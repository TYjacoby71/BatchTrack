---
title: BatchTrack Operations Guide
description: Plain-language walkthrough of the core BatchTrack workflows for both prospective and current users.
---

# BatchTrack Operations Guide

Use this guide as the “public-side” orientation. Each section summarizes what happens inside the app and the mindset you can bring whether you are exploring BatchTrack or already running production on it.

## Provision & Seed the Workspace {#provision-and-seed}
- Install the app (`pip install -r requirements.txt`), run `flask db upgrade`, then seed via `flask init-production`.
- Set `FLASK_APP=run.py` (or use the provided Makefile tasks) and start with `python run.py`.
- Re-run the same steps for staging/preview environments so every teammate sees the same baseline data.

## Manage Organizations, Roles, and Permissions {#organizations-and-permissions}
- Developers live outside any customer org; owners & team members always carry an `organization_id`.
- Use the Organization Dashboard to create custom roles, invite team members, and respect subscription limits.
- In templates and routes, always check `has_permission(...)` so features stay tier-aware.

## Curate the Global Item Library {#global-library}
- Seed curated ingredients/containers via `scripts/seed_global_items_from_density_reference.py`.
- Maintain data through `/developer/global-items`; customers only link to entries, they never edit them.
- Metadata (summary, use cases, FAQs) is generated automatically when new `GlobalItem`s are inserted or synced.

## Create Inventory from Global Templates {#inventory-creation}
- Use the Drawer Picker to select a `GlobalItem`; identity fields lock while org-specific fields stay editable.
- Track quantity, lot, cost, expiration, and ownership (`global` vs `org`) on the `InventoryItem`.
- All quantity changes go through the Inventory Adjustment Service so FIFO history stays accurate.

### Step-by-Step: Add Inventory {#add-inventory}
1. **Navigate** to `Inventory → Add Inventory Item` (`/inventory/new`).
2. **Search** for an existing entry in the global drawer; if you must create a custom one, keep identity fields tight since they become your org’s source of truth.
3. **Confirm** the locked identity banner (shows when linked to a global item).
4. **Enter stock data:**
   - Default unit + conversion shortcuts.
   - Starting quantity and cost per unit.
   - Location, lot, expiration, ownership flag (global/org).
5. **Save & restock** through the Inventory Adjustment modal if you need to add immediate FIFO lots.
6. **Automations:** density, perishable defaults, and metadata flow down automatically from the library.

## Author Recipes & Category Data {#recipes}
- Ingredients, consumables, and containers are defined under each recipe; category-specific JSON lives in `recipe.category_data`.
- Link recipe lines to inventory/global items wherever possible for density-aware conversions.
- Store portioning defaults (names, units, counts) before planning production.

### Step-by-Step: Create a Recipe {#add-recipe}
1. **Navigate** to `Recipes → New Recipe` (`/recipes/new`).
2. **Choose** a category (soap, candle, lotion, etc.); this unlocks category-specific fields like lye ratios or wick data.
3. **Fill basics:** recipe name, description, production category, default yield/unit, portion info if applicable.
4. **Add lines:**
   - Ingredients tab: each row links to an inventory or global item for density + costing.
   - Consumables tab: record supplies consumed per batch.
   - Containers tab: specify vessels/packaging tied to the finished product.
5. **Attach instructions** or SOPs in the notes section so PlanSnapshot surfaces them later.
6. **Save**, then run a stock check (via Production Planning) to confirm availability before starting a batch.

## Plan Production with PlanSnapshot {#plan-snapshot}
- `PlanProductionService.build_plan()` freezes scaled ingredients, consumables, containers, and portioning.
- Send the snapshot untouched to `POST /batches/api/start-batch`; it becomes the immutable `batch.plan_snapshot`.
- Any recipe edits after planning will never mutate in-progress batches thanks to this snapshot.

## Start, Monitor, and Finish Batches {#batches}
- Starting a batch deducts inventory through FIFO, records projected yield, and spawns batch rows for ingredients, consumables, and containers.
- Track progress by comparing actual usage to the snapshot, add extras when needed, and finish to record final yield & spawn products.
- Timers, reservations, and alerts close out automatically when the batch completes.

### Step-by-Step: Plan & Start Production {#plan-production}
1. **Open** `Production Planning` (`/production-planning` or the “Plan Production” button in `Recipes`).
2. **Select** a recipe, choose batch type (ingredient/product), and set the scale factor.
3. **Review** stock check results; fix shortages via drawers if needed.
4. **Lock containers & portioning** selections, then generate the PlanSnapshot preview.
5. **Submit** the snapshot; the UI calls `POST /production/plan` (internal) followed by `POST /batches/api/start-batch`.
6. **Monitor** the in-progress batch view:
   - Planned quantities live in the snapshot pane.
   - Actual usage updates as team members record pulls or extras.
   - Timers, reservations, and alerts stay in sync.
7. **Finish Batch:** record actual yield/unit, confirm outputs, and trigger downstream steps (product SKUs, reservations, exports).

## Restock, Deduct, and Audit Inventory {#inventory-adjustments}
- Use helpers like `adjust_inventory`, `restock_inventory`, and `record_spoilage` with explicit reasons and supplier/cost info.
- Drawer payloads surface when density or unit mapping data is missing, helping users fix issues without leaving the workflow.
- Every adjustment writes to inventory history and keeps FIFO lots in sync.

## Track Expiration, Alerts, and Reservations {#alerts}
- Expiration Service derives shelf-life from inventory & global defaults; alerts roll up through Dashboard Alert Service.
- Reservation Service blocks finished goods for customers, and Combined Inventory Alert Service unifies stock + expiration warnings.
- Dashboards surface the highest-priority alerts first with contextual links.

## Manage Products, SKUs, and Outputs {#products}
- **Source Docs:** `app/services/product_service.py`, `app/services/reservation_service.py`.
- **Steps:** When finishing batches, push outputs through Product Service to create/update SKUs, optionally create reservations, sync costing with FIFO data.

### Step-by-Step: Create Product Variants {#product-variants}
1. **Navigate** to `Products → All Products` (`/products`).
2. **Create or select** a base product that represents the customer-facing SKU.
3. **Open** the Variants tab (`/products/<id>/variants`):
   - Define variant attributes (size, scent, color).
   - Map each variant to the containers/ingredients it consumes.
   - Set target inventory thresholds so reservations and alerts stay accurate.
4. **Link** batches to variants when finishing production so finished goods automatically restock the correct SKU.
5. **Use reservations** (`/products/<id>/reservations`) to hold variant stock for specific orders before fulfillment.

## Use Public Tools, Drafts, and Exports {#public-tools}
- `/tools` hosts calculators (soap, candles, lotions, herbal, baker) that anyone can use before signing up.
- Drafts post to `/tools/draft`, store in session, and auto-fill `/recipes/new` after the user authenticates.
- `/exports/...` routes render HTML, CSV, and PDF for both authenticated recipes and public drafts.

### Step-by-Step: Draft a Recipe via Public Tools {#public-draft}
1. Visit `/tools` and choose a calculator aligned with your workflow.
2. Use the inline typeahead to pull global ingredients, consumables, and containers.
3. When ready, hit **Save to BatchTrack**; the payload posts to `/tools/draft`.
4. Sign up or log in; `/recipes/new` will detect the session draft and preload every line.
5. Convert the draft into a formal recipe, tweak metadata, and save.

## Integrate via APIs & Webhooks {#api}
- Authenticated APIs follow Flask-Login sessions; developer-only endpoints allow org impersonation for support.
- Drawer endpoints (`/api/drawer-actions/...`) feed missing data modals, keeping flows recoverable.
- Public APIs are intentionally narrow: global-item search, unit listings, and unit conversion for the calculators.

## Billing, Tiers, and Feature Flags {#billing}
- Stripe webhooks update the Billing Snapshot, which the Billing Service uses to enforce feature and user limits.
- `has_subscription_feature(...)` toggles UI features per tier; developer-only feature flags live in `settings.json`.
- Keep `docs/changelog` and `docs/system/FREE_TIER.md` updated when pricing or limits change.

## Deployments, Migrations, and Monitoring {#devops}
- Every schema change gets an Alembic migration; run them in org-safe order and never bypass services.
- Middleware enforces security headers and logs unauthenticated hits; monitor logs plus the churn in `docs/changelog`.
- Post-release, update the CAQ (below) when new patterns emerge so the public side always reflects the live system.
