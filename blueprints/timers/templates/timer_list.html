{% extends "layout.html" %}
{% block content %}
<div class="container" x-data="timerManager">
  <h2>Timer Management</h2>

  <!-- Timer List -->
  <div class="table-responsive">
    <table class="table" x-show="timers.length > 0">
      <thead>
        <tr>
          <th>Batch</th>
          <th>Label</th>
          <th>Duration</th>
          <th>Time Left</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <template x-for="timer in timers" :key="timer.id">
          <tr>
            <td x-text="timer.batch_id || '(Manual)'"></td>
            <td x-text="timer.name"></td>
            <td x-text="timer.duration_seconds + ' seconds'"></td>
            <td x-text="calculateTimeLeft(timer)"></td>
            <td>
              <span x-text="timer.status" :class="{
                'badge bg-success': timer.status === 'completed',
                'badge bg-primary': timer.status === 'active'
              }"></span>
            </td>
            <td>
              <button 
                x-show="timer.status !== 'completed'"
                @click="completeTimer(timer.id)" 
                class="btn btn-sm btn-primary">
                Mark Complete
              </button>
              <button 
                @click="deleteTimer(timer.id)"
                class="btn btn-sm btn-danger">
                Delete
              </button>
            </td>
          </tr>
        </template>
      </tbody>
    </table>

    <div x-show="timers.length === 0" class="alert alert-info">
      No active timers found.
    </div>
  </div>

  <!-- New Timer Form -->
  <div class="mt-4">
    <button 
      x-show="!addingTimer"
      @click="addingTimer = true" 
      class="btn btn-primary">
      Add New Timer
    </button>

    <div x-show="addingTimer" class="card mt-3">
      <div class="card-body">
        <form @submit.prevent="createTimer">
          <div class="mb-3">
            <label class="form-label">Batch</label>
            <select class="form-control" x-model="newTimer.batch_id" required>
              <option value="">Select a batch</option>
              <template x-for="batch in activeBatches" :key="batch.id">
                <option :value="batch.id" x-text="`Batch #${batch.id} - ${batch.recipe_name || 'No Recipe'}`"></option>
              </template>
            </select>
          </div>
          <div class="mb-3">
            <label class="form-label">Timer Label</label>
            <input type="text" class="form-control" x-model="newTimer.name" required>
          </div>
          <!-- Updated duration input -->
          <div class="mb-3">
            <label class="form-label">Duration (H:M:S)</label>
            <div class="d-flex gap-2">
              <input type="number" class="form-control" x-model="hours" placeholder="H" min="0">
              <input type="number" class="form-control" x-model="minutes" placeholder="M" min="0" max="59">
              <input type="number" class="form-control" x-model="seconds" placeholder="S" min="0" max="59">
            </div>
          </div>
          <div class="d-flex gap-2">
            <button type="submit" class="btn btn-success">Create Timer</button>
            <button type="button" @click="addingTimer = false" class="btn btn-secondary">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('alpine:init', () => {
  Alpine.data('timerManager', () => ({
    timers: {{ timers|tojson|safe }},
    activeBatches: {{ active_batches|tojson|safe }},
    addingTimer: false,
    hours: '',
    minutes: '',
    seconds: '',
    newTimer: {
      name: '',
      duration_seconds: '',
      batch_id: ''
    },
    init() {
      setInterval(() => {
        this.timers = this.timers.map(timer => {
          const currentTimer = {...timer};
          if (currentTimer.status === 'completed') {
            return currentTimer;
          }
          return currentTimer;
        });
      }, 1000);
    },
    calculateTotalSeconds() {
      const h = parseInt(this.hours || 0);
      const m = parseInt(this.minutes || 0);
      const s = parseInt(this.seconds || 0);
      return (h * 3600) + (m * 60) + s;
    },
    async createTimer() {
      const totalSeconds = this.calculateTotalSeconds();
      if (totalSeconds < 1) {
        alert('Please enter a valid duration');
        return;
      }
      this.newTimer.duration_seconds = totalSeconds;
      const response = await fetch('/timers/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify(this.newTimer)
      });

      const result = await response.json();
      if (result.status === 'success') {
        this.timers.push({
          ...this.newTimer,
          id: result.timer_id,
          start_time: new Date().toISOString(),
          status: 'active'
        });
        this.newTimer = {
          name: '',
          duration_seconds: '',
          batch_id: ''
        };
        this.addingTimer = false;
      }
    },

    formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const remainingSeconds = seconds % 60;
      
      if (hours > 0) {
        return `${hours}h ${minutes}m ${remainingSeconds}s`;
      }
      return `${minutes}m ${remainingSeconds}s`;
    },

    calculateTimeLeft(timer) {
        if (timer.status === 'completed') {
          return 'User Ended';
        }
        if (!timer.start_time) return 'Not Started';

        const start = new Date(timer.start_time);
        const now = new Date();
        const elapsedSeconds = Math.floor((now - start) / 1000);
        const remainingSeconds = Math.max(0, timer.duration_seconds - elapsedSeconds);

        if (remainingSeconds <= 0) {
          if (timer.status === 'active') {
            this.completeTimer(timer.id);
          }
          return 'Expired';
        }

        return this.formatDuration(remainingSeconds);
    },

    async deleteTimer(timerId) {
      const response = await fetch(`/timers/delete/${timerId}`, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      if (response.ok) {
        this.timers = this.timers.filter(timer => timer.id !== timerId);
      }
    },

    async completeTimer(timerId) {
      const response = await fetch(`/timers/complete/${timerId}`, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      if (response.ok) {
        const result = await response.json();
        this.timers = this.timers.map(timer => {
          if (timer.id === timerId) {
            return {
              ...timer,
              status: 'completed',
              end_time: result.end_time
            };
          }
          return timer;
        });
      }
    },

    init() {
      this.timers = this.timers.map(timer => ({
        ...timer,
        duration_seconds: timer.original_duration
      }));
      
      setInterval(() => {
        this.timers = this.timers.map(timer => ({
          ...timer,
          status: timer.status === 'pending' && 
                 this.calculateTimeLeft(timer) === 'Expired' ? 'expired' : timer.status
        }));
      }, 1000);
    }
  }));
});
</script>
{% endblock %}