{% extends "layout.html" %}
{% block content %}
<div class="container" x-data="timerManager">
  <h2>Timer Management</h2>

  <!-- Timer List -->
  <div class="table-responsive">
    <table class="table" x-show="timers.length > 0">
      <thead>
        <tr>
          <th>Batch</th>
          <th>Label</th>
          <th>Duration</th>
          <th>Time Left</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <template x-for="timer in timers" :key="timer.id">
          <tr>
            <td x-text="timer.batch_id || '(Manual)'"></td>
            <td x-text="timer.name"></td>
            <td x-text="timer.duration_seconds + ' seconds'"></td>
            <td x-text="calculateTimeLeft(timer)"></td>
            <td>
              <span x-text="timer.status" :class="{
                'badge bg-success': timer.status === 'completed',
                'badge bg-primary': timer.status === 'active'
              }"></span>
            </td>
            <td>
              <button 
                x-show="timer.status !== 'completed'"
                @click="completeTimer(timer.id)" 
                class="btn btn-sm btn-primary">
                Mark Complete
              </button>
            </td>
          </tr>
        </template>
      </tbody>
    </table>

    <div x-show="timers.length === 0" class="alert alert-info">
      No active timers found.
    </div>
  </div>

  <!-- New Timer Form -->
  <div class="mt-4">
    <button 
      x-show="!addingTimer"
      @click="addingTimer = true" 
      class="btn btn-primary">
      Add New Timer
    </button>

    <div x-show="addingTimer" class="card mt-3">
      <div class="card-body">
        <form @submit.prevent="createTimer">
          <div class="mb-3">
            <label class="form-label">Batch</label>
            <select class="form-control" x-model="newTimer.batch_id" required>
              <option value="">Select a batch</option>
              <template x-for="batch in activeBatches" :key="batch.id">
                <option :value="batch.id" x-text="`Batch #${batch.id} - ${batch.recipe_name || 'No Recipe'}`"></option>
              </template>
            </select>
          </div>
          <div class="mb-3">
            <label class="form-label">Timer Label</label>
            <input type="text" class="form-control" x-model="newTimer.name" required>
          </div>
          <div class="mb-3">
            <label class="form-label">Duration (seconds)</label>
            <input type="number" class="form-control" x-model="newTimer.duration_seconds" required min="1">
          </div>
          <div class="d-flex gap-2">
            <button type="submit" class="btn btn-success">Create Timer</button>
            <button type="button" @click="addingTimer = false" class="btn btn-secondary">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('alpine:init', () => {
  Alpine.data('timerManager', () => ({
    timers: {{ timers|tojson|safe }},
    activeBatches: {{ active_batches|tojson|safe }},
    addingTimer: false,
    newTimer: {
      name: '',
      duration_seconds: '',
      batch_id: ''
    },
    async createTimer() {
      const response = await fetch('/timers/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify(this.newTimer)
      });

      const result = await response.json();
      if (result.status === 'success') {
        this.timers.push({
          ...this.newTimer,
          id: result.timer_id,
          start_time: new Date().toISOString(),
          status: 'active'
        });
        this.newTimer = {
          name: '',
          duration_seconds: '',
          batch_id: ''
        };
        this.addingTimer = false;
      }
    },

    calculateTimeLeft(timer) {
        if (timer.status === 'completed') {
          return 'User Ended';
        }
        if (!timer.start_time) return 'Not Started';
        const start = new Date(timer.start_time);
        const now = new Date();
        const duration = timer.duration_seconds * 1000;
        const diff = (start.getTime() + duration) - now.getTime();

        if (diff <= 0) {
          if (timer.status === 'active') {
            this.completeTimer(timer.id);
          }
          return 'Expired';
        }

        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        return `${minutes}m ${seconds}s`;
    },

    async createTimer() {
      const response = await fetch('/timers/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify(this.newTimer)
      });

      const result = await response.json();
      if (result.status === 'success') {
        this.timers.push({
          ...this.newTimer,
          id: result.timer_id,
          start_time: new Date().toISOString(),
          status: 'active'
        });
        this.newTimer.name = '';
        this.newTimer.duration_seconds = '';
        this.addingTimer = false;
      }
    },

    async completeTimer(timerId) {
      const response = await fetch(`/timers/complete/${timerId}`, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      if (response.ok) {
        const timer = this.timers.find(t => t.id === timerId);
        if (timer) {
          timer.status = 'completed';
        }
      }
    },

    init() {
      setInterval(() => {
        this.timers = this.timers.map(timer => ({
          ...timer,
          status: timer.status === 'pending' && 
                 this.calculateTimeLeft(timer) === 'Expired' ? 'expired' : timer.status
        }));
      }, 1000);
    }
  }));
});
</script>
{% endblock %}