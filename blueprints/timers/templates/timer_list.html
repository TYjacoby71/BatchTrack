{% extends "layout.html" %}
{% block content %}
<div class="container" x-data="timerManager">
  <h2>Timer Management</h2>

  <!-- Timer List -->
  <div class="table-responsive">
    <table class="table" x-show="timers.length > 0">
      <thead>
        <tr>
          <th>Batch</th>
          <th>Label</th>
          <th>Duration</th>
          <th>Time Left</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <template x-for="timer in timers" :key="timer.id">
          <tr>
            <td x-text="timer.batch_id || '(Manual)'"></td>
            <td x-text="timer.name"></td>
            <td x-text="formatDuration(timer.duration_seconds)"></td>
            <td x-text="calculateTimeLeft(timer)"></td>
            <td>
              <span x-text="timer.status" :class="{
                'badge bg-success': timer.status === 'completed',
                'badge bg-primary': timer.status === 'active'
              }"></span>
            </td>
            <td>
              <button 
                x-show="timer.status !== 'completed'"
                @click="completeTimer(timer.id)" 
                class="btn btn-sm btn-primary">
                Mark Complete
              </button>
              <button 
                @click="deleteTimer(timer.id)"
                class="btn btn-sm btn-danger">
                Delete
              </button>
            </td>
          </tr>
        </template>
      </tbody>
    </table>

    <div x-show="timers.length === 0" class="alert alert-info">
      No active timers found.
    </div>
  </div>

  <!-- New Timer Form -->
  <div class="mt-4">
    <button 
      x-show="!addingTimer"
      @click="addingTimer = true" 
      class="btn btn-primary">
      Add New Timer
    </button>

    <div x-show="addingTimer" class="card mt-3">
      <div class="card-body">
        <form @submit.prevent="createTimer">
          <div class="mb-3">
            <label class="form-label">Batch</label>
            <select class="form-control" x-model="newTimer.batch_id">
              <option value="">Select a batch</option>
              <template x-for="batch in activeBatches" :key="batch.id">
                <option :value="batch.id" x-text="`Batch #${batch.id} - ${batch.recipe_name || 'No Recipe'}`"></option>
              </template>
            </select>
          </div>
          <div class="mb-3">
            <label class="form-label">Timer Label</label>
            <input type="text" class="form-control" x-model="newTimer.name" required>
          </div>
          <div class="mb-3">
            <label class="form-label">Duration (e.g. "1h 30m" or "90m" or "3600")</label>
            <input type="text" class="form-control" x-model="duration" placeholder="Enter duration">
          </div>
          <div class="d-flex gap-2">
            <input type="number" class="form-control" x-model="hours" placeholder="H" min="0">
              <input type="number" class="form-control" x-model="minutes" placeholder="M" min="0">
              <input type="number" class="form-control" x-model="seconds" placeholder="S" min="0">
          </div>
          <div class="d-flex gap-2">
            <button type="submit" class="btn btn-success">Create Timer</button>
            <button type="button" @click="addingTimer = false" class="btn btn-secondary">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('alpine:init', () => {
  Alpine.data('timerManager', () => ({
    timers: {{ timers|tojson|safe }},
    activeBatches: {{ active_batches|tojson|safe }},
    addingTimer: false,
    hours: '',
    minutes: '',
    seconds: '',
    newTimer: {
      name: '',
      batch_id: '',
      duration_seconds: null
    },

    init() {
      this.updateTimers();
    },

    updateTimers() {
      setInterval(() => {
        this.timers = this.timers.map(timer => ({
          ...timer,
          status: timer.status === 'active' && 
                 this.calculateTimeLeft(timer) === 'Expired' ? 'expired' : timer.status
        }));
      }, 1000);
    },

    formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const remainingSeconds = seconds % 60;

      if (hours > 0) {
        return `${hours}h ${minutes}m ${remainingSeconds}s`;
      }
      return `${minutes}m ${remainingSeconds}s`;
    },

    calculateTimeLeft(timer) {
        if (timer.status === 'completed') return 'User Ended';
        if (!timer.start_time) return 'Not Started';

        const start = new Date(timer.start_time + 'Z');
        const now = new Date();
        const totalSeconds = parseInt(timer.duration_seconds);
        const elapsedSeconds = Math.floor((now - start) / 1000);
        const remainingSeconds = Math.max(0, totalSeconds - elapsedSeconds);

      if (remainingSeconds <= 0) {
        if (timer.status === 'active') {
          this.completeTimer(timer.id);
        }
        return 'Expired';
      }

      return this.formatDuration(remainingSeconds);
    },

    parseTimeInput(input) {
      if (!input) return 0;

      // Check if input is just a number (assumed seconds)
      if (/^\d+$/.test(input.toString())) {
        return parseInt(input);
      }

      // Try to parse "1h 30m" or "90m" style input
      const matches = input.toString().toLowerCase().match(/(?:(\d+)h)?\s*(?:(\d+)m)?\s*(?:(\d+)s?)?/);
      if (matches) {
        const hours = parseInt(matches[1] || 0);
        const minutes = parseInt(matches[2] || 0);
        const seconds = parseInt(matches[3] || 0);
        return (hours * 3600) + (minutes * 60) + seconds;
      }

      return 0;
    },

    calculateTotalSeconds() {
      const timeStr = `${this.hours || ''}h ${this.minutes || ''}m ${this.seconds || ''}s`;
      return this.parseTimeInput(timeStr);
    },

    async createTimer() {
      const totalSeconds = this.parseTimeInput(this.duration);
      if (totalSeconds < 1) {
        alert('Please enter a valid duration (e.g. "1h 30m" or "90m" or "3600")');
        return;
      }

      const timerData = {
        name: this.newTimer.name,
        batch_id: this.newTimer.batch_id || null,
        duration_seconds: totalSeconds
      };

      const response = await fetch('/timers/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify(timerData)
      });

      const result = await response.json();
      if (result.status === 'success') {
        this.timers.push({
          ...timerData,
          id: result.timer_id,
          start_time: new Date().toISOString(),
          status: 'active',
          original_duration: totalSeconds
        });

        // Reset form
        this.newTimer.name = '';
        this.newTimer.batch_id = '';
        this.hours = '';
        this.minutes = '';
        this.seconds = '';
        this.addingTimer = false;
      }
    },

    async deleteTimer(timerId) {
      const response = await fetch(`/timers/delete/${timerId}`, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      if (response.ok) {
        this.timers = this.timers.filter(timer => timer.id !== timerId);
      }
    },

    async completeTimer(timerId) {
      const response = await fetch(`/timers/complete/${timerId}`, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      if (response.ok) {
        const result = await response.json();
        this.timers = this.timers.map(timer => 
          timer.id === timerId ? {
            ...timer,
            status: 'completed',
            end_time: result.end_time
          } : timer
        );
      }
    }
  }));
});
</script>
{% endblock %}