Yep—still on-track for PR3. No goal drift. These fails are all the same theme: “use the canonical helpers exactly as the tests expect” + a couple schema/model nits. Here’s the tight fix list mapping 1:1 to the errors:

What to change
1) Make the canonical service accept the args tests pass

app/services/inventory_adjustment.py

Ensure signature matches calls:

py
Copy
Edit
def process_inventory_adjustment(
    item_id: int,
    quantity: float,
    change_type: str,
    unit: str | None = None,
    notes: str | None = None,
    created_by: int | None = None,
    cost_override: float | None = None,
    item_type: str | None = None,
    **_
) -> bool:
    ...
Return True/False.

2) Make audit helper easy to patch and not require quantity

In the same file, relax audit signature:

py
Copy
Edit
def record_audit_entry(
    item_id: int,
    change_type: str,
    notes: str,
    quantity: float | None = None,
    fifo_reference_id: int | None = None,
    source: str | None = None,
) -> None:
    ...
(The error log shows it tried to run the real function.) In app/blueprints/products/products.py, call through the module so the test patch hits:

py
Copy
Edit
import app.services.inventory_adjustment as inv

def _write_product_created_audit(variant):
    inv.record_audit_entry(
        item_id=variant.id,
        change_type="product_created",
        notes=f"Product variant created: {variant.name}",
    )
(Avoid from ... import record_audit_entry so the pre-bound symbol doesn’t bypass their patch.)

3) Ensure the routes expose the exact symbol the tests patch

app/blueprints/inventory/routes.py

py
Copy
Edit
from app.services.inventory_adjustment import process_inventory_adjustment  # keep at module scope

# When handling recount / initial stock:
process_inventory_adjustment(
    item_id=item.id,
    quantity=float(form_quantity),
    change_type="restock" or "recount",
    unit=item.unit or input_unit,
    notes=form_notes,
    created_by=current_user.id,
    cost_override=cost_per_unit_if_any,
)
The tests patch app.blueprints.inventory.routes.process_inventory_adjustment, so call the module-level name, not services.process_inventory_adjustment.

4) Expiration service must delegate to canonical service

app/blueprints/expiration/services.py

py
Copy
Edit
from app.services.inventory_adjustment import process_inventory_adjustment

class ExpirationService:
    @staticmethod
    def mark_as_expired(kind, entry_id, quantity, notes=""):
        if kind == "fifo":
            entry = InventoryHistory.query.get(entry_id)
            return process_inventory_adjustment(
                item_id=entry.inventory_item_id,
                quantity=-quantity,
                change_type="spoil",
                unit=entry.unit,
                notes=f"Expired lot disposal #{entry_id}: {notes}",
                created_by=current_user.id if getattr(current_user, "is_authenticated", False) else None,
            ), "ok"
        if kind == "product":
            entry = ProductSKUHistory.query.get(entry_id)
            return process_inventory_adjustment(
                item_id=entry.inventory_item_id,
                quantity=-quantity,
                change_type="spoil",
                unit=entry.unit,
                notes=f"Expired product lot disposal #{entry_id}: {notes}",
                created_by=current_user.id if getattr(current_user, "is_authenticated", False) else None,
                item_type="product",
            ), "ok"
(This makes those assert_called_once_with(...) pass.)

5) Fix NOT NULL on FIFO “layer” rows used by tests

InventoryHistory model

Make these nullable:

py
Copy
Edit
change_type = db.Column(db.String, nullable=True)
quantity_change = db.Column(db.Float, nullable=True)
The tests create a bare layer with only remaining_quantity and unit; your current NOT NULLs cause the insert error.

6) Make ProductSKU.quantity settable

In ProductSKU:

Either map a real column:

py
Copy
Edit
quantity = db.Column(db.Float, default=0.0)
Or, if it’s a computed @hybrid_property, add a setter that stores into a backing column (e.g., _quantity = db.Column(db.Float, default=0.0)):

py
Copy
Edit
@hybrid_property
def quantity(self): return self._quantity or 0.0
@quantity.setter
def quantity(self, v): self._quantity = v
The POS test passes quantity=100 to the constructor; without a setter you get the “no setter” error.

7) (Nice-to-have) Unit fallback

Your logs show FallbackUnit not defined. Define/import it or gate that path; not currently causing fails but it’s noisy.

Why these fixes match the failures
assert_called_once_with(...) failures → your code bypassed the patched symbol or didn’t call the canonical helper; the import/usage changes fix that.

unexpected keyword arg 'created_by' → expand the canonical function signature.

NOT NULL constraint on inventory_history.quantity_change → make nullable for setup rows.

ProductSKU.quantity has no setter → add setter or column.

Ping me after you push these and re-run; we should drop to green (or at worst a tiny assertion tweak). Still