============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 49 items                                                             

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit PASSED [  2%]
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit PASSED [  4%]
tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_decorator_allows_with_permission PASSED [  6%]
tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_returns_json_for_api FAILED [  8%]
tests/test_auth_permissions.py::TestAuthPermissions::test_any_permission_required_decorator PASSED [ 10%]
tests/test_auth_permissions.py::TestAuthPermissions::test_tier_required_decorator PASSED [ 12%]
tests/test_auth_permissions.py::TestAuthPermissions::test_user_has_any_permission_method PASSED [ 14%]
tests/test_auth_permissions.py::TestAuthPermissions::test_api_unauth_returns_json_401 FAILED [ 16%]
tests/test_auth_permissions.py::TestAuthPermissions::test_web_unauth_redirects_to_login PASSED [ 18%]
tests/test_auth_permissions.py::TestAuthPermissions::test_csrf_token_available_in_templates PASSED [ 20%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling PASSED [ 22%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[active-200] PASSED [ 24%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] FAILED [ 26%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] FAILED [ 28%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] FAILED [ 30%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_developer_can_masquerade_regardless_of_billing PASSED [ 32%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_complete_security_cascade PASSED [ 34%]
tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment PASSED [ 36%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service PASSED [ 38%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service PASSED [ 40%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists PASSED [ 42%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists PASSED [ 44%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists PASSED [ 46%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path PASSED [ 48%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist PASSED [ 51%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status PASSED [ 53%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state PASSED [ 55%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED [ 57%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order PASSED [ 59%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly PASSED [ 61%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service FAILED [ 63%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 65%]
tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service PASSED [ 67%]
tests/test_pos_integration_canonicalization.py::TestPOSIntegrationCanonicalService::test_reserve_inventory_calls_canonical_service PASSED [ 69%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_creation_flow PASSED [ 71%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints PASSED [ 73%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_service_exists PASSED [ 75%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_creation_validation PASSED [ 77%]
tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release PASSED [ 79%]
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit PASSED [ 81%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists PASSED [ 83%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior PASSED [ 85%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment PASSED [ 87%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists PASSED [ 89%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation PASSED [ 91%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_exists PASSED [ 93%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_signature_verification_path_exists PASSED [ 95%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_idempotency_behavior PASSED [ 97%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_methods_exist PASSED [100%]

======================================= FAILURES ========================================
___________ TestAuthPermissions.test_permission_required_returns_json_for_api ___________

self = <tests.test_auth_permissions.TestAuthPermissions object at 0x7fbf4e3db910>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>

    def test_permission_required_returns_json_for_api(self, app, client):
        """Test that API endpoints return JSON when permission denied"""
        with app.app_context():
            @app.route('/api/test-perm')
            @permission_required('test.permission')
            def api_test_route():
                return {'status': 'success'}
    
            response = client.get('/api/test-perm')
            # Should return JSON unauthorized response
>           assert response.status_code == 401
E           assert 200 == 401
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_auth_permissions.py:33: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
_________________ TestAuthPermissions.test_api_unauth_returns_json_401 __________________

self = <tests.test_auth_permissions.TestAuthPermissions object at 0x7fbf4e3ed590>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>

    def test_api_unauth_returns_json_401(self, app, client):
        """Test that API endpoints return 401 JSON when unauthorized"""
        with app.app_context():
            @app.route("/api/_perm_test")
            @permission_required("some.permission")
            def _p():
                return {"ok": True}
    
            resp = client.get("/api/_perm_test", headers={"Accept": "application/json"})
>           assert resp.status_code == 401
E           assert 200 == 401
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_auth_permissions.py:77: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
______ TestBillingAndTierEnforcement.test_billing_status_enforcement[past_due-302] ______

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7fbf4e3f8f50>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755289990969344>, billing_status = 'past_due'
expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client:
                with client.session_transaction() as sess:
                    sess['_user_id'] = str(test_user.id)
                    sess['_fresh'] = True
    
                response = client.get('/_protected_dashboard')
    
                # ASSERT
>               assert response.status_code == expected_status_code
E               assert 200 == 302
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:103: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
_____ TestBillingAndTierEnforcement.test_billing_status_enforcement[suspended-302] ______

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7fbf4e3f9090>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755289992210812>, billing_status = 'suspended'
expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client:
                with client.session_transaction() as sess:
                    sess['_user_id'] = str(test_user.id)
                    sess['_fresh'] = True
    
                response = client.get('/_protected_dashboard')
    
                # ASSERT
>               assert response.status_code == expected_status_code
E               assert 200 == 302
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:103: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
______ TestBillingAndTierEnforcement.test_billing_status_enforcement[canceled-302] ______

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7fbf4e3f91d0>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755289993648140>, billing_status = 'canceled'
expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client:
                with client.session_transaction() as sess:
                    sess['_user_id'] = str(test_user.id)
                    sess['_fresh'] = True
    
                response = client.get('/_protected_dashboard')
    
                # ASSERT
>               assert response.status_code == expected_status_code
E               assert 200 == 302
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:103: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
____________________ test_recount_adjustment_uses_canonical_service _____________________

client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fbf4eb592d0>
test_user = <User testuser_1755290012804987>

    def test_recount_adjustment_uses_canonical_service(client, app, db_session, test_user):
        """Test that inventory recount routes use the canonical adjustment service"""
    
        with app.app_context():
            # Create test inventory item
            item = InventoryItem(
                name="Test Item",
                quantity=100,
                unit="count",
                organization_id=test_user.organization_id
            )
            db_session.add(item)
            db_session.commit()
    
            # Log in the user for the test
            with client.session_transaction() as sess:
                sess['_user_id'] = str(test_user.id)
                sess['_fresh'] = True
    
            # Mock the canonical service
            with patch('app.services.inventory_adjustment.process_inventory_adjustment') as mock_adjustment:
                mock_adjustment.return_value = True
    
                # Make recount request
                response = client.post(f'/inventory/adjust/{item.id}', data={
                    'adjustment_type': 'recount',
                    'quantity': '80',
                    'notes': 'Physical count adjustment'
                })
    
                # Verify canonical service was called
>               mock_adjustment.assert_called_once()

tests/test_inventory_routes_canonicalization.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='process_inventory_adjustment' id='140459578890832'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
--------------------------------- Captured stdout call ----------------------------------
RECOUNT: Test Item - FIFO total: 0, target: 80.0, delta: 80.0
----------------------------------- Captured log call -----------------------------------
INFO     app.services.inventory_adjustment._core:_core.py:33 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=80.0, change_type=recount, caller=app/blueprints/inventory/routes.py:adjust_inventory
INFO     app.services.inventory_adjustment._core:_core.py:44 RECOUNT: Processing recount from 100.0 to 80.0
INFO     app.services.inventory_adjustment._core:_core.py:33 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=80.0, change_type=restock, caller=app/services/inventory_adjustment/_recount_logic.py:handle_recount_adjustment
INFO     app.services.inventory_adjustment._fifo_ops:_fifo_ops.py:237 FIFO: Updating inventory item 1 quantity: 100.0 â†’ 180.0
ERROR    app.services.inventory_adjustment._audit:_audit.py:107 Failed to record audit entry for item 1: (builtins.ValueError) could not convert string to float: 'Physical count adjustment - Added 80.0'
[SQL: INSERT INTO unified_inventory_history (inventory_item_id, timestamp, change_type, quantity_change, unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id, created_by, notes, quantity_used, used_for_batch_id, is_perishable, shelf_life_days, expiration_date, location_id, location_name, temperature_at_time, quality_status, compliance_status, quality_checked_by, customer, sale_price, order_id, reservation_id, is_reserved, sale_location, marketplace_order_id, marketplace_source, batch_number, lot_number, container_id, fifo_source, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
[parameters: [{'inventory_item_id': 1, 'quantity_change': 'Physical count adjustment - Added 80.0', 'organization_id': 2, 'change_type': 'restock', 'fifo_code': 'TX ... (544 characters truncated) ... ch_id': None, 'container_id': None, 'temperature_at_time': None, 'quality_status': None, 'batch_id': None, 'reservation_id': None, 'created_by': None}]]
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

self = <tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7fbf4de14590>
mock_route_user = <AsyncMock name='current_user' id='140459559149264'>
mock_middleware_user = <AsyncMock name='current_user' id='140459557799568'>
mock_item = <MagicMock name='InventoryItem' id='140459563871376'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140459561603344'>
client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>

    @patch('app.services.inventory_adjustment.process_inventory_adjustment')
    @patch('app.blueprints.inventory.routes.InventoryItem')
    @patch('app.middleware.current_user')
    @patch('app.blueprints.inventory.routes.current_user')
    def test_adjust_inventory_initial_stock_calls_canonical_service(self, mock_route_user, mock_middleware_user, mock_item, mock_process, client, app):
        """Test that initial stock creation calls process_inventory_adjustment"""
        with app.app_context():
            # Mock the inventory item with no history
            mock_inventory_item = MagicMock()
            mock_inventory_item.id = 1
            mock_inventory_item.type = 'ingredient'
            mock_inventory_item.unit = 'g'
            mock_inventory_item.cost_per_unit = 2.5
            mock_inventory_item.is_perishable = False
            mock_inventory_item.organization_id = 1
    
            mock_item.query.get_or_404.return_value = mock_inventory_item
    
            # Configure both middleware and route user mocks
            for mock_user in [mock_route_user, mock_middleware_user]:
                mock_user.id = 1
                mock_user.organization_id = 1
                mock_user.is_authenticated = True
                mock_user.user_type = 'regular'
                mock_user.organization = MagicMock()
                mock_user.organization.is_active = True
    
            mock_process.return_value = True
    
            # Log in the mock user for the test
            with client.session_transaction() as sess:
                sess['_user_id'] = str(mock_route_user.id)
                sess['_fresh'] = True
    
            # Mock UnifiedInventoryHistory count to simulate no existing history
            with patch('app.blueprints.inventory.routes.UnifiedInventoryHistory') as mock_history:
                mock_history.query.filter_by.return_value.count.return_value = 0
    
                # Make POST request to adjust inventory
                response = client.post('/inventory/adjust/1', data={
                    'adjustment_type': 'restock',
                    'quantity': '100.0',
                    'input_unit': 'g',
                    'notes': 'Initial stock',
                    'cost_entry_type': 'per_unit',
                    'cost_per_unit': '3.0'
                })
    
                # Verify canonical service was called
>               mock_process.assert_called_once()

tests/test_inventory_routes_canonicalization.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='process_inventory_adjustment' id='140459561603344'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError
---------------------------------- Captured log setup -----------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
=================================== warnings summary ====================================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_auth_permissions.py: 8 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_audit_canonicalization.py: 2 warnings
tests/test_auth_permissions.py: 8 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 1 warning
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 1 warning
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling
  /home/runner/workspace/app/models/models.py:323: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    role = Role.query.get(assignment.role_id)

tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment
  /home/runner/workspace/app/blueprints/expiration/services.py:545: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    entry = InventoryHistory.query.get(entry_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/app/services/inventory_adjustment/_audit.py:77: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
  /home/runner/workspace/app/services/stock_check.py:71: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(inventory_item_id)

tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/query.py:30: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    rv = self.get(ident)

tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/app/services/inventory_adjustment/_recount_logic.py:20: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ short test summary info ================================
FAILED tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_returns_json_for_api - assert 200 == 401
FAILED tests/test_auth_permissions.py::TestAuthPermissions::test_api_unauth_returns_json_401 - assert 200 == 401
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] - assert 200 == 302
FAILED tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to have been called once. Ca...
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to have been called once. Ca...
================= 7 failed, 42 passed, 104 warnings in 64.70s (0:01:04) =================
