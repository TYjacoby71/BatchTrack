============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 34 items                                                                                                                          

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit FAILED                                         [  2%]
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit FAILED                                                [  5%]
tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment FAILED                                   [  8%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service FAILED      [ 11%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service FAILED   [ 14%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists PASSED                                         [ 17%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists PASSED                                   [ 20%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists PASSED                                [ 23%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path PASSED                                  [ 26%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist PASSED                                  [ 29%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status PASSED                                   [ 32%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state PASSED                                 [ 35%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED                                [ 38%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order ERROR                                      [ 41%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly ERROR                   [ 44%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service ERROR                                 [ 47%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 50%]
tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service FAILED                                           [ 52%]
tests/test_pos_integration_canonicalization.py::TestPOSIntegrationCanonicalService::test_reserve_inventory_calls_canonical_service PASSED [ 55%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_creation_flow PASSED                                          [ 58%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints PASSED                                     [ 61%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_service_exists PASSED                                         [ 64%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_creation_validation PASSED                                        [ 67%]
tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release FAILED                             [ 70%]
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit FAILED                                [ 73%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists PASSED                                        [ 76%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior PASSED                                          [ 79%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment PASSED                                  [ 82%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists PASSED                                      [ 85%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation PASSED                                     [ 88%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_exists PASSED                                   [ 91%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_signature_verification_path_exists PASSED              [ 94%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_idempotency_behavior PASSED                            [ 97%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_methods_exist PASSED                            [100%]

================================================================== ERRORS ===================================================================
_______________________________ ERROR at setup of TestInventoryFIFOCharacterization.test_fifo_deduction_order _______________________________
file /home/runner/workspace/tests/test_inventory_fifo.py, line 15
      def test_fifo_deduction_order(self, app, db_session, test_user, test_org):
E       fixture 'test_user' not found
>       available fixtures: app, auth_headers, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, client, db_session, doctest_namespace, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, runner, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_inventory_fifo.py:15
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_____________________ ERROR at setup of TestInventoryFIFOCharacterization.test_inventory_adjustment_delegates_properly ______________________
file /home/runner/workspace/tests/test_inventory_fifo.py, line 72
      def test_inventory_adjustment_delegates_properly(self, app, db_session, test_user, test_org):
E       fixture 'test_user' not found
>       available fixtures: app, auth_headers, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, client, db_session, doctest_namespace, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, runner, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_inventory_fifo.py:72
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_____________________________________ ERROR at setup of test_recount_adjustment_uses_canonical_service ______________________________________
file /home/runner/workspace/tests/test_inventory_routes_canonicalization.py, line 7
  def test_recount_adjustment_uses_canonical_service(client, app, db_session, test_user):
E       fixture 'test_user' not found
>       available fixtures: app, auth_headers, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, client, db_session, doctest_namespace, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, runner, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_inventory_routes_canonicalization.py:7
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
================================================================= FAILURES ==================================================================
_____________________________________________ test_api_reservation_routes_uses_canonical_audit ______________________________________________

app = <Flask 'app'>

    def test_api_reservation_routes_uses_canonical_audit(app):
        """Test that API reservation routes use canonical audit helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.record_audit_entry') as mock_audit:
    
                # Mock the route function that writes audit entries
                from app.blueprints.api.reservation_routes import _write_unreserved_audit
    
                _write_unreserved_audit(
                    item_id=123,
                    unit="kg",
                    notes="Test unreserve"
                )
    
                # Assert canonical helper was called
>               mock_audit.assert_called_once_with(
                    item_id=123,
                    change_type="unreserved_audit",
                    notes="Unreserved via API: Test unreserve"
                )

tests/test_audit_canonicalization.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='record_audit_entry' id='140184265292368'>, args = ()
kwargs = {'change_type': 'unreserved_audit', 'item_id': 123, 'notes': 'Unreserved via API: Test unreserve'}
msg = "Expected 'record_audit_entry' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_________________________________________________ test_products_routes_uses_canonical_audit _________________________________________________

app = <Flask 'app'>

    def test_products_routes_uses_canonical_audit(app):
        """Test that product creation uses canonical audit helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.record_audit_entry') as mock_audit:
    
                # Mock the route function that writes audit entries
                from app.blueprints.products.products import _write_product_created_audit
    
                mock_variant = MagicMock()
                mock_variant.id = 456
                mock_variant.name = "Test Product"
    
                _write_product_created_audit(mock_variant)
    
                # Assert canonical helper was called
>               mock_audit.assert_called_once_with(
                    item_id=456,
                    change_type="product_created",
                    notes="Product variant created: Test Product"
                )

tests/test_audit_canonicalization.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='record_audit_entry' id='140184262308304'>, args = ()
kwargs = {'change_type': 'product_created', 'item_id': 456, 'notes': 'Product variant created: Test Product'}
msg = "Expected 'record_audit_entry' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
------------------------------------------------------------- Captured log call -------------------------------------------------------------
ERROR    app.services.inventory_adjustment:inventory_adjustment.py:739 Error creating audit entry: Incorrect number of values in identifier to formulate primary key for session.get(); primary key columns are 'inventory_item.id'
_____________________________________________ test_expiration_service_uses_canonical_adjustment _____________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x7f7f3111abd0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f7f31323b50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f7f31127d10>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f7f31127b90>
parameters = [('Test Item', None, 100.0, 'count', 0.0, 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f7f31323b50>
cursor = <sqlite3.Cursor object at 0x7f7f310ee940>
statement = 'INSERT INTO inventory_item (name, category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_...reated_by, created_at, intermediate, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Item', None, 100.0, 'count', 0.0, 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f7f31127d10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: inventory_item.organization_id

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>, db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f7f364b25d0>

    def test_expiration_service_uses_canonical_adjustment(app, db_session):
        """Test that expiration disposal uses the canonical inventory adjustment service"""
    
        # Create test data
        item = InventoryItem(name="Test Item", quantity=100, unit="count")
        db_session.add(item)
>       db_session.commit()

tests/test_expiration_canonicalization.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f7f31323b50>
cursor = <sqlite3.Cursor object at 0x7f7f310ee940>
statement = 'INSERT INTO inventory_item (name, category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_...reated_by, created_at, intermediate, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Item', None, 100.0, 'count', 0.0, 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f7f31127d10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: inventory_item.organization_id
E       [SQL: INSERT INTO inventory_item (name, category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, storage_amount, storage_unit, created_by, created_at, intermediate, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Test Item', None, 100.0, 'count', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, '2025-08-12 03:29:41.480993', 0, None)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_______________________________ TestExpirationCanonicalService.test_mark_fifo_expired_calls_canonical_service _______________________________

self = <tests.test_expiration_canonicalization.TestExpirationCanonicalService object at 0x7f7f346d0710>
mock_user = <AsyncMock name='current_user' id='140184260415952'>, mock_history = <MagicMock name='InventoryHistory' id='140184262080016'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140184262072848'>

    @patch('app.blueprints.expiration.services.process_inventory_adjustment')
    @patch('app.blueprints.expiration.services.InventoryHistory')
    @patch('app.blueprints.expiration.services.current_user')
    def test_mark_fifo_expired_calls_canonical_service(self, mock_user, mock_history, mock_process):
        """Test that marking FIFO entry as expired calls process_inventory_adjustment"""
        from app import create_app
    
        app = create_app({'TESTING': True})
        with app.app_context():
            # Mock the FIFO entry
            mock_fifo_entry = MagicMock()
            mock_fifo_entry.id = 123
            mock_fifo_entry.inventory_item_id = 456
            mock_fifo_entry.remaining_quantity = 10.0
            mock_fifo_entry.unit = 'g'
    
            mock_history.query.get.return_value = mock_fifo_entry
            mock_user.id = 1
            mock_user.is_authenticated = True
            mock_process.return_value = True
    
            # Call the service
            success, message = ExpirationService.mark_as_expired('fifo', 123, quantity=5.0, notes="Test expiration")
    
            # Verify canonical service was called
>           mock_process.assert_called_once_with(
                item_id=456,
                quantity=-5.0,
                change_type="spoil",
                unit='g',
                notes="Expired lot disposal #123: Test expiration",
                created_by=1
            )

tests/test_expiration_canonicalization.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='process_inventory_adjustment' id='140184262072848'>, args = ()
kwargs = {'change_type': 'spoil', 'created_by': 1, 'item_id': 456, 'notes': 'Expired lot disposal #123: Test expiration', ...}
msg = "Expected 'process_inventory_adjustment' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------------------------------------- Captured log call -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
ERROR    app.blueprints.expiration.services:services.py:615 Expiration mark failed: 'NoneType' object has no attribute 'is_authenticated'
_____________________________ TestExpirationCanonicalService.test_mark_product_expired_calls_canonical_service ______________________________

self = <tests.test_expiration_canonicalization.TestExpirationCanonicalService object at 0x7f7f346d0a10>
mock_user = <AsyncMock name='current_user' id='140184271868112'>
mock_sku_history = <MagicMock name='ProductSKUHistory' id='140184265759120'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140184271867088'>

    @patch('app.blueprints.expiration.services.process_inventory_adjustment')
    @patch('app.blueprints.expiration.services.ProductSKUHistory')
    @patch('app.blueprints.expiration.services.current_user')
    def test_mark_product_expired_calls_canonical_service(self, mock_user, mock_sku_history, mock_process):
        """Test that marking product SKU as expired calls process_inventory_adjustment"""
        from app import create_app
    
        app = create_app({'TESTING': True})
        with app.app_context():
            # Mock the product SKU history entry
            mock_sku_entry = MagicMock()
            mock_sku_entry.id = 789
            mock_sku_entry.inventory_item_id = 101
            mock_sku_entry.remaining_quantity = 20.0
            mock_sku_entry.unit = 'ml'
    
            mock_sku_history.query.get.return_value = mock_sku_entry
            mock_user.id = 2
            mock_user.is_authenticated = True
            mock_process.return_value = True
    
            # Call the service
            success, message = ExpirationService.mark_as_expired('product', 789, quantity=15.0, notes="Product expired")
    
            # Verify canonical service was called with product type
>           mock_process.assert_called_once_with(
                item_id=101,
                quantity=-15.0,
                change_type="spoil",
                unit='ml',
                notes="Expired product lot disposal #789: Product expired",
                created_by=2,
                item_type='product'
            )

tests/test_expiration_canonicalization.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='process_inventory_adjustment' id='140184271867088'>, args = ()
kwargs = {'change_type': 'spoil', 'created_by': 2, 'item_id': 101, 'item_type': 'product', ...}
msg = "Expected 'process_inventory_adjustment' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------------------------------------- Captured log call -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
ERROR    app.blueprints.expiration.services:services.py:615 Expiration mark failed: 'NoneType' object has no attribute 'is_authenticated'
______________________ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service ______________________

args = (<tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7f7f340cb110>,)
keywargs = {'app': <Flask 'app'>, 'client': <FlaskClient <Flask 'app'>>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f7f340c9d10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.blueprints.inventory.routes' from '/home/runner/workspace/app/blueprints/inventory/routes.py'> does not have the attribute 'process_inventory_adjustment'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
___________________________________________________ test_pos_sale_uses_canonical_service ____________________________________________________

app = <Flask 'app'>, db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f7f364b25d0>

    def test_pos_sale_uses_canonical_service(app, db_session):
        """Test that POS sales use the canonical inventory adjustment service"""
    
        # Create test data
        item = InventoryItem(name="Test Product", quantity=100, unit="count")
        db_session.add(item)
    
>       sku = ProductSKU(
            name="Test SKU",
            inventory_item_id=item.id,
            quantity=100
        )

tests/test_pos_integration_canonicalization.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'ProductSKU' object has no attribute 'id'") raised in repr()] ProductSKU object at 0x7f7f31246550>
kwargs = {'inventory_item_id': None, 'name': 'Test SKU', 'quantity': 100}, cls_ = <class 'app.models.product.ProductSKU'>, k = 'name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'name' is an invalid keyword argument for ProductSKU

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2175: TypeError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
__________________________________________ test_credit_specific_lot_called_on_reservation_release ___________________________________________

app = <Flask 'app'>

    def test_credit_specific_lot_called_on_reservation_release(app):
        """Test that releasing a reservation calls the canonical credit_specific_lot helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.credit_specific_lot') as mock_credit:
                mock_credit.return_value = True
    
                # Mock reservation object
                mock_reservation = MagicMock()
                mock_reservation.inventory_item_id = 123
                mock_reservation.source_fifo_id = 456
                mock_reservation.quantity = 5.0
    
                # Mock source entry
                mock_source_entry = MagicMock()
                mock_source_entry.unit = "kg"
    
                with patch('app.models.inventory.InventoryHistory.query') as mock_query:
                    mock_query.get.return_value = mock_source_entry
    
                    # This should trigger the credit_specific_lot call
                    ReservationService._release_reservation_inventory(mock_reservation, mock_source_entry)
    
                    # Assert it was called with correct parameters
>                   mock_credit.assert_called_once_with(
                        item_id=123,
                        fifo_entry_id=456,
                        qty=5.0,
                        unit="kg",
                        notes="Released reservation → credit back lot #456"
                    )

tests/test_reservation_canonicalization.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='credit_specific_lot' id='140184259036176'>, args = ()
kwargs = {'fifo_entry_id': 456, 'item_id': 123, 'notes': 'Released reservation → credit back lot #456', 'qty': 5.0, ...}
msg = "Expected 'credit_specific_lot' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'credit_specific_lot' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
____________________________________________ test_record_audit_entry_called_for_unreserved_audit ____________________________________________

app = <Flask 'app'>

    def test_record_audit_entry_called_for_unreserved_audit(app):
        """Test that audit entries use the canonical record_audit_entry helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.record_audit_entry') as mock_audit:
    
                # Mock reservation object
                mock_reservation = MagicMock()
                mock_reservation.inventory_item_id = 123
                mock_reservation.source_fifo_id = 456
                mock_reservation.id = 789
    
                # This should trigger the record_audit_entry call
                ReservationService._write_unreserved_audit_entry(mock_reservation)
    
                # Assert it was called with correct parameters
>               mock_audit.assert_called_once_with(
                    item_id=123,
                    change_type="unreserved_audit",
                    notes="Released reservation (ref lot #456)",
                    fifo_reference_id=456,
                    source="reservation_789"
                )

tests/test_reservation_canonicalization.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='record_audit_entry' id='140184244836880'>, args = ()
kwargs = {'change_type': 'unreserved_audit', 'fifo_reference_id': 456, 'item_id': 123, 'notes': 'Released reservation (ref lot #456)', ...}
msg = "Expected 'record_audit_entry' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------------------------------------ Captured log setup -------------------------------------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
============================================================= warnings summary ==============================================================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit
  /home/runner/workspace/app/services/inventory_adjustment.py:702: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
========================================================== short test summary info ==========================================================
FAILED tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit - AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.
FAILED tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit - AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.
FAILED tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: inventory_item.organization_id
FAILED tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.
FAILED tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - AttributeError: <module 'app.blueprints.inventory.routes' from '/home/runner/workspace/app/blueprints/inventory/routes.py'> does not hav...
FAILED tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service - TypeError: 'name' is an invalid keyword argument for ProductSKU
FAILED tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release - AssertionError: Expected 'credit_specific_lot' to be called once. Called 0 times.
FAILED tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit - AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
ERROR tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
=========================================== 9 failed, 22 passed, 36 warnings, 3 errors in 32.09s ============================================
