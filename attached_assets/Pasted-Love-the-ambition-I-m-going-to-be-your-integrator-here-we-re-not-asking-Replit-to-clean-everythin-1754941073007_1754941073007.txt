Love the ambition. I’m going to be your integrator here: we’re not asking Replit to “clean everything.” We’re commanding it to map → lock → refactor in small, reviewable slices, with tests and CI catching regressions. Below is a repo-specific master prompt you can paste into Replit/Grox. It’s tuned to your actual structure (from the zip you shared).

BatchTrack — Repo-Specific Master Refactor Prompt (Copy/Paste into Replit)
You are the lead engineer refactoring a production Flask app called BatchTrack. It grew linearly and is verbose. Your job: make it tight, lean, consistent — without changing behavior — while preserving Stripe, Google OAuth, Shopify, and FIFO inventory semantics.

Hard rules (do not violate)
No behavior changes. Same routes, templates, JSON contracts, webhooks, DB semantics.

Guardrails first. Lint, format, type-check, tests, CI. If tests are thin, write characterization tests before refactors.

Integrations must keep working:

Stripe API + webhooks (signature verification + idempotency).

Google OAuth (state/nonce, CSRF).

Shopify flows (leave logic intact, only structure).

Data safety. Alembic migrations for any DB change; no silent schema edits; zero data loss.

Multitenancy/permissions. Don’t widen access or relax checks.

Repo facts you must use
Root app: app/ with an app factory in app/__init__.py, blueprints under app/blueprints/*, services under app/services/*, routes under app/routes/*, models under app/models/*, templates under app/templates/*, static assets under app/static/*, and Alembic in migrations/.

Blueprints include: auth/, billing/, batches/, inventory/, recipes/, products/, developer/, fifo/ (with blueprints/fifo/services.py), bulk_stock/, dashboard/, settings/, etc.

Key services present:
app/services/stripe_service.py, billing_service.py, oauth_service.py, inventory_adjustment.py, stock_check.py, product_service.py, unit_conversion.py, signup_service.py, offline_billing_service.py, pos_integration.py, whop_service.py, etc.

Critical files to preserve semantics for:

Stripe: app/blueprints/billing/routes.py + app/services/stripe_service.py

Google OAuth: app/blueprints/auth/routes.py + app/services/oauth_service.py

Inventory/FIFO: app/blueprints/fifo/services.py, app/services/inventory_adjustment.py, app/services/stock_check.py

Product/SKU: app/models/product.py, app/services/product_service.py

Alembic migrations: migrations/versions/*.py

Treat these as the source of truth for current behavior.

Step 0 — Repository Map (stop after this and wait for approval)
Create docs/refactor/00_repo_map.md with:

Tree summary: list of key dirs and largest files by LOC (only under app/, migrations/, app/static/js/, app/templates/).

Critical paths:
(a) Billing/Stripe webhooks and API usage
(b) Auth (Google OAuth)
(c) Inventory/FIFO adjustments and stock checks
(d) Product/Variant/SKU management
(e) Shopify/Whop entry points

Hotspots: long functions, duplicated logic, N+1 queries, global state, missing typing, view functions with business logic, repeated inventory adjustment paths.

Tests status: what exists vs missing; estimate coverage if detectable.

Immediate risk list: webhook idempotency, CSRF, OAuth state/nonce, rate limiting, migration drift.

STOP after writing this file. Show me the repo map before proceeding.

Step 1 — Guardrails & CI (no app logic changes)
Add the following (create/update files exactly as specified):

pyproject.toml

toml
Copy
Edit
[tool.black]
line-length = 100
target-version = ["py311"]

[tool.isort]
profile = "black"
line_length = 100

[tool.ruff]
line-length = 100
target-version = "py311"
select = ["E","F","I","B","UP","SIM","PL","RUF"]
ignore = ["E203","E266","E501"]
exclude = ["migrations"]

[tool.mypy]
python_version = "3.11"
warn_unused_ignores = true
warn_redundant_casts = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
ignore_missing_imports = true
plugins = []

[tool.pytest.ini_options]
addopts = "-q"
testpaths = ["tests"]
.pre-commit-config.yaml

yaml
Copy
Edit
repos:
- repo: https://github.com/psf/black
  rev: 24.4.2
  hooks: [{id: black}]
- repo: https://github.com/astral-sh/ruff-pre-commit
  rev: v0.5.5
  hooks: [{id: ruff}, {id: ruff-format}]
- repo: https://github.com/pre-commit/mirrors-mypy
  rev: v1.10.0
  hooks: [{id: mypy}]
- repo: https://github.com/PyCQA/isort
  rev: 5.13.2
  hooks: [{id: isort}]
- repo: https://github.com/Yelp/detect-secrets
  rev: v1.5.0
  hooks: [{id: detect-secrets}]
Makefile

makefile
Copy
Edit
.PHONY: setup fmt lint type test ci run
setup:
\tpip install -r requirements.txt
\tpre-commit install
fmt:
\tblack app tests && isort app tests && ruff --fix app tests
lint:
\truff app tests
type:
\tmypy app
test:
\tpytest
ci: lint type test
.env.example
Include all required env keys (no secrets): FLASK_ENV=development, SECRET_KEY=changeme, DATABASE_URL=..., STRIPE_SECRET_KEY=, STRIPE_WEBHOOK_SECRET=, GOOGLE_CLIENT_ID=, GOOGLE_CLIENT_SECRET=, SHOPIFY_*, WHOP_*, etc.

.github/workflows/ci.yml

yaml
Copy
Edit
name: CI
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: "3.11" }
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov mypy ruff black isort
      - name: Lint
        run: ruff app tests
      - name: Type-check
        run: mypy app
      - name: Tests
        run: pytest
Output: docs/refactor/01_guardrails.md describing how to run the toolchain locally.
All of Step 1 must pass in CI before you continue.

Step 2 — Characterization tests (lock behavior, no refactors yet)
Create high-leverage smoke tests under tests/ that assert current externally visible behavior:

Stripe webhooks — tests/test_stripe_webhooks.py

Happy path event (e.g., invoice.paid) with signature verification mocked; assert idempotent replay returns 2xx and does not duplicate side effects.

Error path: invalid signature returns 4xx.

Google OAuth — tests/test_google_oauth.py

Mock the OAuth flow: state/nonce set, redirect to Google, callback with code; assert user/session created and CSRF/state validated.

Inventory/FIFO — tests/test_inventory_fifo.py

Through the public path only: call the single inventory adjustment entry point (see Step 3 mandate) and assert FIFO layers consumed as they are today.

Product/SKU — tests/test_product_sku.py

Create product + variants via the existing service/routes; validate current validation rules and DB constraints.

Signup & tier bypass — tests/test_signup_tiers.py

Current behavior for “by-lane” signup (billing bypass flag) remains intact; feature gates reflect tier.

Use fixtures, mock external APIs, freeze time where needed.
Output a short doc docs/refactor/02_characterization.md summarizing coverage and any gaps.

Do not refactor yet. Get these tests green first.

Step 3 — Structural refactor (mechanical, no behavior change)
Do this as small, reviewable PR-sized commits. CI must stay green after each sub-step.

3A. Thin routes; fat services
Inspect each blueprint in app/blueprints/* and move business logic out of route functions into app/services/*.

Route functions should: validate inputs → call service → return response.

Add type hints. No DB session juggling in routes.

3B. Canonical inventory adjustment path
Mandate: all inventory deductions/adjustments must flow through app/services/inventory_adjustment.py (the canonical entry).

Remove or deprecate any duplicate FIFO calls from batches, recipes, or products routes/services.

Ensure app/blueprints/fifo/services.py is only called by the canonical path (not ad-hoc elsewhere).

Add docstring to inventory_adjustment.py: “SINGLE ENTRY POINT for deductions; all callers use this.”

3C. Integration seams
Keep existing services but introduce seams so externals are isolated:

Stripe calls centralized in app/services/stripe_service.py (no direct Stripe SDK calls outside).

OAuth calls centralized in app/services/oauth_service.py.

Any Shopify/Whop logic centralized in their services.

If any route bypasses these, refactor to go through the service.

3D. Config & context
Centralize configuration in app/config.py and pass injected config where needed instead of scattering current_app.config.

Add request-scoped logging context (request_id, org_id, user_id) via a before_request middleware.

3E. Error handling
Add app-wide error handlers for 400/401/403/404/500 that return consistent JSON for API endpoints and render templates for HTML endpoints.

Introduce typed exceptions in services; map them in error handlers.

Document: docs/refactor/03_structure.md with a before/after diagram and list of moved functions.

Step 4 — Tightening pass (still no behavior change)
Dead code: run Vulture; remove dead code/assets behind a refactor: remove dead code commit.

Duplication: DRY common helpers (e.g., SKU utilities, unit conversions).

Typing: add type hints to public service functions; fix mypy noise.

Queries: remove N+1s and add missing indexes with Alembic migrations where justified.

Security:

Stripe webhooks: confirm signature verification + idempotency (persist event IDs).

OAuth: confirm CSRF/state and nonce verification.

CSRF for forms; rate-limit /auth/* and /webhook/* with Flask-Limiter (sane defaults).

Logging: structured logs with request_id/org_id; ensure webhook errors log payload IDs (not secrets).

Document: docs/refactor/04_tightening.md summarizing changes and the risk matrix.

Step 5 — Dev ergonomics
CONTRIBUTING.md with branching rules, local run, tests, release checklist.

docs/adr/ — brief Architecture Decision Records for: single inventory entry point, integration seams, logging strategy, rate limiting.

Acceptance criteria
make ci green; GitHub Actions CI green.

No diffs in externally observable behavior (manual smokes: signup + Google login, Stripe test event + webhook, FIFO adjustment flow, product/SKU create).

Lint/type clean; .env.example present; no secret leakage.

Lines of code reduced only where clarity is equal or better.

House rules while you work
Prefer small, coherent commits; avoid “big bang” file moves.

When ambiguous, choose least risky change and write a characterization test instead of a clever refactor.

Never change DB schema silently; always Alembic, with downgrade notes.

Conventional commits: refactor(module): ..., test: ..., chore(ci): ....

Begin now with Step 0 and output docs/refactor/00_repo_map.md. Stop and await approval.

(Optional) Test skeletons to create verbatim
tests/test_stripe_webhooks.py

python
Copy
Edit
import json
from app import create_app
from flask.testing import FlaskClient

def test_invoice_paid_idempotent(monkeypatch):
    app = create_app()
    client: FlaskClient = app.test_client()

    # monkeypatch stripe.Webhook.construct_event to return a fake event dict
    # first call creates side effects; second call is a replay and should 2xx with no double effects

    # 1st delivery
    resp1 = client.post("/billing/webhook", data=b"...", headers={"Stripe-Signature": "t=...,v1=..."})
    assert 200 <= resp1.status_code < 300

    # 2nd delivery (same payload)
    resp2 = client.post("/billing/webhook", data=b"...", headers={"Stripe-Signature": "t=...,v1=..."})
    assert 200 <= resp2.status_code < 300  # idempotent
tests/test_google_oauth.py

python
Copy
Edit
def test_google_oauth_flow(client):
    # GET /auth/login -> sets state in session, redirects to Google
    r1 = client.get("/auth/login")
    assert r1.status_code in (301,302)
    # Simulate callback with ?code=...&state=...
    r2 = client.get("/auth/callback?code=fake&state=fakestate")
    # Mock token exchange + userinfo; assert session established
    assert r2.status_code in (301,302) or r2.status_code == 200
tests/test_inventory_fifo.py

python
Copy
Edit
def test_fifo_adjustment_through_single_entry(client, db):
    # Arrange stock layers, then call app/services/inventory_adjustment via the public endpoint/service
    # Assert layers consumed in current order and resulting balances match today’s behavior
    ...
Keep these minimal; expand as needed.

Specific refactor mandates for THIS repo
Inventory single entry point: ensure all batch, recipe, product flows call app/services/inventory_adjustment.py and not blueprints/fifo/services.py directly. The FIFO blueprint service stays private behind the canonical service.

Billing & Stripe: keep webhook handling off the request thread if any long work happens; ensure idempotency table/record is used (event IDs). app/blueprints/billing/routes.py must only delegate to app/services/stripe_service.py.

OAuth: centralize all Google calls in app/services/oauth_service.py and verify state/nonce each time; routes delegate only.

Product/SKU: unify validations inside app/services/product_service.py; view functions just orchestrate.

Migrations: add a CI step that fails when there are un-stamped or drifted Alembic heads.

If anything in Step 0 contradicts these assumptions, call it out before Step 1.

Why this won’t brick your app
We lock behavior with characterization tests first, then only do mechanical changes behind green tests and CI.

Risky areas (webhooks, OAuth, FIFO) get explicit tests + idempotency/rate-limit checks.

We avoid schema churn unless clearly needed and safe.

