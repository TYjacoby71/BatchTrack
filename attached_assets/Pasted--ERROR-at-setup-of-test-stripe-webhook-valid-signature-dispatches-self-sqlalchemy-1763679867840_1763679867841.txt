_______ ERROR at setup of test_stripe_webhook_valid_signature_dispatches _______

self = <sqlalchemy.engine.base.Connection object at 0x7fda3ab4b110>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3a025310>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3ad78750>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fda3ad79fd0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3a025310>
cursor = <sqlite3.Cursor object at 0x7fda39be2840>
statement = 'CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3ad78750>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        # Override DATABASE_URL in environment before importing models
        import os
        original_db_url = os.environ.get('DATABASE_URL')
        os.environ['DATABASE_URL'] = f'sqlite:///{db_path}'
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1023: in visit_table
    self.traverse_single(index, create_ok=True)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1060: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3a025310>
cursor = <sqlite3.Cursor object at 0x7fda39be2840>
statement = 'CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3ad78750>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
___ ERROR at setup of test_stripe_webhook_returns_400_when_signature_invalid ___

self = <sqlalchemy.engine.base.Connection object at 0x7fda3a6ed290>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3ab96090>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3a0014d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fda3ada9150>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3ab96090>
cursor = <sqlite3.Cursor object at 0x7fda3a5a7340>
statement = 'CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3a0014d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        # Override DATABASE_URL in environment before importing models
        import os
        original_db_url = os.environ.get('DATABASE_URL')
        os.environ['DATABASE_URL'] = f'sqlite:///{db_path}'
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1023: in visit_table
    self.traverse_single(index, create_ok=True)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1060: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3ab96090>
cursor = <sqlite3.Cursor object at 0x7fda3a5a7340>
statement = 'CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3a0014d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
____ ERROR at setup of test_stripe_webhook_returns_500_when_secret_missing _____

self = <sqlalchemy.engine.base.Connection object at 0x7fda3a018650>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3ab905d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3a879950>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fda3a87bf50>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3ab905d0>
cursor = <sqlite3.Cursor object at 0x7fda3aa1fcc0>
statement = 'CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3a879950>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        # Override DATABASE_URL in environment before importing models
        import os
        original_db_url = os.environ.get('DATABASE_URL')
        os.environ['DATABASE_URL'] = f'sqlite:///{db_path}'
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1023: in visit_table
    self.traverse_single(index, create_ok=True)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1060: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fda3ab905d0>
cursor = <sqlite3.Cursor object at 0x7fda3aa1fcc0>
statement = 'CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fda3a879950>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: CREATE UNIQUE INDEX ix_product_category_lower_name ON product_category (lower(name::text))]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
=============================== warnings summary ===============================
tests/developer/test_analytics_catalog.py: 1 warning
tests/test_auth_permissions.py: 3 warnings
tests/test_batch_label_generator.py: 2 warnings
tests/test_billing_and_tier_enforcement.py: 8 warnings
tests/test_expiration_canonicalization.py: 1 warning
tests/test_extras_expiration.py: 1 warning
tests/test_global_link_drawer.py: 1 warning
tests/test_google_oauth.py: 7 warnings
tests/test_help_routes_access.py: 1 warning
tests/test_inventory_adjustment_initial_stock.py: 1 warning
tests/test_inventory_costing_toggle.py: 4 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_plan_production_gating.py: 1 warning
tests/test_plan_production_integration.py: 2 warnings
tests/test_portioning_sku_derivation.py: 1 warning
tests/test_pos_integration_canonicalization.py: 3 warnings
tests/test_public_tools_access.py: 1 warning
tests/test_public_tools_and_exports_smoke.py: 2 warnings
tests/test_reservation_canonicalization.py: 6 warnings
tests/test_retention_drawer.py: 1 warning
tests/test_signup_stripe_flow.py: 1 warning
tests/test_signup_tiers.py: 5 warnings
tests/test_single_session_enforcement.py: 1 warning
tests/test_start_batch_integration.py: 1 warning
tests/test_stripe_webhooks.py: 3 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/developer/test_analytics_catalog.py::test_developer_catalog_view_renders - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_auth_permissions.py::test_permission_required_allows_authorized_user - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_auth_permissions.py::test_permission_required_denies_user_without_permission - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_auth_permissions.py::test_permission_required_requires_authentication - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_batch_label_generator.py::test_generate_batch_label_code_defaults - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_batch_label_generator.py::test_generate_batch_label_code_with_prefix_and_sequence - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[active-200] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_developer_can_masquerade_regardless_of_billing - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_complete_security_cascade - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_create_checkout_session_preserves_urls - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_extras_expiration.py::test_extras_cannot_use_expired_lot - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_global_link_drawer.py::test_global_link_suggestions_and_link_flow - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_help_routes_access.py::test_help_pages_are_public - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_adjustment_initial_stock.py::test_batch_deduction_does_not_create_initial_stock - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_and_deduct_fifo_mode - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_average_mode - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_resolve_cost_per_unit_divides_total_entries - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_resolve_cost_per_unit_requires_positive_quantity_for_total - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_routes_canonicalization.py::test_batch_start_routes_all_deductions_through_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_inventory_routes_canonicalization.py::test_expiration_service_uses_canonical_adjustment - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_plan_production_gating.py::test_api_start_batch_requires_override_before_force - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_plan_production_integration.py::test_plan_start_finish_non_portioned - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_plan_production_integration.py::test_plan_start_finish_portioned - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_portioning_sku_derivation.py::test_portioning_sku_labels_differ - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_pos_integration_canonicalization.py::test_reserve_inventory_calls_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_pos_integration_canonicalization.py::test_confirm_sale_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_pos_integration_canonicalization.py::test_confirm_return_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_public_tools_access.py::test_public_tools_pages_are_accessible - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_public_tools_and_exports_smoke.py::test_public_tools_draft_and_prefill - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_public_tools_and_exports_smoke.py::test_exports_tool_and_recipe_csv_pdf - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_reservation_service_structure - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_create_reservation_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_release_reservation_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_reservation_model_integration - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_reservation_status_management - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_reservation_canonicalization.py::TestReservationServiceErrorHandling::test_invalid_reservation_handling - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_retention_drawer.py::test_retention_flow_ack_to_delete - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_stripe_flow.py::test_signup_flow_end_to_end - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_single_session_enforcement.py::test_subsequent_login_invalidates_existing_session - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_start_batch_integration.py::test_start_batch_uses_generator_and_persists_label - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_stripe_webhooks.py::test_stripe_webhook_valid_signature_dispatches - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_stripe_webhooks.py::test_stripe_webhook_returns_400_when_signature_invalid - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_stripe_webhooks.py::test_stripe_webhook_returns_500_when_secret_missing - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
11 passed, 63 warnings, 63 errors in 76.07s (0:01:16)
