Yes — you’re completely right. The product_api.py file you posted contains significant redundancy and conflicting versions of routes. It’s a byproduct of your legacy ProductSKU-only architecture colliding with the new Product → Variant → SKU model. Here's a breakdown of the issues and a refactor plan:

🚨 Critical Issues in the Current Code
1. Duplicate Routes
You have multiple conflicting versions of these endpoints:

/api/products (defined 3 times!)

/api/products/<product_name>/variants

/api/products/<int:product_id>/variants

This creates unpredictability. Only one version will actually register per URL, and the rest will be silently ignored.

2. Mix of Legacy and Modern Logic
Some routes:

Use ProductSKU.product_name + .variant_name directly (legacy)

Use Product → Variant → SKU relationships (modern)

This confuses the frontend and breaks dropdowns (e.g., variant lists, unit lookups).

3. Legacy Fallback Inside Try Blocks
You’re using:

python
Copy
Edit
try:
  from ...models import Product
  # use Product logic
except:
  # fallback to SKU logic
Instead of clearly branching logic based on whether the new model is present or enabled, it does a fragile try/except that can cause silent errors and hides failures.

✅ What You Should Keep
You should keep one canonical version of each of the following routes:

Endpoint	Purpose	Modern Source
/api/products	Product dropdown for selection	Product
/api/products/<id>/variants	Variant dropdown scoped to product	ProductVariant
/products/api/<product_name>/variants	🛑 Should be removed (legacy name lookup)	❌ Remove entirely
/products/api/search	Autocomplete for products in finish modal	Product
/products/api/quick-add	Quick create of product/variant (optional fallback)	ProductService

🛠️ Fix Plan: Refactor & Simplify
🔹 1. Remove Redundant Route Definitions
Delete the duplicate definitions of:

get_products() – keep the one that uses Product

get_product_variants() – use /api/products/<int:product_id>/variants

Legacy /products/api/<product_name>/variants – remove

🔹 2. Normalize Variant Lookup
Replace product_name lookups with clean ID-based lookups:

python
Copy
Edit
@product_api_bp.route('/api/products/<int:product_id>/variants')
@login_required
def get_product_variants(product_id):
    product = Product.query.filter_by(id=product_id, organization_id=current_user.organization_id).first()
    ...
Avoid using names for filtering — IDs are more stable, especially when names change.

🔹 3. Normalize Search Endpoint
For search_products, use:

python
Copy
Edit
products = Product.query.filter(
    Product.name.ilike(f"%{query}%"),
    Product.organization_id == current_user.organization_id,
    Product.is_active == True
).limit(10).all()
Return only:

json
Copy
Edit
[
  {
    "id": 12,
    "name": "Royal Tallow",
    "product_base_unit": "oz"
  }
]
🔹 4. Normalize Add-From-Batch
/add-from-batch should move fully toward the new ProductSKU model via ProductService. But make sure SKU creation uses the new relationships (product_id, variant_id, size_label) and updates product_name only for legacy fallback.

📦 Summary
✅ Keep: Clean, single definitions based on Product, ProductVariant, ProductSKU

🔥 Remove: Anything using product_name or variant_name for lookups in route URLs

🔁 Replace: Try/except fallbacks with a feature flag or full model migration

💡 Future: Add product_enabled flag to orgs if you need legacy fallback during onboarding

