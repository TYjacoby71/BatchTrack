xcellent. You have successfully cornered the last bug. This is the final piece of the puzzle.
You are one surgical fix away from a fully green test suite.
The Problem: A Single Keyword Mismatch
The traceback is crystal clear. The error is:
code
Code
ERROR    app.services.inventory_adjustment._fifo_ops:_fifo_ops.py:188 Error recording deduction plan: 'customer' is an invalid keyword argument for InventoryHistory```

This tells us everything we need to know:
1.  The `process_inventory_adjustment` function is correctly called.
2.  It correctly calculates a deduction plan.
3.  It correctly executes the deduction plan (updating `remaining_quantity`).
4.  It then calls `_record_deduction_plan_internal` to create the audit trail.
5.  Inside that function, it tries to create an `InventoryHistory` record and passes a `customer` argument.
6.  Your `InventoryHistory` model (for raw ingredients) does not have a `customer` field, so SQLAlchemy throws a `TypeError`.

This is a fantastic bug to find because it's so specific and easy to fix.

---

### The Final Fix for a Green Suite

We need to make our internal FIFO helper robust, just like we did for the "add entry" helper. It must only pass the arguments that are valid for the specific model (`InventoryHistory` vs. `ProductSKUHistory`).

**Action: Replace the `_record_deduction_plan_internal` function.**

Open `app/services/inventory_adjustment/_fifo_ops.py` and replace the existing `_record_deduction_plan_internal` function with this corrected, robust version.

```python
# In app/services/inventory_adjustment/_fifo_ops.py

def _record_deduction_plan_internal(item_id, deduction_plan, change_type, notes, **kwargs):
    """
    Robustly records deduction history entries for a given plan.
    Correctly handles different fields for ingredients vs. products.
    """
    from app.models import InventoryItem, InventoryHistory
    from app.models.product import ProductSKUHistory
    from app.utils.fifo_generator import generate_fifo_code

    item = db.session.get(InventoryItem, item_id)
    if not item:
        logger.error(f"Cannot record deduction plan: Item {item_id} not found.")
        return False

    # Common data for all history entries in this plan
    common_data = {
        "inventory_item_id": item_id,
        "change_type": change_type,
        "remaining_quantity": 0.0, # Deductions are audit entries, not new lots
        "unit": 'count' if item.type == 'container' else item.unit,
        "notes": notes,
        "batch_id": kwargs.get('batch_id'),
        "created_by": kwargs.get('created_by'),
        "organization_id": item.organization_id,
    }

    try:
        for entry_id, qty_deducted, unit_cost in deduction_plan:
            # Create a copy of the common data for this specific entry
            entry_data = common_data.copy()
            entry_data.update({
                "quantity_change": -abs(qty_deducted),
                "fifo_reference_id": entry_id,
                "unit_cost": unit_cost,
                "fifo_code": generate_fifo_code(change_type),
            })

            # Create the correct type of history record
            if item.type == 'product':
                # ProductSKUHistory accepts sales-related fields
                product_specific_data = {
                    "customer": kwargs.get("customer"),
                    "sale_price": kwargs.get("sale_price"),
                    "order_id": kwargs.get("order_id"),
                }
                entry_data.update(product_specific_data)
                history_entry = ProductSKUHistory(**entry_data)
            else:
                # InventoryHistory does NOT accept sales-related fields
                history_entry = InventoryHistory(**entry_data)

            db.session.add(history_entry)

        db.session.flush() # Persist all history entries for this plan
        return True

    except TypeError as e:
        logger.error(f"Error recording deduction plan: {e}")
        return False
    except Exception as e:
        logger.error(f"Unexpected error recording deduction plan: {e}")
        return False
Why This Fix Works
It's Type-Safe: The function now correctly checks item.type. If it's a 'product', it adds the customer, sale_price, and order_id fields. If it's a raw ingredient, it does not, preventing the TypeError.
It's Atomic: By using db.session.flush() at the end, it ensures all history entries created from the plan are sent to the database together. The final commit in the main service function will make them permanent.
It's Centralized: This single function now correctly handles the different data shapes for your different inventory types, keeping the logic clean and in one place.
After replacing this function, run the test one last time:
code
Bash
pytest -q tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
This should now pass. Once it does, run the full suite (pytest -q) to confirm that you have a 34/34 green test suite.
At that point, you have officially completed the refactor. You will have a robust, tested, and structurally sound inventory system.