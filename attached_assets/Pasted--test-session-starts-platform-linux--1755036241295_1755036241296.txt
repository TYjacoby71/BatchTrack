============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collecting 34 items                                    collected 34 items                                                             

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit PASSED [  2%]
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit PASSED [  5%]
tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment PASSED [  8%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service PASSED [ 11%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service PASSED [ 14%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists PASSED [ 17%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists PASSED [ 20%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists PASSED [ 23%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path PASSED [ 26%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist PASSED [ 29%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status PASSED [ 32%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state PASSED [ 35%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED [ 38%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order FAILED [ 41%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly PASSED [ 44%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service FAILED [ 47%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 50%]
tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service PASSED [ 52%]
tests/test_pos_integration_canonicalization.py::TestPOSIntegrationCanonicalService::test_reserve_inventory_calls_canonical_service PASSED [ 55%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_creation_flow PASSED [ 58%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints PASSED [ 61%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_service_exists PASSED [ 64%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_creation_validation PASSED [ 67%]
tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release PASSED [ 70%]
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit PASSED [ 73%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists PASSED [ 76%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior PASSED [ 79%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment PASSED [ 82%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists PASSED [ 85%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation PASSED [ 88%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_exists PASSED [ 91%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_signature_verification_path_exists PASSED [ 94%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_idempotency_behavior PASSED [ 97%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_methods_exist PASSED [100%]

=================================== FAILURES ===================================
_________ TestInventoryFIFOCharacterization.test_fifo_deduction_order __________

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f64b86e5a90>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f64bac965d0>
test_user = <User test@example.com>, test_org = <Organization 2>

    def test_fifo_deduction_order(self, app, db_session, test_user, test_org):
        """Test FIFO deduction follows first-in-first-out order."""
        with app.test_request_context():
            login_user(test_user)
    
            # Create inventory item
            item = InventoryItem(
                name="Test Ingredient",
                type="ingredient",
                unit="g",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
            db_session.flush()
    
            # Add stock in layers (oldest first)
            assert process_inventory_adjustment(
                item_id=item.id,
                quantity=100.0,
                change_type="restock",
                notes="First batch",
                created_by=test_user.id
            )
    
            assert process_inventory_adjustment(
                item_id=item.id,
                quantity=50.0,
                change_type="restock",
                notes="Second batch",
                created_by=test_user.id
            )
    
            # Verify total
            db_session.refresh(item)
            assert item.quantity == 150.0
    
            # Deduct and verify FIFO order
>           assert process_inventory_adjustment(
                item_id=item.id,
                quantity=-75.0,
                change_type="batch",
                notes="FIFO test deduction",
                created_by=test_user.id
            )

tests/test_inventory_fifo.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/inventory_adjustment.py:459: in process_inventory_adjustment
    raise e
app/services/inventory_adjustment.py:338: in process_inventory_adjustment
    success, deduction_plan, available_qty = FIFOService.calculate_deduction_plan(
app/blueprints/fifo/services.py:42: in calculate_deduction_plan
    return _FIFOService.calculate_deduction_plan(inventory_item_id, quantity, change_type)
app/blueprints/fifo/services.py:289: in calculate_deduction_plan
    fifo_entries = _FIFOService.get_fifo_entries(inventory_item_id)  # Already excludes expired
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

inventory_item_id = 1

    @staticmethod
    def get_fifo_entries(inventory_item_id):
        """Get all FIFO entries for an item with remaining quantity, excluding expired ones"""
        from app.models.product import ProductSKUHistory
    
        today = datetime.now().date()
    
        # Check what type of item this is
        item = InventoryItem.query.get(inventory_item_id)
        if not item:
            return []
    
        if item.type == 'product':
            # For products, ONLY query ProductSKUHistory
            query = ProductSKUHistory.query.filter(
                and_(
                    ProductSKUHistory.inventory_item_id == inventory_item_id,
                    ProductSKUHistory.remaining_quantity > 0,
                    # Skip expired entries - they can only be spoiled/trashed
                    db.or_(
                        ProductSKUHistory.expiration_date.is_(None),  # Non-perishable
                        ProductSKUHistory.expiration_date >= today    # Not expired yet
                    )
                )
            )
    
            # Add organization scoping - always required
            org_id = current_user.organization_id if current_user and current_user.is_authenticated else None
            if org_id:
                query = query.filter(ProductSKUHistory.organization_id == org_id)
    
            return query.order_by(ProductSKUHistory.timestamp.asc()).all()
        else:
            # For ingredients/containers, query InventoryHistory
            query = InventoryHistory.query.filter(
>               and_(
                    InventoryHistory.inventory_item_id == inventory_item_id,
                    InventoryHistory.remaining_quantity > 0,
                    # Skip expired entries - they can only be spoiled/trashed
                    db.or_(
                        InventoryHistory.expiration_date.is_(None),  # Non-perishable
                        InventoryHistory.expiration_date >= today    # Not expired yet
                    )
                )
            )
E           NameError: name 'and_' is not defined

app/blueprints/fifo/services.py:153: NameError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured stdout call -----------------------------
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 0 for item 1
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 1 for item 1
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 1 for item 1
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 1 for item 1
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 2 for item 1
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 2 for item 1
DEBUG Ingredient FIFO validation: item_id=1, org_id=2, current_user_org=2
DEBUG Ingredient FIFO entries found: 2 for item 1
------------------------------ Captured log call -------------------------------
INFO     app.services.inventory_adjustment:inventory_adjustment.py:229 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=100.0, change_type=restock, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_fifo_deduction_order
INFO     app.services.inventory_adjustment:inventory_adjustment.py:229 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=50.0, change_type=restock, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_fifo_deduction_order
INFO     app.services.inventory_adjustment:inventory_adjustment.py:229 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=-75.0, change_type=batch, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_fifo_deduction_order
________________ test_recount_adjustment_uses_canonical_service ________________

client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f64bac965d0>
test_user = <User test@example.com>

    def test_recount_adjustment_uses_canonical_service(client, app, db_session, test_user):
        """Test that inventory recount routes use the canonical adjustment service"""
    
        # Create test inventory item
        item = InventoryItem(
            name="Test Item",
            quantity=100,
            unit="count",
            organization_id=test_user.organization_id
        )
        db_session.add(item)
        db_session.commit()
    
        # Mock the canonical service
        with patch('app.blueprints.inventory.routes.process_inventory_adjustment') as mock_adjustment:
            mock_adjustment.return_value = True
    
            # Login
            client.post('/auth/login', data={'email': test_user.email, 'password': 'password'})
    
            # Make recount request
            response = client.post(f'/inventory/adjust/{item.id}', data={
                'adjustment_type': 'recount',
                'quantity': '80',
                'notes': 'Physical count adjustment'
            })
    
            # Verify canonical service was called
>           mock_adjustment.assert_called_once()

tests/test_inventory_routes_canonicalization.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='process_inventory_adjustment' id='140070517971472'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
------------------------------ Captured log call -------------------------------
INFO     app.utils.unit_utils:unit_utils.py:32 Getting global unit list
WARNING  app.utils.unit_utils:unit_utils.py:70 No units found, creating fallback units
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

self = <tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7f64b86e7350>
mock_user = <AsyncMock name='current_user' id='140070516222544'>
mock_item = <MagicMock name='InventoryItem' id='140070521459088'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140070516255376'>
client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>

    @patch('app.blueprints.inventory.routes.process_inventory_adjustment')
    @patch('app.blueprints.inventory.routes.InventoryItem')
    @patch('app.blueprints.inventory.routes.current_user')
    def test_adjust_inventory_initial_stock_calls_canonical_service(self, mock_user, mock_item, mock_process, client, app):
        """Test that initial stock creation calls process_inventory_adjustment"""
        with app.test_request_context():
            # Mock the inventory item with no history
            mock_inventory_item = MagicMock()
            mock_inventory_item.id = 1
            mock_inventory_item.type = 'ingredient'
            mock_inventory_item.unit = 'g'
            mock_inventory_item.cost_per_unit = 2.5
            mock_inventory_item.is_perishable = False
    
            mock_item.query.get_or_404.return_value = mock_inventory_item
            mock_user.id = 1
            mock_process.return_value = True
    
            # Mock InventoryHistory count to simulate no existing history
            with patch('app.blueprints.inventory.routes.InventoryHistory') as mock_history:
                mock_history.query.filter_by.return_value.count.return_value = 0
    
                # Make POST request to adjust inventory
                response = client.post('/inventory/adjust/1', data={
                    'change_type': 'restock',
                    'quantity': '100.0',
                    'input_unit': 'g',
                    'notes': 'Initial stock',
                    'cost_entry_type': 'per_unit',
                    'cost_per_unit': '3.0'
                })
    
                # Verify canonical service was called
>               mock_process.assert_called_once_with(
                    item_id=1,
                    quantity=100.0,
                    change_type="restock",
                    unit='g',
                    notes='Initial stock',
                    created_by=1,
                    cost_override=3.0
                )

tests/test_inventory_routes_canonicalization.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='process_inventory_adjustment' id='140070516255376'>
args = ()
kwargs = {'change_type': 'restock', 'cost_override': 3.0, 'created_by': 1, 'item_id': 1, ...}
msg = "Expected 'process_inventory_adjustment' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
=============================== warnings summary ===============================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment
  /home/runner/workspace/app/blueprints/expiration/services.py:545: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    entry = InventoryHistory.query.get(entry_id)

tests/test_inventory_fifo.py: 10 warnings
  /home/runner/workspace/app/services/inventory_adjustment.py:101: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment.py:249: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/blueprints/fifo/services.py:93: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(inventory_item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
  /home/runner/workspace/app/blueprints/fifo/services.py:126: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(inventory_item_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order - NameError: name 'and_' is not defined
FAILED tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to have been called...
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to be called once. ...
================== 3 failed, 31 passed, 52 warnings in 31.72s ==================