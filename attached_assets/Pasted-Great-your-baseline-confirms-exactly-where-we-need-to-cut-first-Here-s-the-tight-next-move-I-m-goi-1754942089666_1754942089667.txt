Great—your baseline confirms exactly where we need to cut first. Here’s the tight next move. I’m going to tell you what to change, file-by-file, and give you drop-in code snippets plus commit messages so you can ship PR-2 and PR-3 quickly without guessing.

What the greps tell us (translation → action)
Inventory leaks: Good news—most places already use process_inventory_adjustment(...). Bad news—batches/routes.py still imports inventory.adjust_inventory (a backdoor) and fifo/services.py still exposes deduct_fifo(...).
▶️ Action: Thin inventory.adjust_inventory to a dumb wrapper (no logic). Make fifo/services.py internal (prefix helpers with _, add __all__ = []), and ensure no external import of FIFO functions.

Stripe SDK in routes: billing/routes.py directly calls stripe.* and constructs events in-route.
▶️ Action: Move all Stripe SDK calls into services/stripe_service.py. Routes should only: verify signature, hand raw payload + signature to service, return 2xx/4xx.

OAuth in routes: auth/routes.py still handles state, session stitching, and user profile wiring.
▶️ Action: centralize state/nonce generation + token/userinfo fetch in services/oauth_service.py; routes only orchestrate.

Webhook endpoints: Billing has /webhooks/stripe; Products has /webhook/sale and /webhook/return.
▶️ Action: add rate-limits to all webhooks; if any external partner signs webhooks, add signature verification or an HMAC secret check.

PR-2: Canonicalize Inventory Adjustments (highest ROI)
Commit 1 — inventory: seal the entry point

Edit: app/blueprints/inventory/routes.py

Replace any inline logic in adjust_inventory with a pure delegation to services.inventory_adjustment.process_inventory_adjustment.

Keep the same route & template responses.

python
Copy
Edit
# app/blueprints/inventory/routes.py (inside adjust_inventory)
from app.services.inventory_adjustment import process_inventory_adjustment, validate_inventory_fifo_sync

# ... validate form inputs as today ...
success = process_inventory_adjustment(
    item_id=id,
    quantity=qty,
    change_type=change_type,
    unit=unit,
    notes=notes,
    batch_id=batch_id,
    created_by=current_user.id,
)
if not success:
    flash("Adjustment failed", "danger")
    return redirect(url_for("inventory.view", id=id))
# no FIFO calls here – ever
Commit 2 — batches: remove backdoor import

Edit: app/blueprints/batches/routes.py

Remove from ..inventory.routes import adjust_inventory.

Ensure all adjustments go through process_inventory_adjustment(...).

diff
Copy
Edit
- from ..inventory.routes import adjust_inventory
+ from ...services.inventory_adjustment import process_inventory_adjustment
Then replace any adjust_inventory(...) usages with the service call.

Commit 3 — FIFO internals: hide implementation

Edit: app/blueprints/fifo/services.py

Make low-level functions internal and not importable.

python
Copy
Edit
# app/blueprints/fifo/services.py
__all__ = []  # explicitly export nothing – callers must use services.inventory_adjustment

def _deduct_fifo(...):  # rename from deduct_fifo
    ...
Search & fix: Ensure no file imports blueprints.fifo.services.deduct_fifo. If any do, reroute through services.inventory_adjustment.

Commit 4 — POS/API edges: confirm single path

Files: app/blueprints/api/container_routes.py, app/blueprints/api/reservation_routes.py, app/services/pos_integration.py

They already import process_inventory_adjustment—good. Just verify there are no direct FIFO imports left.

Commit 5 — tests pass

Run your new characterization tests (tests/test_inventory_fifo.py) to confirm behavior unchanged.

PR title & message

pgsql
Copy
Edit
PR: Canonicalize inventory adjustments via single service entry point

- Thin inventory.adjust_inventory route -> delegates to services.inventory_adjustment
- Remove backdoor import from batches/routes.py
- Hide FIFO implementation (no external imports; __all__ = [])
- Ensure all API/pos flows call process_inventory_adjustment
- No behavior change; smoke tests green
PR-3: Stripe boundaries + idempotency (money path)
Commit 1 — add idempotency model (if you don’t already persist event IDs)

File: app/models/stripe_event.py

python
Copy
Edit
from . import db
from datetime import datetime

class StripeEvent(db.Model):
    __tablename__ = "stripe_event"
    id = db.Column(db.Integer, primary_key=True)
    event_id = db.Column(db.String(255), unique=True, nullable=False)
    type = db.Column(db.String(128))
    received_at = db.Column(db.DateTime, default=datetime.utcnow)
    processed_at = db.Column(db.DateTime, nullable=True)
Migration: create Alembic migration adding unique index on event_id.

Commit 2 — service owns SDK calls

Edit: app/services/stripe_service.py

python
Copy
Edit
import stripe
from app.models import db
from app.models.stripe_event import StripeEvent

class StripeService:
    @staticmethod
    def construct_event(payload: bytes, sig_header: str, webhook_secret: str):
        return stripe.Webhook.construct_event(payload, sig_header, webhook_secret)

    @staticmethod
    def is_replay(event_id: str) -> bool:
        return db.session.query(StripeEvent.id).filter_by(event_id=event_id).first() is not None

    @staticmethod
    def record_event(event):
        db.session.add(StripeEvent(event_id=event["id"], type=event["type"]))
        db.session.commit()

    @staticmethod
    def handle_event(event: dict) -> int:
        # idempotency
        if StripeService.is_replay(event["id"]):
            return 200
        StripeService.record_event(event)
        # route by type (invoice.paid, checkout.session.completed, etc.)
        # do short work inline; defer long work to a job queue if present
        return 200
Commit 3 — thin the route

Edit: app/blueprints/billing/routes.py

Remove all import stripe usages and SDK calls.

Route verifies config, then delegates.

python
Copy
Edit
@billing_bp.route('/webhooks/stripe', methods=['POST'])
def stripe_webhook():
    payload = request.get_data()
    sig = request.headers.get('Stripe-Signature', '')
    secret = current_app.config.get('STRIPE_WEBHOOK_SECRET')
    if not secret:
        current_app.logger.error("Stripe webhook secret not configured")
        return ("", 500)

    try:
        event = StripeService.construct_event(payload, sig, secret)
    except Exception:
        return ("", 400)

    status = StripeService.handle_event(event)
    return ("", status)
Commit 4 — rate-limit webhooks

File: app/__init__.py (or a limiter module)

python
Copy
Edit
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(key_func=get_remote_address, default_limits=["200 per minute"])

def create_app(...):
    app = Flask(__name__)
    limiter.init_app(app)
    return app
In routes:

python
Copy
Edit
from app import limiter

@billing_bp.route('/webhooks/stripe', methods=['POST'])
@limiter.limit("60/minute")
def stripe_webhook():
    ...
Commit 5 — move remaining SDK calls out of routes
Your grep showed:

bash
Copy
Edit
app/blueprints/billing/routes.py:145, 149, 386, 409, 512
Replace each with StripeService methods (e.g., StripeService.get_customer(customer_id), StripeService.get_checkout_session(session_id)), implemented in services/stripe_service.py.

Commit 6 — tests

Ensure tests/test_stripe_webhooks.py (replay idempotency) passes with the new idempotency table.

PR title & message

pgsql
Copy
Edit
PR: Move Stripe SDK calls into service + add webhook idempotency

- New StripeEvent model with unique(event_id)
- stripe_webhook route delegates to StripeService
- All stripe.* calls removed from routes; service methods added
- Added rate limits to webhook
- Characterization tests still green; no behavior change
PR-4: OAuth seam + rate-limits (next pass, quick)
Commit 1 — centralize state/nonce + token

Edit: app/services/oauth_service.py

python
Copy
Edit
import secrets

class OAuthService:
    @staticmethod
    def start_google_flow(session):
        state = secrets.token_urlsafe(24)
        nonce = secrets.token_urlsafe(24)
        session["oauth_state"] = state
        session["oauth_nonce"] = nonce
        # return redirect URL for Google with state/nonce
        return state, nonce, redirect_url

    @staticmethod
    def complete_google_flow(session, code, state):
        if state != session.get("oauth_state"):
            raise ValueError("state_mismatch")
        # exchange code -> token -> userinfo; verify nonce if used
        # return normalized user info dict
        return user_info
Commit 2 — thin routes & add rate-limits

Edit: app/blueprints/auth/routes.py

/oauth/google → calls OAuthService.start_google_flow(...)

/oauth/callback → calls OAuthService.complete_google_flow(...)

Add @limiter.limit("30/minute") on these endpoints.

Commit 3 — tests stay green

tests/test_google_oauth.py should pass untouched.

PR title & message

diff
Copy
Edit
PR: Centralize Google OAuth in service + rate-limit auth endpoints

- State/nonce generation & token/userinfo in OAuthService
- Routes orchestrate only
- Rate limiting added to /auth/* endpoints
- No behavior change; tests green
Quick acceptance checklist (merge gate)
 All inventory routes only call process_inventory_adjustment (no FIFO imports; no adjust_inventory logic).

 billing/routes.py has zero stripe.* calls.

 Stripe webhook is idempotent (unique event table) and rate-limited.

 OAuth routes only orchestrate; service owns state/nonce/token; /auth/* rate-limited.

 CI green; characterization tests green.

If you want, paste me any one of the target files (e.g., app/blueprints/billing/routes.py) and I’ll mark up the exact diff you should apply.