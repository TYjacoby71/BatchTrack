============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 34 items                                                           

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit PASSED [  2%]
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit PASSED [  5%]
tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment PASSED [  8%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service PASSED [ 11%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service PASSED [ 14%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists PASSED [ 17%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists PASSED [ 20%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists PASSED [ 23%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path PASSED [ 26%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist PASSED [ 29%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status PASSED [ 32%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state PASSED [ 35%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED [ 38%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order FAILED [ 41%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly FAILED [ 44%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service PASSED [ 47%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 50%]
tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service PASSED [ 52%]
tests/test_pos_integration_canonicalization.py::TestPOSIntegrationCanonicalService::test_reserve_inventory_calls_canonical_service PASSED [ 55%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_creation_flow PASSED [ 58%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints PASSED [ 61%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_service_exists PASSED [ 64%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_creation_validation PASSED [ 67%]
tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release FAILED [ 70%]
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit PASSED [ 73%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists PASSED [ 76%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior PASSED [ 79%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment PASSED [ 82%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists PASSED [ 85%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation PASSED [ 88%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_exists PASSED [ 91%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_signature_verification_path_exists PASSED [ 94%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_idempotency_behavior PASSED [ 97%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_methods_exist PASSED [100%]

================================== FAILURES ==================================
________ TestInventoryFIFOCharacterization.test_fifo_deduction_order _________

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f15ea047950>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ec5e2590>
test_user = <User test@example.com>, test_org = <Organization 2>

    def test_fifo_deduction_order(self, app, db_session, test_user, test_org):
        """Test FIFO deduction follows first-in-first-out order."""
        with app.test_request_context():
            login_user(test_user)
    
            # Create inventory item
            item = InventoryItem(
                name="Test Ingredient",
                type="ingredient",
                unit="g",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
            db_session.flush()
    
            # Add stock in layers (oldest first)
>           assert process_inventory_adjustment(
                item_id=item.id,
                quantity=100.0,
                change_type="restock",
                notes="First batch",
                created_by=test_user.id
            )

tests/test_inventory_fifo.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/inventory_adjustment/_core.py:317: in process_inventory_adjustment
    raise e
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item_id = 1, quantity = 100.0, change_type = 'restock', unit = 'g'
notes = 'First batch', created_by = 2, cost_override = None, item_type = None
custom_shelf_life_days = None, kwargs = {}
InventoryItem = <class 'app.models.inventory.InventoryItem'>, batch_id = None
order_id = None, customer = None, sale_price = None
caller_frame = <frame at 0x7f15e730b4d0, file '/home/runner/workspace/tests/test_inventory_fifo.py', line 33, code test_fifo_deduction_order>
caller_file = '/home/runner/workspace/tests/test_inventory_fifo.py'

    def process_inventory_adjustment(
        item_id: int,
        quantity: float,
        change_type: str,
        unit: str | None = None,
        notes: str | None = None,
        created_by: int | None = None,
        cost_override: float | None = None,
        item_type: str | None = None,
        custom_shelf_life_days: int | None = None,
        **kwargs,
    ) -> bool:
        """
        Process inventory adjustments through a centralized, canonical service.
        """
        from app.models.inventory import InventoryItem
    
        if custom_shelf_life_days is None:
            custom_shelf_life_days = kwargs.get("custom_shelf_life_days")
    
        # Extract optional metadata used downstream
        batch_id = kwargs.get("batch_id")
        order_id = kwargs.get("order_id")
        customer = kwargs.get("customer")
        sale_price = kwargs.get("sale_price")
    
        # Log canonical entry point usage for audit
        caller_frame = inspect.currentframe().f_back
        caller_file = caller_frame.f_code.co_filename
        caller_function = caller_frame.f_code.co_name
    
        logger.info(f"CANONICAL INVENTORY ADJUSTMENT: item_id={item_id}, quantity={quantity}, "
                   f"change_type={change_type}, caller={caller_file}:{caller_function}")
    
        # Validate required parameters
        if not item_id:
            logger.error("CANONICAL ENTRY: item_id is required")
            return False
    
        if quantity == 0:
            logger.warning("CANONICAL ENTRY: zero quantity adjustment requested")
            return True  # No-op but not an error
    
        # Start a transaction with explicit rollback protection
        try:
            # Pre-validate FIFO sync BEFORE starting any inventory changes (skip for recount)
            if change_type != 'recount':
                is_valid, error_msg, inv_qty, fifo_total = validate_inventory_fifo_sync(item_id, item_type)
                if not is_valid:
                    raise ValueError(f"Pre-adjustment validation failed - FIFO sync error: {error_msg}")
    
            # Get the item - treat item_id as inventory_item_id for unified handling
            item = InventoryItem.query.get(item_id)
    
            if not item:
                raise ValueError(f"Inventory item not found for ID: {item_id}")
    
            # Organization scoping check
            if current_user and current_user.is_authenticated and current_user.organization_id:
                if item.organization_id and item.organization_id != current_user.organization_id:
                    raise ValueError("Access denied: Item does not belong to your organization")
    
            # Add unit fallback for when unit is None
            if unit is None:
                unit = getattr(item, "unit", None)
    
            # Convert units if needed
            # only attempt conversion when there's something to convert
            if item_type != "product" and getattr(item, "type", None) != "container" and unit and unit != item.unit:
                conversion = safe_convert(quantity, unit, item.unit, ingredient_id=item.id)
                if not conversion["ok"]:
                    raise ValueError(conversion["error"])
                quantity = conversion["value"]
    
            # Determine quantity change and special handling
            current_quantity = item.quantity
    
            if change_type == 'recount':
                # Recount is special - handle independently from FIFO sync validation
                return handle_recount_adjustment(item_id, quantity, notes, created_by, item_type)
            elif change_type in ['spoil', 'trash', 'sold', 'sale', 'gift', 'sample', 'tester', 'quality_fail', 'damaged', 'expired', 'use', 'batch']:
                qty_change = -abs(quantity)
            elif change_type == 'reserved':
                # Handle reservation creation - deduct from available inventory
                qty_change = -abs(quantity)
            elif change_type == 'unreserved':
                # Unreserved operations should only be handled by ReservationService.release_reservation()
                # This should not be called directly through inventory adjustment
                raise ValueError("Unreserved operations must use ReservationService.release_reservation()")
            elif change_type == 'returned':
                qty_change = quantity
            else:
                qty_change = quantity
    
            # Handle expiration using ExpirationService
            from app.blueprints.expiration.services import ExpirationService
    
            expiration_date = None
            shelf_life_to_use = None
    
            is_perishable_override = expiration_date is not None or custom_shelf_life_days is not None
    
            if is_perishable_override:
                if expiration_date:
                    expiration_date = expiration_date
                elif custom_shelf_life_days:
                    expiration_date = ExpirationService.calculate_expiration_date(datetime.utcnow(), custom_shelf_life_days)
                shelf_life_to_use = custom_shelf_life_days
            elif item.is_perishable and item.shelf_life_days:
                # Use ExpirationService to get proper expiration date considering batch hierarchy
                expiration_date = ExpirationService.get_expiration_date_for_new_entry(item_id, batch_id)
                shelf_life_to_use = item.shelf_life_days
    
            # Handle cost calculations
            if change_type in ['spoil', 'trash']:
                cost_per_unit = None
            elif change_type in ['restock', 'finished_batch'] and qty_change > 0:
                # Calculate weighted average
                current_value = item.quantity * item.cost_per_unit
                new_value = qty_change * (cost_override or item.cost_per_unit)
                total_quantity = item.quantity + qty_change
    
                if total_quantity > 0:
                    weighted_avg_cost = (current_value + new_value) / total_quantity
                    item.cost_per_unit = weighted_avg_cost
                else: # If adding to zero quantity, use the new cost
                    item.cost_per_unit = cost_override or item.cost_per_unit
    
                cost_per_unit = cost_override or item.cost_per_unit
            elif cost_override is not None and change_type == 'cost_override':
                cost_per_unit = cost_override
                item.cost_per_unit = cost_override
            else:
                cost_per_unit = item.cost_per_unit
    
            # Track whether we already applied the quantity mutation inside FIFO helpers
            qty_applied_in_fifo = False
    
            # Handle inventory changes using internal FIFO methods
            if qty_change < 0:
                # Deductions - calculate plan first
                deduction_plan, error_msg = _calculate_deduction_plan_internal(
                    item_id, abs(qty_change), change_type
                )
    
                if not deduction_plan:
                    raise ValueError(error_msg or "Insufficient inventory")
    
                # Handle reservations specially - create reservations FIRST before any FIFO changes
                if change_type == 'reserved':
                    # Only products can be reserved
                    if item.type != 'product':
                        raise ValueError("Only products can be reserved, not raw inventory")
    
                    # Create reservation tracking with FIFO lot details BEFORE executing deductions
                    from app.services.reservation_service import ReservationService
    
                    reservations_created = []
                    try:
                        for fifo_entry_id, qty_deducted, cost_per_unit_from_plan in deduction_plan:
                            reservation, error = ReservationService.create_reservation(
                                inventory_item_id=item_id,
                                quantity=qty_deducted,
                                order_id=order_id,
                                source_fifo_id=fifo_entry_id,
                                unit_cost=cost_per_unit_from_plan,
                                customer=customer,
                                sale_price=sale_price,
                                notes=notes or f"Reserved for order {order_id}"
                            )
                            if error:
                                raise ValueError(f"Failed to create reservation: {error}")
                            reservations_created.append(reservation)
                    except Exception as e:
                        # If reservation creation fails, don't execute FIFO deductions
                        raise ValueError(f"Reservation creation failed, no inventory changes made: {str(e)}")
    
                # Execute the deduction plan ONLY after reservations are created successfully
                success, error_msg = _execute_deduction_plan_internal(deduction_plan, item_id)
                if not success:
                    raise ValueError(error_msg or "Failed to execute deduction plan")
    
                # Record deduction history
                success = _record_deduction_plan_internal(
                    item_id,
                    deduction_plan,
                    change_type,
                    notes,
                    batch_id=batch_id,
                    created_by=created_by,
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id,
                )
                if not success:
                    raise ValueError("Failed to record deduction history")
            elif qty_change > 0:
                # Additions - use internal FIFO methods
                if change_type == 'refunded' and batch_id:
                    # TODO: Handle refund credits - for now use standard addition
                    pass
    
                # Determine the correct unit for the history entry
                history_unit = 'count' if getattr(item, 'type', None) == 'container' else item.unit
    
                # Create unified history record - works for all item types
                # This section was updated to use the UnifiedInventoryHistory model and remove branching logic.
                # Product-specific fields are now handled within this single model.
                history = UnifiedInventoryHistory(
                    inventory_item_id=item.id,
                    change_type=change_type,
                    quantity_change=float(quantity),
                    remaining_quantity=item.quantity, # This should be the quantity BEFORE the change
                    unit=history_unit,
                    unit_cost=cost_per_unit,
                    fifo_code=batch_id, # Assuming batch_id can act as fifo_code for simplicity
                    batch_id=batch_id,
                    notes=notes,
                    created_by=created_by,
                    quantity_used=0, # Not directly applicable for additions in this context
                    is_perishable=item.is_perishable,
                    shelf_life_days=shelf_life_to_use,
                    expiration_date=expiration_date,
                    organization_id=item.organization_id,
                    # Product-specific fields (will be None for ingredients)
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id
                )
                db.session.add(history)
    
                success, error_msg = _internal_add_fifo_entry_enhanced(
                    item_id=item_id,
                    quantity=qty_change,
                    change_type=change_type,
                    unit=history_unit,
                    notes=notes,
                    cost_per_unit=cost_per_unit,
                    expiration_date=expiration_date,
                    shelf_life_days=shelf_life_to_use,
                    batch_id=batch_id,
                    created_by=created_by,
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id,
                    custom_expiration_date=expiration_date,
                    custom_shelf_life_days=shelf_life_to_use
                )
    
                if not success:
                    raise ValueError(error_msg or "Failed to add FIFO entry")
    
                qty_applied_in_fifo = True
    
            # For batch completions, ensure the inventory item inherits perishable settings
            if change_type == 'finished_batch' and batch_id:
                from ..models import Batch
                batch = Batch.query.get(batch_id)
                if batch and batch.is_perishable:
                    # Set perishable data at inventory_item level
                    item.is_perishable = True
                    item.shelf_life_days = batch.shelf_life_days
                    current_app.logger.info(f"Set inventory item {item.name} as perishable with {batch.shelf_life_days} day shelf life from batch {batch_id}")
    
            # Update inventory quantity with rounding only if not applied inside FIFO helper
            if not qty_applied_in_fifo:
                rounded_qty_change = ConversionEngine.round_value(qty_change, 3)
                item.quantity = ConversionEngine.round_value(item.quantity + rounded_qty_change, 3)
    
            db.session.commit()
    
            # Validate inventory/FIFO sync after adjustment
            is_valid, error_msg, inv_qty, fifo_total = validate_inventory_fifo_sync(item_id, item_type)
            if not is_valid:
                # Rollback the transaction
                db.session.rollback()
>               raise ValueError(f"Inventory adjustment failed validation: {error_msg}")
E               ValueError: Inventory adjustment failed validation: FIFO sync error: inventory=100.0, fifo_total=0, diff=100.0

app/services/inventory_adjustment/_core.py:297: ValueError
----------------------------- Captured log setup -----------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured log call ------------------------------
INFO     app.services.inventory_adjustment._core:_core.py:52 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=100.0, change_type=restock, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_fifo_deduction_order
_ TestInventoryFIFOCharacterization.test_inventory_adjustment_delegates_properly _

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f15ea047f50>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ec5e2590>
test_user = <User test@example.com>, test_org = <Organization 2>

    def test_inventory_adjustment_delegates_properly(self, app, db_session, test_user, test_org):
        """Verify inventory adjustment service delegates to proper internal systems."""
        with app.test_request_context():
            login_user(test_user)
    
            item = InventoryItem(
                name="Test Product",
                type="product",
                unit="ml",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
            db_session.flush()
    
            # Test product addition (should use ProductSKUHistory)
>           result = process_inventory_adjustment(
                item_id=item.id,
                quantity=250.0,
                change_type="finished_batch",
                notes="Batch completion",
                created_by=test_user.id
            )

tests/test_inventory_fifo.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/inventory_adjustment/_core.py:317: in process_inventory_adjustment
    raise e
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item_id = 1, quantity = 250.0, change_type = 'finished_batch', unit = 'ml'
notes = 'Batch completion', created_by = 2, cost_override = None
item_type = None, custom_shelf_life_days = None, kwargs = {}
InventoryItem = <class 'app.models.inventory.InventoryItem'>, batch_id = None
order_id = None, customer = None, sale_price = None
caller_frame = <frame at 0x7f15e7b25a80, file '/home/runner/workspace/tests/test_inventory_fifo.py', line 89, code test_inventory_adjustment_delegates_properly>
caller_file = '/home/runner/workspace/tests/test_inventory_fifo.py'

    def process_inventory_adjustment(
        item_id: int,
        quantity: float,
        change_type: str,
        unit: str | None = None,
        notes: str | None = None,
        created_by: int | None = None,
        cost_override: float | None = None,
        item_type: str | None = None,
        custom_shelf_life_days: int | None = None,
        **kwargs,
    ) -> bool:
        """
        Process inventory adjustments through a centralized, canonical service.
        """
        from app.models.inventory import InventoryItem
    
        if custom_shelf_life_days is None:
            custom_shelf_life_days = kwargs.get("custom_shelf_life_days")
    
        # Extract optional metadata used downstream
        batch_id = kwargs.get("batch_id")
        order_id = kwargs.get("order_id")
        customer = kwargs.get("customer")
        sale_price = kwargs.get("sale_price")
    
        # Log canonical entry point usage for audit
        caller_frame = inspect.currentframe().f_back
        caller_file = caller_frame.f_code.co_filename
        caller_function = caller_frame.f_code.co_name
    
        logger.info(f"CANONICAL INVENTORY ADJUSTMENT: item_id={item_id}, quantity={quantity}, "
                   f"change_type={change_type}, caller={caller_file}:{caller_function}")
    
        # Validate required parameters
        if not item_id:
            logger.error("CANONICAL ENTRY: item_id is required")
            return False
    
        if quantity == 0:
            logger.warning("CANONICAL ENTRY: zero quantity adjustment requested")
            return True  # No-op but not an error
    
        # Start a transaction with explicit rollback protection
        try:
            # Pre-validate FIFO sync BEFORE starting any inventory changes (skip for recount)
            if change_type != 'recount':
                is_valid, error_msg, inv_qty, fifo_total = validate_inventory_fifo_sync(item_id, item_type)
                if not is_valid:
                    raise ValueError(f"Pre-adjustment validation failed - FIFO sync error: {error_msg}")
    
            # Get the item - treat item_id as inventory_item_id for unified handling
            item = InventoryItem.query.get(item_id)
    
            if not item:
                raise ValueError(f"Inventory item not found for ID: {item_id}")
    
            # Organization scoping check
            if current_user and current_user.is_authenticated and current_user.organization_id:
                if item.organization_id and item.organization_id != current_user.organization_id:
                    raise ValueError("Access denied: Item does not belong to your organization")
    
            # Add unit fallback for when unit is None
            if unit is None:
                unit = getattr(item, "unit", None)
    
            # Convert units if needed
            # only attempt conversion when there's something to convert
            if item_type != "product" and getattr(item, "type", None) != "container" and unit and unit != item.unit:
                conversion = safe_convert(quantity, unit, item.unit, ingredient_id=item.id)
                if not conversion["ok"]:
                    raise ValueError(conversion["error"])
                quantity = conversion["value"]
    
            # Determine quantity change and special handling
            current_quantity = item.quantity
    
            if change_type == 'recount':
                # Recount is special - handle independently from FIFO sync validation
                return handle_recount_adjustment(item_id, quantity, notes, created_by, item_type)
            elif change_type in ['spoil', 'trash', 'sold', 'sale', 'gift', 'sample', 'tester', 'quality_fail', 'damaged', 'expired', 'use', 'batch']:
                qty_change = -abs(quantity)
            elif change_type == 'reserved':
                # Handle reservation creation - deduct from available inventory
                qty_change = -abs(quantity)
            elif change_type == 'unreserved':
                # Unreserved operations should only be handled by ReservationService.release_reservation()
                # This should not be called directly through inventory adjustment
                raise ValueError("Unreserved operations must use ReservationService.release_reservation()")
            elif change_type == 'returned':
                qty_change = quantity
            else:
                qty_change = quantity
    
            # Handle expiration using ExpirationService
            from app.blueprints.expiration.services import ExpirationService
    
            expiration_date = None
            shelf_life_to_use = None
    
            is_perishable_override = expiration_date is not None or custom_shelf_life_days is not None
    
            if is_perishable_override:
                if expiration_date:
                    expiration_date = expiration_date
                elif custom_shelf_life_days:
                    expiration_date = ExpirationService.calculate_expiration_date(datetime.utcnow(), custom_shelf_life_days)
                shelf_life_to_use = custom_shelf_life_days
            elif item.is_perishable and item.shelf_life_days:
                # Use ExpirationService to get proper expiration date considering batch hierarchy
                expiration_date = ExpirationService.get_expiration_date_for_new_entry(item_id, batch_id)
                shelf_life_to_use = item.shelf_life_days
    
            # Handle cost calculations
            if change_type in ['spoil', 'trash']:
                cost_per_unit = None
            elif change_type in ['restock', 'finished_batch'] and qty_change > 0:
                # Calculate weighted average
                current_value = item.quantity * item.cost_per_unit
                new_value = qty_change * (cost_override or item.cost_per_unit)
                total_quantity = item.quantity + qty_change
    
                if total_quantity > 0:
                    weighted_avg_cost = (current_value + new_value) / total_quantity
                    item.cost_per_unit = weighted_avg_cost
                else: # If adding to zero quantity, use the new cost
                    item.cost_per_unit = cost_override or item.cost_per_unit
    
                cost_per_unit = cost_override or item.cost_per_unit
            elif cost_override is not None and change_type == 'cost_override':
                cost_per_unit = cost_override
                item.cost_per_unit = cost_override
            else:
                cost_per_unit = item.cost_per_unit
    
            # Track whether we already applied the quantity mutation inside FIFO helpers
            qty_applied_in_fifo = False
    
            # Handle inventory changes using internal FIFO methods
            if qty_change < 0:
                # Deductions - calculate plan first
                deduction_plan, error_msg = _calculate_deduction_plan_internal(
                    item_id, abs(qty_change), change_type
                )
    
                if not deduction_plan:
                    raise ValueError(error_msg or "Insufficient inventory")
    
                # Handle reservations specially - create reservations FIRST before any FIFO changes
                if change_type == 'reserved':
                    # Only products can be reserved
                    if item.type != 'product':
                        raise ValueError("Only products can be reserved, not raw inventory")
    
                    # Create reservation tracking with FIFO lot details BEFORE executing deductions
                    from app.services.reservation_service import ReservationService
    
                    reservations_created = []
                    try:
                        for fifo_entry_id, qty_deducted, cost_per_unit_from_plan in deduction_plan:
                            reservation, error = ReservationService.create_reservation(
                                inventory_item_id=item_id,
                                quantity=qty_deducted,
                                order_id=order_id,
                                source_fifo_id=fifo_entry_id,
                                unit_cost=cost_per_unit_from_plan,
                                customer=customer,
                                sale_price=sale_price,
                                notes=notes or f"Reserved for order {order_id}"
                            )
                            if error:
                                raise ValueError(f"Failed to create reservation: {error}")
                            reservations_created.append(reservation)
                    except Exception as e:
                        # If reservation creation fails, don't execute FIFO deductions
                        raise ValueError(f"Reservation creation failed, no inventory changes made: {str(e)}")
    
                # Execute the deduction plan ONLY after reservations are created successfully
                success, error_msg = _execute_deduction_plan_internal(deduction_plan, item_id)
                if not success:
                    raise ValueError(error_msg or "Failed to execute deduction plan")
    
                # Record deduction history
                success = _record_deduction_plan_internal(
                    item_id,
                    deduction_plan,
                    change_type,
                    notes,
                    batch_id=batch_id,
                    created_by=created_by,
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id,
                )
                if not success:
                    raise ValueError("Failed to record deduction history")
            elif qty_change > 0:
                # Additions - use internal FIFO methods
                if change_type == 'refunded' and batch_id:
                    # TODO: Handle refund credits - for now use standard addition
                    pass
    
                # Determine the correct unit for the history entry
                history_unit = 'count' if getattr(item, 'type', None) == 'container' else item.unit
    
                # Create unified history record - works for all item types
                # This section was updated to use the UnifiedInventoryHistory model and remove branching logic.
                # Product-specific fields are now handled within this single model.
                history = UnifiedInventoryHistory(
                    inventory_item_id=item.id,
                    change_type=change_type,
                    quantity_change=float(quantity),
                    remaining_quantity=item.quantity, # This should be the quantity BEFORE the change
                    unit=history_unit,
                    unit_cost=cost_per_unit,
                    fifo_code=batch_id, # Assuming batch_id can act as fifo_code for simplicity
                    batch_id=batch_id,
                    notes=notes,
                    created_by=created_by,
                    quantity_used=0, # Not directly applicable for additions in this context
                    is_perishable=item.is_perishable,
                    shelf_life_days=shelf_life_to_use,
                    expiration_date=expiration_date,
                    organization_id=item.organization_id,
                    # Product-specific fields (will be None for ingredients)
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id
                )
                db.session.add(history)
    
                success, error_msg = _internal_add_fifo_entry_enhanced(
                    item_id=item_id,
                    quantity=qty_change,
                    change_type=change_type,
                    unit=history_unit,
                    notes=notes,
                    cost_per_unit=cost_per_unit,
                    expiration_date=expiration_date,
                    shelf_life_days=shelf_life_to_use,
                    batch_id=batch_id,
                    created_by=created_by,
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id,
                    custom_expiration_date=expiration_date,
                    custom_shelf_life_days=shelf_life_to_use
                )
    
                if not success:
                    raise ValueError(error_msg or "Failed to add FIFO entry")
    
                qty_applied_in_fifo = True
    
            # For batch completions, ensure the inventory item inherits perishable settings
            if change_type == 'finished_batch' and batch_id:
                from ..models import Batch
                batch = Batch.query.get(batch_id)
                if batch and batch.is_perishable:
                    # Set perishable data at inventory_item level
                    item.is_perishable = True
                    item.shelf_life_days = batch.shelf_life_days
                    current_app.logger.info(f"Set inventory item {item.name} as perishable with {batch.shelf_life_days} day shelf life from batch {batch_id}")
    
            # Update inventory quantity with rounding only if not applied inside FIFO helper
            if not qty_applied_in_fifo:
                rounded_qty_change = ConversionEngine.round_value(qty_change, 3)
                item.quantity = ConversionEngine.round_value(item.quantity + rounded_qty_change, 3)
    
            db.session.commit()
    
            # Validate inventory/FIFO sync after adjustment
            is_valid, error_msg, inv_qty, fifo_total = validate_inventory_fifo_sync(item_id, item_type)
            if not is_valid:
                # Rollback the transaction
                db.session.rollback()
>               raise ValueError(f"Inventory adjustment failed validation: {error_msg}")
E               ValueError: Inventory adjustment failed validation: FIFO sync error: inventory=250.0, fifo_total=0, diff=250.0

app/services/inventory_adjustment/_core.py:297: ValueError
----------------------------- Captured log setup -----------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured log call ------------------------------
INFO     app.services.inventory_adjustment._core:_core.py:52 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=250.0, change_type=finished_batch, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_inventory_adjustment_delegates_properly
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

self = <tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7f15ea049f50>
mock_user = <AsyncMock name='current_user' id='139732060229968'>
mock_item = <MagicMock name='InventoryItem' id='139732059030736'>
mock_process = <MagicMock name='process_inventory_adjustment' id='139732047019280'>
client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>

    @patch('app.blueprints.inventory.routes.process_inventory_adjustment')
    @patch('app.blueprints.inventory.routes.InventoryItem')
    @patch('app.blueprints.inventory.routes.current_user')
    def test_adjust_inventory_initial_stock_calls_canonical_service(self, mock_user, mock_item, mock_process, client, app):
        """Test that initial stock creation calls process_inventory_adjustment"""
        with app.test_request_context():
            # Mock the inventory item with no history
            mock_inventory_item = MagicMock()
            mock_inventory_item.id = 1
            mock_inventory_item.type = 'ingredient'
            mock_inventory_item.unit = 'g'
            mock_inventory_item.cost_per_unit = 2.5
            mock_inventory_item.is_perishable = False
            mock_inventory_item.organization_id = 1
    
            mock_item.query.get_or_404.return_value = mock_inventory_item
            mock_user.id = 1
            mock_user.organization_id = 1
            mock_process.return_value = True
    
            # Mock InventoryHistory count to simulate no existing history
>           with patch('app.blueprints.inventory.routes.InventoryHistory') as mock_history:

tests/test_inventory_routes_canonicalization.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15e6905bd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.blueprints.inventory.routes' from '/home/runner/workspace/app/blueprints/inventory/routes.py'> does not have the attribute 'InventoryHistory'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
----------------------------- Captured log setup -----------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
___________ test_credit_specific_lot_called_on_reservation_release ___________

app = <Flask 'app'>

    def test_credit_specific_lot_called_on_reservation_release(app):
        """Test that releasing a reservation calls the canonical credit_specific_lot helper"""
        with app.app_context():
>           with patch('app.services.inventory_adjustment.credit_specific_lot') as mock_credit:

tests/test_reservation_canonicalization.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15e6a57910>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.inventory_adjustment' from '/home/runner/workspace/app/services/inventory_adjustment/__init__.py'> does not have the attribute 'credit_specific_lot'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
----------------------------- Captured log setup -----------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
============================== warnings summary ==============================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment
  /home/runner/workspace/app/blueprints/expiration/services.py:545: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    entry = InventoryHistory.query.get(entry_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment/_validation.py:8: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment/_core.py:73: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/query.py:30: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    rv = self.get(ident)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
========================== short test summary info ===========================
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order - ValueError: Inventory adjustment failed validation: FIFO sync error: inve...
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly - ValueError: Inventory adjustment failed validation: FIFO sync error: inve...
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - AttributeError: <module 'app.blueprints.inventory.routes' from '/home/run...
FAILED tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release - AttributeError: <module 'app.services.inventory_adjustment' from '/home/r...
================= 4 failed, 30 passed, 41 warnings in 36.97s =================
