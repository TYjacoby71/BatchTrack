You’re on the right path. We’re not chasing our tail—we’re finishing Step 1 (guardrails) + Step 2 (characterization tests) so the high-ROI refactors (PR-2 inventory, PR-3 Stripe, PR-4 OAuth) can land safely. The test fixes (app factory accepting a config dict, compat shims, re-exports) aren’t scope creep; they’re the guardrails that keep us from breaking money paths (Stripe) or math (FIFO) when we tighten the code.

Here’s the tight checkpoint to prove we’re still on-track:

✅ Guardrails in place: ruff/black/mypy/pre-commit, CI, rate-limiter wired, Stripe idempotency table created.

✅ Boundaries improved: Stripe SDK calls moved to service (routes now clean), FIFO public entry sealed (moving callers to process_inventory_adjustment).

🔧 Tests wiring: make create_app(config: dict | None) accept overrides; keep import shims (InventoryAdjustmentService, StockCheckService, model re-exports) so tests can lock current behavior.

Quick go/no-go checklist—run these and we proceed to PR-2 immediately:

grep -Rn "import stripe\|stripe\." app/blueprints/billing --include="*.py" || echo OK → OK

grep -Rn "blueprints\.fifo\.services\|deduct_fifo" app --include="*.py" | grep -v __pycache__ || echo OK → OK

rg -n "def create_app\(" app/__init__.py shows def create_app(config: dict | None = None): and sets SQLALCHEMY_DATABASE_URI from DATABASE_URL if provided.

pytest -q → should now collect (even if some tests fail initially). If it still errors on collection, we fix that last wiring, then green-light PR-2.

Once collection works, we move exactly as planned:

PR-2: enforce single inventory entry (finish ripping FIFO imports), tiny commits, tests green.

PR-3: finalize Stripe service (idempotency insert-first + background safety), rate-limit webhooks.

PR-4: centralize OAuth state/nonce + rate-limits.

Bottom line: yes, this is the elite-dev route—map → guard → characterize → refactor—and you’re nearly past the “characterize” gate. Execute the checklist above; if (3) and (4) pass, we flip straight to PR-2.