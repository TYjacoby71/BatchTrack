
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
Excellent. Now that the full test suite is green, we have a stable, verified baseline. This is the perfect time to execute the final, most impactful part of the inventory refactor.
Based on the official roadmap we established, we are now moving into PR3.
PR3 Goal: Merge History Tables & Organize the Service
The goal of this PR is to address the last two major sources of complexity in the inventory system:
Duplicate History Tables: The need for constant if/else logic to handle InventoryHistory vs. ProductSKUHistory is messy and error-prone.
Oversized Service File: The _core.py and _fifo_ops.py files, while logically consolidated, are still too large and could be better organized.
By the end of this PR, your inventory service will not only be structurally sound but also internally clean, simple, and truly "elite level."
Here is the step-by-step plan.
Step 1: Create the Unified History Model
First, we will define our new, single source of truth for all inventory events.
Action:
In your app/models/ directory, create a new file named unified_inventory_history.py.
Paste the following code into this new file. This model includes every field from both old tables, with product-specific fields being nullable.
code
Python
# app/models/unified_inventory_history.py
from . import db
from datetime import datetime

class UnifiedInventoryHistory(db.Model):
    __tablename__ = 'unified_inventory_history'

    id = db.Column(db.Integer, primary_key=True)
    inventory_item_id = db.Column(db.Integer, db.ForeignKey('inventory_item.id'), nullable=False, index=True)
    organization_id = db.Column(db.Integer, db.ForeignKey('organization.id'), nullable=False, index=True)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, nullable=False, index=True)
    change_type = db.Column(db.String(50), nullable=False, index=True)
    quantity_change = db.Column(db.Float, nullable=False)
    unit = db.Column(db.String(50))
    unit_cost = db.Column(db.Float)
    remaining_quantity = db.Column(db.Float, default=0.0)

    # FIFO Tracking
    fifo_reference_id = db.Column(db.Integer, db.ForeignKey('unified_inventory_history.id'), nullable=True)
    fifo_code = db.Column(db.String(64), index=True)

    # Contextual Information
    batch_id = db.Column(db.Integer, db.ForeignKey('batch.id'), nullable=True)
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    notes = db.Column(db.Text) # Using 'notes' to unify 'note' and 'notes'

    # Perishability
    is_perishable = db.Column(db.Boolean, default=False)
    shelf_life_days = db.Column(db.Integer)
    expiration_date = db.Column(db.Date, nullable=True, index=True)

    # --- Product-Specific Fields (Nullable) ---
    customer = db.Column(db.String(255), nullable=True)
    sale_price = db.Column(db.Float, nullable=True)
    order_id = db.Column(db.String(255), nullable=True)

    # Relationships
    inventory_item = db.relationship('InventoryItem')
    batch = db.relationship('Batch')
    creator = db.relationship('User')
    fifo_reference = db.relationship('UnifiedInventoryHistory', remote_side=[id])
Step 2: Create the Database Migration
This is the most critical action. We will create a migration to build the new table, move all the data, and delete the old tables.
Action:
Run the command to create a new migration file:
code
Bash
flask db revision -m "Create unified_inventory_history and merge data"
Open the new file created in migrations/versions/.
Delete everything inside it and replace it with the code below. You will need to find the revision ID of the previous migration and paste it into the down_revision field.
code
Python
"""Create unified_inventory_history and merge data

Revision ID: [Alembic will generate this]
Revises: [Find the last revision ID and paste it here]
Create Date: [Date]

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '[PASTE THE NEW REVISION ID FROM THE FILENAME HERE]'
down_revision = '[PASTE THE PREVIOUS REVISION ID HERE]' # <-- IMPORTANT!
branch_labels = None
depends_on = None

def upgrade():
    # Step 1: Create the new unified table with all columns
    op.create_table('unified_inventory_history',
        sa.Column('id', sa.Integer(), nullable=False),
        # ... (all columns as defined in the model above) ...
        sa.Column('order_id', sa.String(length=255), nullable=True),
        sa.ForeignKeyConstraint(['inventory_item_id'], ['inventory_item.id'], ),
        # ... (all other foreign keys) ...
        sa.PrimaryKeyConstraint('id')
    )
    # Create indexes for performance
    op.create_index(op.f('ix_unified_inventory_history_inventory_item_id'), 'unified_inventory_history', ['inventory_item_id'], unique=False)
    op.create_index(op.f('ix_unified_inventory_history_organization_id'), 'unified_inventory_history', ['organization_id'], unique=False)
    # ... (all other indexes) ...

    # Step 2: Copy data from inventory_history
    op.execute("""
        INSERT INTO unified_inventory_history (
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id,
            created_by, notes, is_perishable, shelf_life_days, expiration_date
        )
        SELECT
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, used_for_batch_id,
            created_by, note, is_perishable, shelf_life_days, expiration_date
        FROM inventory_history;
    """)

    # Step 3: Copy data from product_sku_history
    op.execute("""
        INSERT INTO unified_inventory_history (
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id,
            created_by, notes, is_perishable, shelf_life_days, expiration_date,
            customer, sale_price, order_id
        )
        SELECT
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id,
            created_by, notes, is_perishable, shelf_life_days, expiration_date,
            customer, sale_price, order_id
        FROM product_sku_history;
    """)

    # Step 4: Drop the old tables
    op.drop_table('product_sku_history')
    op.drop_table('inventory_history')

def downgrade():
    # A downgrade path is complex, for now we will just recreate empty old tables
    # ... (code to recreate old tables) ...
    op.drop_table('unified_inventory_history')
Run the migration:
code
Bash
flask db upgrade
Step 3: Refactor the Application Code
Now for the payoff. We will perform a global search-and-replace to simplify the entire inventory service.
Action:
Search: Find every file that imports InventoryHistory or ProductSKUHistory.
Replace:
Change all imports to from app.models.unified_inventory_history import UnifiedInventoryHistory.
Replace all uses of InventoryHistory and ProductSKUHistory with UnifiedInventoryHistory.
In UnifiedInventoryHistory, the note column is now notes. Update any code that accessed history.note to use history.notes.
Simplify (The Big Win):
Go into app/services/inventory_adjustment/_fifo_ops.py and _recount_logic.py.
Find every if item.type == 'product': ... else: ... block that was choosing between the two history models and delete it. You now only need a single, simple code path that queries UnifiedInventoryHistory.
Step 4: Update and Run the Tests
The final step is to ensure our safety net is still working.
Action:
Perform the same search-and-replace in your tests/ directory.
Run the full test suite:
code
Bash
pytest -q
We are aiming for 34/34 passed. After this, PR3 is complete. You will have a single, clean, unified history system, and your codebase will be dramatically simpler and more robust.