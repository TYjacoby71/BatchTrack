
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
You are asking the exact right question. This is a classic and critical strategic decision every developer faces: do you fix a complex feature or do you cut it to meet a deadline?
Given your goal to launch by the end of the month, my strong, unequivocal recommendation is:
Cut Google Auth for V1. Focus exclusively on a simple, secure password-based system.
Here’s the breakdown of why this is the right move and how to execute it cleanly.
The Strategic Rationale: Speed and Stability
The Goal is to Launch: Your primary objective is to get a working, stable product to your target users this month. The current mixed-authentication system is a known source of bugs and complexity—it is your biggest risk.
Eliminate the Biggest Risk: By removing Google OAuth, you instantly delete a huge chunk of complex, error-prone code. You no longer have to worry about OAuth flows, redirect URIs, state tokens, scopes, or external API dependency bugs.
Simplicity is Speed: A standard email/password system is a well-understood problem. The logic is linear and self-contained within your app. It is dramatically faster to build, test, and debug.
Your Users Will Be Fine: You are building a specialized tool for neurodivergent batchmakers. This is a motivated, niche audience. They will not be deterred by a standard login form if the core application solves their problem. The "friction" of a password is far less damaging than the friction of a buggy or unreliable login experience. A smooth, working app is the best onboarding experience you can provide.
Think of it this way: a feature that is 90% done but buggy is a liability. A simpler feature that is 100% done and stable is an asset. Let's build the asset.
The New Action Plan: The "Fastest Path to Launch" Auth
We will replace the "Harden Authentication" task in our roadmap with a much simpler "Implement Password Auth" task.
Revised Phase 3, PR #4: Implement Rock-Solid Password Authentication
Goal: Create a clean, secure, and simple email/password authentication system.
Step 1: Ruthlessly Remove All Old Auth Code
This is the most liberating step. Go through your project and delete:
Any routes related to /auth/google, /auth/callback.
The OAuthService or any related service files.
All Google-specific configurations from your settings (GOOGLE_CLIENT_ID, etc.).
Any "shim" code you wrote to try and bridge the two systems.
Clean out the user model of any fields that were specific to Google OAuth (like google_id, refresh_token, etc.).
Step 2: Modify the User Model
Your User model in app/models/models.py needs one critical field: a place to store the hashed password.
code
Python
# In your User model class

class User(UserMixin, db.Model):
    # ... other fields like id, email, etc.
    password_hash = db.Column(db.String(256), nullable=True) # Nullable for now if you have users without it

    # Add methods to handle password hashing
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
You will need to import generate_password_hash and check_password_hash from werkzeug.security.
Step 3: Build the Core Auth Routes and Service
Create a new, simple auth_service.py and clean routes.py.
app/blueprints/auth/routes.py:
/signup (GET, POST):
GET: Renders the signup form (email, password, confirm_password).
POST: Takes form data, validates it (do passwords match?), checks if the email is already in use, calls auth_service.create_user, logs the new user in, and redirects to the dashboard.
/login (GET, POST):
GET: Renders the login form (email, password).
POST: Takes form data, calls auth_service.authenticate_user, logs the user in if successful, and redirects. If not, it re-renders the form with an error.
/logout:
Calls logout_user() from Flask-Login and redirects to the homepage.
app/services/auth_service.py:
create_user(email, password): Creates a new User object, calls user.set_password(password), and saves it to the database.
authenticate_user(email, password): Finds a user by email. If the user exists and user.check_password(password) is true, it returns the user object. Otherwise, it returns None.
Step 4: Implement a Password Reset Flow (Non-Negotiable)
A password-based system must have a "forgot password" flow. This involves:
A form to enter an email address.
Generating a secure, single-use token with an expiration time (e.g., using itsdangerous library, which comes with Flask).
Sending an email to the user with a link containing the token.
A route that accepts the token, validates it, and allows the user to set a new password.
How This Sets You Up for the Future
By choosing this path, you are not abandoning Google Auth forever. You are deferring it. Once you have launched and have a stable V1, adding Google Auth back as a second login method is straightforward:
You will already have a clean auth_service.py. You can simply add a new function to it like get_or_create_user_from_google(profile_info).
Your User model will be stable. You can add a google_id column in a new migration.
The password_hash can be nullable to accommodate users who sign up with Google and don't have a password.
This revised plan is the most professional and pragmatic path forward. It directly addresses your core problem, de-risks your launch, and provides a stable foundation to build upon later.
Does this revised plan feel like the right direction to get you to launch by the end of the month?