Perfect—here’s the repo-specific Step-0 “repo map” plus a laser-focused hit list of where to operate first. I pulled this from your zip and walked the tree, counted LOC, and looked for duplication and boundary leaks.

I’m going to be blunt (integrator hat on): your biggest risks are (1) fat route files doing business logic, (2) multiple paths for inventory adjustments, (3) webhook/OAuth guardrails not being enforced uniformly, and (4) migrations drift. We’ll fix those first—with tests—before any beautification.

Repo Map (BatchTrack-91)
Key roots

app/__init__.py (580 LOC) — app factory + a lot of wiring.

app/blueprints/* (20 blueprints) — many routes contain business logic.

app/services/* — good start; needs to be the only business-logic layer.

app/models/* — SQLAlchemy models; models.py and product.py are heavy.

migrations/versions/* — 29 migrations; ensure drift checks.

app/templates/* — very large templates (inventory pages esp.).

app/static/js/* — several sizeable JS files, plus per-feature scripts.

Largest Python files (hotspots)

app/blueprints/developer/routes.py — 908 LOC (business logic in routes).

app/management.py — 851 LOC (check for command logic creeping in).

app/blueprints/organization/routes.py — 748 LOC.

app/blueprints/expiration/services.py — 684 LOC (service but very fat).

app/blueprints/inventory/routes.py — 660 LOC (critical).

app/blueprints/billing/routes.py — 617 LOC (Stripe path).

app/blueprints/auth/routes.py — 596 LOC (Google OAuth).

app/blueprints/recipes/routes.py — 559 LOC.

app/blueprints/fifo/services.py — 480 LOC (inventory logic lives here).

app/models/models.py — 449 LOC.

app/models/product.py — 383 LOC.

app/blueprints/batches/finish_batch.py — 401 LOC.

Largest templates (often correlated w/ logic leakage)

app/templates/inventory_list.html — 927 LOC.

app/templates/developer/system_roles.html — 770 LOC.

app/templates/homepage.html — 719 LOC.

app/templates/products/view_product.html — 653 LOC.

app/templates/plan_production.html — 627 LOC.

Several batches/* and products/* in the 400–500 LOC range.

Largest JS

app/static/js/organization/dashboard.js — 564 LOC.

app/static/js/batches/batch_form.js — 258 LOC.

app/static/js/batches/fifo_modal.js — 233 LOC.

Multiple feature scripts 50–170 LOC each.

Services inventory (good anchors)

app/services/inventory_adjustment.py ✅ (canonical entry point target)

app/services/stripe_service.py ✅

app/services/oauth_service.py ✅

app/services/product_service.py, stock_check.py, unit_conversion.py, etc.

Integrations discovered

Stripe referenced across 14 files (routes + services + models). Source of truth should be services/stripe_service.py.

Google OAuth present in auth/routes.py and services/oauth_service.py.

FIFO logic sits in both inventory_adjustment.py and blueprints/fifo/services.py. This is your duplication hazard.

Migrations

29 version files in migrations/versions/. No immediate red flags seen here, but CI must add drift detection and require heads stamped.

Immediate Risk List
Multiple inventory adjustment paths
Evidence: adjust_inventory found in route files (batches/routes.py, inventory/routes.py). Also direct references to fifo/services.py. This must be centralized.

Business logic in routes
billing/routes.py, auth/routes.py, inventory/routes.py, organization/routes.py, developer/routes.py are very fat; they likely perform DB and integration logic inline.

Webhook idempotency/verification
Stripe webhook handling scattered (found “webhook” in 7 files). Confirm signature verification and persisted event ID idempotency in services/stripe_service.py, and ensure routes only delegate.

OAuth state/nonce + CSRF & rate-limits
Make sure auth/routes.py only orchestrates; all Google calls go through services/oauth_service.py. Confirm state, nonce, CSRF on forms, and add rate limits to /auth/* and /webhook/*.

Migration drift
With 29 migrations, you need CI to fail on ungenerated migrations or multiple heads.

Where to Touch First (prioritized, surgical, test-first)
PR-0: Guardrails (no logic changes)
Add/verify: pyproject.toml (black, ruff, isort, mypy, pytest), .pre-commit-config.yaml, .github/workflows/ci.yml, .env.example, Makefile.

This was already specified in the master prompt—apply it verbatim.

PR-1: Characterization tests (lock current behavior)
Create minimal smoke tests that exercise today’s behavior through public endpoints/services:

Stripe Webhook Idempotency

Files touched: tests/test_stripe_webhooks.py

Cover: valid event (mock signature), replay same payload → 2xx without duplicate side effects.

Ensure route under app/blueprints/billing/routes.py delegates to services/stripe_service.py.

Google OAuth Flow

Files: tests/test_google_oauth.py

Cover: /auth/login sets state; /auth/callback with mocked token/userinfo; state/nonce validation.

Inventory/FIFO Single Entry

Files: tests/test_inventory_fifo.py

Arrange layers, call the public, canonical adjustment path, assert current layer consumption order and balances. This locks today’s quirks so refactors can’t change math.

Product/SKU Create

Files: tests/test_product_sku.py

Use the current service/route to create a product + SKU; assert DB constraints that bit you lately (NotNullViolation on product_sku.name etc.).

Signup Tier Bypass

Files: tests/test_signup_tiers.py

Exercise by-lane signup (billing bypass flag) and confirm feature-gate semantics.

These are small tests; the goal is detection, not perfection.

PR-2: Canonicalize Inventory Adjustments (the most important structural change)
Goal: one entry point only → app/services/inventory_adjustment.py.

Refactor work:

In app/blueprints/batches/routes.py and app/blueprints/inventory/routes.py, remove any direct FIFO or adjustment logic and delegate to services/inventory_adjustment.py.

Ensure no caller imports blueprints/fifo/services.py directly. That module becomes an internal helper (or gets moved under services if truly “service” logic).

Add a module docstring at the top of inventory_adjustment.py: “SINGLE ENTRY POINT for all inventory deductions/adjustments. All routes and services must call here.”

Files to edit first:

app/blueprints/batches/routes.py

app/blueprints/inventory/routes.py

app/blueprints/batches/finish_batch.py

app/blueprints/batches/start_batch.py

app/blueprints/products/product_inventory_routes.py

app/blueprints/fifo/services.py (reduce surface; no external imports)

Post-refactor tests: run tests/test_inventory_fifo.py to confirm behavior unchanged.

PR-3: Stripe boundaries & idempotency
Goal: routes orchestrate only; services/stripe_service.py does the work.

Files to edit:

app/blueprints/billing/routes.py — thin to: verify signature → call StripeService.handle_event(payload) → return response. No business logic here.

app/services/stripe_service.py — ensure:

Initialization uses STRIPE_SECRET_KEY.

Signature verification path is respected (route can do this too if you prefer).

Persist event IDs and short-circuit replays.

Long work goes to a background job (if present) or at least guarded by idempotency.

Tests: extend tests/test_stripe_webhooks.py for replay.

PR-4: Google OAuth seam (state/nonce/CSRF, rate limiting)
Files to edit:

app/blueprints/auth/routes.py — remove token calls; delegate to services/oauth_service.py. Verify state & nonce; CSRF on form posts.

app/services/oauth_service.py — own all Google calls; explicit state/nonce generation and verification helpers.

Add rate limits (Flask-Limiter) to /auth/* and /billing/webhook.

Tests: tests/test_google_oauth.py remains green.

PR-5: Thin remaining fat routes (no behavior change)
Do this in small passes; each commit CI-green.

High-value refactors:

app/blueprints/inventory/routes.py (660 LOC) → split into small route handlers delegating to services/* (stock_check.py, inventory_adjustment.py).

app/blueprints/organization/routes.py (748 LOC) → move DB logic to services/statistics_service.py or new organization_service.py.

app/blueprints/developer/routes.py (908 LOC) → carve out permission/tier logic into app/services and keep this panel as a thin admin UI.

For each: create a sibling service if not present, move logic wholesale, wire imports, keep endpoints/JSON contracts the same. Update imports in routes.

PR-6: Migrations drift & safety
Add a CI step to fail when:

Autogenerate produces a diff (i.e., migrations not committed).

Multiple heads exist.

Document make migrate, make upgrade, make downgrade in CONTRIBUTING.md.

Greps / sanity checks for Replit to run (so it proves the cleanup)
Ask Replit to execute these and paste outputs into docs/refactor/00_repo_map.md:

Route bloat check

wc -l app/blueprints/*/*.py | sort -nr | head

Inventory path leaks

rg -n "adjust_inventory\\(|inventory_adjustment|deduct_fifo" app

Stripe SDK calls outside the service

rg -n "import stripe|stripe\\." app | rg -v "services/stripe_service.py"

OAuth calls outside the service

rg -n "oauth|google" app/blueprints | rg -v "services/oauth_service.py"

Webhook handlers

rg -n "webhook" app | sort

The goal: after PR-2..PR-4, those grep results should show no direct FIFO/Stripe/OAuth calls outside services, and only one inventory entry path.

Acceptance Criteria per PR (non-negotiable)
CI green (lint, type, tests).

No behavior changes (manual smokes: signup + Google login, Stripe test event + webhook, plan/start/finish batch, SKU create).

Event idempotency persists for Stripe webhooks.

All inventory adjustments flow through services/inventory_adjustment.py.

Routes thin; services fat—routes validate input, call a service, return a response.

Quick file-by-file “start here” checklist
Inventory (highest ROI)

 app/blueprints/batches/routes.py → delegate to services/inventory_adjustment.py

 app/blueprints/batches/finish_batch.py → same

 app/blueprints/inventory/routes.py → same

 app/blueprints/products/product_inventory_routes.py → same

 app/blueprints/fifo/services.py → internal only; no external imports

Billing / Stripe

 app/blueprints/billing/routes.py → delegate only; verify signature; rate-limit webhook

 app/services/stripe_service.py → idempotency store + background safety

Auth / Google

 app/blueprints/auth/routes.py → delegate only; add rate limit

 app/services/oauth_service.py → own state/nonce/CSRF

Developer / Organization (progressively)

 app/blueprints/developer/routes.py → split into service(s)

 app/blueprints/organization/routes.py → split into organization_service.py or reuse statistics_service.py

If you paste this into Replit and tell it to start with Step 0 → PR-1 tests → PR-2 inventory, you’ll get the safest velocity. Want me to generate the exact commit messages and PR descriptions for the first two PRs so you can copy/paste those too?