.FFFF........EEEFF..F..FF.........                                       [100%]
==================================== ERRORS ====================================
_ ERROR at setup of TestInventoryFIFOCharacterization.test_fifo_deduction_order _

self = <sqlalchemy.engine.base.Connection object at 0x7fd9a0cbcc90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a1091490>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a0cbc1d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7fd9a0cbde90>
parameters = [('test_4a2269', None, None, None, 'test@example.com', None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a1091490>
cursor = <sqlite3.Cursor object at 0x7fd9a1738440>
statement = 'INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organi...t_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('test_4a2269', None, None, None, 'test@example.com', None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a0cbc1d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: user.password_hash

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fd9a683e450>
test_org = <Organization 2>

    @pytest.fixture
    def test_user(db_session, test_org):
        user = User(email="test@example.com", is_active=True, organization_id=test_org.id)
        db_session.add(user)
>       db_session.commit()

tests/conftest.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a1091490>
cursor = <sqlite3.Cursor object at 0x7fd9a1738440>
statement = 'INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organi...t_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('test_4a2269', None, None, None, 'test@example.com', None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a0cbc1d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: user.password_hash
E       [SQL: INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organization_owner, is_active, created_at, last_login, timezone, email_verified, email_verification_token, email_verification_sent_at, oauth_provider, oauth_provider_id, password_reset_token, password_reset_sent_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('test_4a2269', None, None, None, 'test@example.com', None, 2, 'customer', 0, 1, '2025-08-12 16:23:49.455389', None, 'UTC', 0, None, None, None, None, None, None, None, None, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_ ERROR at setup of TestInventoryFIFOCharacterization.test_inventory_adjustment_delegates_properly _

self = <sqlalchemy.engine.base.Connection object at 0x7fd9a0636d10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a169b7d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a0637790>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7fd9a0637d50>
parameters = [('test_aaa95b', None, None, None, 'test@example.com', None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a169b7d0>
cursor = <sqlite3.Cursor object at 0x7fd9a4298840>
statement = 'INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organi...t_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('test_aaa95b', None, None, None, 'test@example.com', None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a0637790>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: user.password_hash

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fd9a683e450>
test_org = <Organization 2>

    @pytest.fixture
    def test_user(db_session, test_org):
        user = User(email="test@example.com", is_active=True, organization_id=test_org.id)
        db_session.add(user)
>       db_session.commit()

tests/conftest.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a169b7d0>
cursor = <sqlite3.Cursor object at 0x7fd9a4298840>
statement = 'INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organi...t_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('test_aaa95b', None, None, None, 'test@example.com', None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a0637790>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: user.password_hash
E       [SQL: INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organization_owner, is_active, created_at, last_login, timezone, email_verified, email_verification_token, email_verification_sent_at, oauth_provider, oauth_provider_id, password_reset_token, password_reset_sent_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('test_aaa95b', None, None, None, 'test@example.com', None, 2, 'customer', 0, 1, '2025-08-12 16:23:51.242720', None, 'UTC', 0, None, None, None, None, None, None, None, None, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_______ ERROR at setup of test_recount_adjustment_uses_canonical_service _______

self = <sqlalchemy.engine.base.Connection object at 0x7fd9a08a1f50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a0cbbc90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a08a3150>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7fd9a08a2f10>
parameters = [('test_8d8343', None, None, None, 'test@example.com', None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a0cbbc90>
cursor = <sqlite3.Cursor object at 0x7fd9a04b97c0>
statement = 'INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organi...t_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('test_8d8343', None, None, None, 'test@example.com', None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a08a3150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: user.password_hash

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fd9a683e450>
test_org = <Organization 2>

    @pytest.fixture
    def test_user(db_session, test_org):
        user = User(email="test@example.com", is_active=True, organization_id=test_org.id)
        db_session.add(user)
>       db_session.commit()

tests/conftest.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a0cbbc90>
cursor = <sqlite3.Cursor object at 0x7fd9a04b97c0>
statement = 'INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organi...t_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('test_8d8343', None, None, None, 'test@example.com', None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a08a3150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: user.password_hash
E       [SQL: INSERT INTO user (username, password_hash, first_name, last_name, email, phone, organization_id, user_type, is_organization_owner, is_active, created_at, last_login, timezone, email_verified, email_verification_token, email_verification_sent_at, oauth_provider, oauth_provider_id, password_reset_token, password_reset_sent_at, deleted_at, deleted_by, is_deleted) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('test_8d8343', None, None, None, 'test@example.com', None, 2, 'customer', 0, 1, '2025-08-12 16:23:52.879650', None, 'UTC', 0, None, None, None, None, None, None, None, None, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
=================================== FAILURES ===================================
__________________ test_products_routes_uses_canonical_audit ___________________

app = <Flask 'app'>

    def test_products_routes_uses_canonical_audit(app):
        """Test that product creation uses canonical audit helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.record_audit_entry') as mock_audit:
    
                # Mock the route function that writes audit entries
                from app.blueprints.products.products import _write_product_created_audit
    
                mock_variant = MagicMock()
                mock_variant.id = 456
                mock_variant.name = "Test Product"
    
                _write_product_created_audit(mock_variant)
    
                # Assert canonical helper was called
>               mock_audit.assert_called_once_with(
                    item_id=456,
                    change_type="product_created",
                    notes="Product variant created: Test Product"
                )

tests/test_audit_canonicalization.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='record_audit_entry' id='140572695798864'>, args = ()
kwargs = {'change_type': 'product_created', 'item_id': 456, 'notes': 'Product variant created: Test Product'}
msg = "Expected 'record_audit_entry' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
------------------------------ Captured log call -------------------------------
ERROR    app.services.inventory_adjustment:inventory_adjustment.py:739 Error creating audit entry: Incorrect number of values in identifier to formulate primary key for session.get(); primary key columns are 'inventory_item.id'
______________ test_expiration_service_uses_canonical_adjustment _______________

self = <sqlalchemy.engine.base.Connection object at 0x7fd9a16aae90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a1624b10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a16b0c50>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7fd9a16b0c90>
parameters = [(1, '2025-08-12 16:23:37.509859', None, None, 'count', 50.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a1624b10>
cursor = <sqlite3.Cursor object at 0x7fd9a16d4ec0>
statement = 'INSERT INTO inventory_history (inventory_item_id, timestamp, change_type, quantity_change, unit, remaining_quantity, ...able, shelf_life_days, expiration_date, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = (1, '2025-08-12 16:23:37.509859', None, None, 'count', 50.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a16b0c50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: inventory_history.change_type

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fd9a683e450>

    def test_expiration_service_uses_canonical_adjustment(app, db_session):
        """Test that expiration disposal uses the canonical inventory adjustment service"""
    
        # Create test data
        item = InventoryItem(name="Test Item", quantity=100, unit="count")
        db_session.add(item)
        db_session.commit()
    
        fifo_entry = InventoryHistory(
            inventory_item_id=item.id,
            remaining_quantity=50,
            unit="count"
        )
        db_session.add(fifo_entry)
>       db_session.commit()

tests/test_expiration_canonicalization.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fd9a1624b10>
cursor = <sqlite3.Cursor object at 0x7fd9a16d4ec0>
statement = 'INSERT INTO inventory_history (inventory_item_id, timestamp, change_type, quantity_change, unit, remaining_quantity, ...able, shelf_life_days, expiration_date, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = (1, '2025-08-12 16:23:37.509859', None, None, 'count', 50.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fd9a16b0c50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: inventory_history.change_type
E       [SQL: INSERT INTO inventory_history (inventory_item_id, timestamp, change_type, quantity_change, unit, remaining_quantity, unit_cost, fifo_reference_id, fifo_code, batch_id, note, created_by, quantity_used, used_for_batch_id, is_perishable, shelf_life_days, expiration_date, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: (1, '2025-08-12 16:23:37.509859', None, None, 'count', 50.0, None, None, None, None, None, None, 0.0, None, 0, None, None, None)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: IntegrityError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_ TestExpirationCanonicalService.test_mark_fifo_expired_calls_canonical_service _

self = <tests.test_expiration_canonicalization.TestExpirationCanonicalService object at 0x7fd9a48837d0>
mock_user = <AsyncMock name='current_user' id='140572696317520'>
mock_history = <MagicMock name='InventoryHistory' id='140572692230480'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140572693604880'>

    @patch('app.blueprints.expiration.services.process_inventory_adjustment')
    @patch('app.blueprints.expiration.services.InventoryHistory')
    @patch('app.blueprints.expiration.services.current_user')
    def test_mark_fifo_expired_calls_canonical_service(self, mock_user, mock_history, mock_process):
        """Test that marking FIFO entry as expired calls process_inventory_adjustment"""
        from app import create_app
    
        app = create_app({'TESTING': True})
        with app.app_context():
            # Mock the FIFO entry
            mock_fifo_entry = MagicMock()
            mock_fifo_entry.id = 123
            mock_fifo_entry.inventory_item_id = 456
            mock_fifo_entry.remaining_quantity = 10.0
            mock_fifo_entry.unit = 'g'
    
            mock_history.query.get.return_value = mock_fifo_entry
            mock_user.id = 1
            mock_user.is_authenticated = True
            mock_process.return_value = True
    
            # Call the service
            success, message = ExpirationService.mark_as_expired('fifo', 123, quantity=5.0, notes="Test expiration")
    
            # Verify canonical service was called
>           mock_process.assert_called_once_with(
                item_id=456,
                quantity=-5.0,
                change_type="spoil",
                unit='g',
                notes="Expired lot disposal #123: Test expiration",
                created_by=1
            )

tests/test_expiration_canonicalization.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='process_inventory_adjustment' id='140572693604880'>
args = ()
kwargs = {'change_type': 'spoil', 'created_by': 1, 'item_id': 456, 'notes': 'Expired lot disposal #123: Test expiration', ...}
msg = "Expected 'process_inventory_adjustment' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------ Captured log call -------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_ TestExpirationCanonicalService.test_mark_product_expired_calls_canonical_service _

self = <tests.test_expiration_canonicalization.TestExpirationCanonicalService object at 0x7fd9a4883e10>
mock_user = <AsyncMock name='current_user' id='140572694751696'>
mock_sku_history = <MagicMock name='ProductSKUHistory' id='140572694508304'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140572681915024'>

    @patch('app.blueprints.expiration.services.process_inventory_adjustment')
    @patch('app.blueprints.expiration.services.ProductSKUHistory')
    @patch('app.blueprints.expiration.services.current_user')
    def test_mark_product_expired_calls_canonical_service(self, mock_user, mock_sku_history, mock_process):
        """Test that marking product SKU as expired calls process_inventory_adjustment"""
        from app import create_app
    
        app = create_app({'TESTING': True})
        with app.app_context():
            # Mock the product SKU history entry
            mock_sku_entry = MagicMock()
            mock_sku_entry.id = 789
            mock_sku_entry.inventory_item_id = 101
            mock_sku_entry.remaining_quantity = 20.0
            mock_sku_entry.unit = 'ml'
    
            mock_sku_history.query.get.return_value = mock_sku_entry
            mock_user.id = 2
            mock_user.is_authenticated = True
            mock_process.return_value = True
    
            # Call the service
            success, message = ExpirationService.mark_as_expired('product', 789, quantity=15.0, notes="Product expired")
    
            # Verify canonical service was called with product type
>           mock_process.assert_called_once_with(
                item_id=101,
                quantity=-15.0,
                change_type="spoil",
                unit='ml',
                notes="Expired product lot disposal #789: Product expired",
                created_by=2,
                item_type='product'
            )

tests/test_expiration_canonicalization.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='process_inventory_adjustment' id='140572681915024'>
args = ()
kwargs = {'change_type': 'spoil', 'created_by': 2, 'item_id': 101, 'item_type': 'product', ...}
msg = "Expected 'process_inventory_adjustment' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------ Captured log call -------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

args = (<tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7fd9a42aa590>,)
keywargs = {'app': <Flask 'app'>, 'client': <FlaskClient <Flask 'app'>>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd9a42a9050>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.blueprints.inventory.routes' from '/home/runner/workspace/app/blueprints/inventory/routes.py'> does not have the attribute 'process_inventory_adjustment'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_____________________ test_pos_sale_uses_canonical_service _____________________

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fd9a683e450>

    def test_pos_sale_uses_canonical_service(app, db_session):
        """Test that POS sales use the canonical inventory adjustment service"""
    
        # Create test data
        item = InventoryItem(name="Test Product", quantity=100, unit="count")
        db_session.add(item)
    
>       sku = ProductSKU(
            name="Test SKU",
            inventory_item_id=item.id,
            quantity=100
        )

tests/test_pos_integration_canonicalization.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'ProductSKU' object has no attribute 'sku_code'") raised in repr()] ProductSKU object at 0x7fd9a0f0aa50>
kwargs = {'inventory_item_id': None, 'name': 'Test SKU', 'quantity': 100}
cls_ = <class 'app.models.product.ProductSKU'>, k = 'quantity'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'quantity' of 'ProductSKU' object has no setter

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2178: AttributeError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
________ TestProductSKUCharacterization.test_sku_generation_constraints ________

self = <tests.test_product_sku.TestProductSKUCharacterization object at 0x7fd9a42cca10>
app = <Flask 'app'>

    def test_sku_generation_constraints(self, app):
        """Test current SKU generation and constraints."""
        with app.app_context():
            # This test characterizes the NotNullViolation issue mentioned
            # in the engineer's assessment
    
            # Verify Product model exists and has expected fields
            product = Product()
            assert hasattr(product, 'name')
            assert hasattr(product, 'organization_id')
    
            # Verify ProductSKU model exists and has expected fields
            sku = ProductSKU()
>           assert hasattr(sku, 'sku_code')  # ProductSKU uses sku_code, not name
E           assert False
E            +  where False = hasattr(<[AttributeError("'ProductSKU' object has no attribute 'sku_code'") raised in repr()] ProductSKU object at 0x7fd9a02926d0>, 'sku_code')

tests/test_product_sku.py:35: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
____________ test_credit_specific_lot_called_on_reservation_release ____________

app = <Flask 'app'>

    def test_credit_specific_lot_called_on_reservation_release(app):
        """Test that releasing a reservation calls the canonical credit_specific_lot helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.credit_specific_lot') as mock_credit:
                mock_credit.return_value = True
    
                # Mock reservation object
                mock_reservation = MagicMock()
                mock_reservation.inventory_item_id = 123
                mock_reservation.source_fifo_id = 456
                mock_reservation.quantity = 5.0
    
                # Mock source entry
                mock_source_entry = MagicMock()
                mock_source_entry.unit = "kg"
    
                with patch('app.models.inventory.InventoryHistory.query') as mock_query:
                    mock_query.get.return_value = mock_source_entry
    
                    # This should trigger the credit_specific_lot call
                    ReservationService._release_reservation_inventory(mock_reservation, mock_source_entry)
    
                    # Assert it was called with correct parameters
>                   mock_credit.assert_called_once_with(
                        item_id=123,
                        fifo_entry_id=456,
                        qty=5.0,
                        unit="kg",
                        notes="Released reservation → credit back lot #456"
                    )

tests/test_reservation_canonicalization.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='credit_specific_lot' id='140572693353104'>, args = ()
kwargs = {'fifo_entry_id': 456, 'item_id': 123, 'notes': 'Released reservation → credit back lot #456', 'qty': 5.0, ...}
msg = "Expected 'credit_specific_lot' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'credit_specific_lot' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
_____________ test_record_audit_entry_called_for_unreserved_audit ______________

app = <Flask 'app'>

    def test_record_audit_entry_called_for_unreserved_audit(app):
        """Test that audit entries use the canonical record_audit_entry helper"""
        with app.app_context():
            with patch('app.services.inventory_adjustment.record_audit_entry') as mock_audit:
    
                # Mock reservation object
                mock_reservation = MagicMock()
                mock_reservation.inventory_item_id = 123
                mock_reservation.source_fifo_id = 456
                mock_reservation.id = 789
    
                # This should trigger the record_audit_entry call
                ReservationService._write_unreserved_audit_entry(mock_reservation)
    
                # Assert it was called with correct parameters
>               mock_audit.assert_called_once_with(
                    item_id=123,
                    change_type="unreserved_audit",
                    notes="Released reservation (ref lot #456)",
                    fifo_reference_id=456,
                    source="reservation_789"
                )

tests/test_reservation_canonicalization.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='record_audit_entry' id='140572700496528'>, args = ()
kwargs = {'change_type': 'unreserved_audit', 'fifo_reference_id': 456, 'item_id': 123, 'notes': 'Released reservation (ref lot #456)', ...}
msg = "Expected 'record_audit_entry' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'record_audit_entry' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app:unit_utils.py:20 BatchTrack startup
------------------------------ Captured log call -------------------------------
ERROR    app.services.reservation_service:reservation_service.py:45 Failed to write unreserved audit entry: record_audit_entry() missing 1 required positional argument: 'quantity'
=============================== warnings summary ===============================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit
  /home/runner/workspace/app/services/inventory_adjustment.py:702: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service
  /home/runner/workspace/app/blueprints/expiration/services.py:568: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    fifo_entry = InventoryHistory.query.get(entry_id)

tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service
  /home/runner/workspace/app/blueprints/expiration/services.py:585: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    sku_entry = ProductSKUHistory.query.get(entry_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit - AssertionError: Expected 'record_audit_entry' to be called once. Called 0 t...
FAILED tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint...
FAILED tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to be called once. ...
FAILED tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to be called once. ...
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - AttributeError: <module 'app.blueprints.inventory.routes' from '/home/runne...
FAILED tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service - AttributeError: property 'quantity' of 'ProductSKU' object has no setter
FAILED tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints - assert False
FAILED tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release - AssertionError: Expected 'credit_specific_lot' to be called once. Called 0 ...
FAILED tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit - AssertionError: Expected 'record_audit_entry' to be called once. Called 0 t...
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint...
ERROR tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint...
ERROR tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint...
9 failed, 22 passed, 36 warnings, 3 errors in 39.77s
