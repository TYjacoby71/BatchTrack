Got it. I parsed the auto-migrate output you pasted (the last one) and turned it into:

a clear list of what the autogenerator says is different (i.e., what it would change), and

a step-by-step instruction plan you can hand to your Replit/Cursor agent to push those fixes back into your ≤5 base migrations so future flask db migrate runs are clean (no drift).

1) What this auto-migration would change (from the log you pasted)
Global warnings

Topo sort cycle: batch ↔ product_sku have mutually dependent FKs. Alembic can’t topologically order them.
→ You must split FK creation into a later migration (tables first, then FKs).

Computed defaults warnings on many batch.* and recipe.* columns (e.g., vessel_fill_pct, soap_superfat, etc.).
→ DB-level computed defaults can’t be autocompared; keep them out of the base, or implement via DB triggers (PG-only) or app-level calculations.

Nullability & defaults (missing NOT NULL or defaults)

inventory_item.is_active → detected NULL (should probably be nullable=False, default false)

inventory_item.is_archived → detected NULL

role.is_active → detected NULL

user.is_active → detected NULL

NOT NULL that the models require

reservation.product_item_id → detected NOT NULL (DB currently allows NULL)

Type/length diffs

reservation.customer → VARCHAR(255) → String(128)

reservation.source_fifo_id → VARCHAR(128) → Integer

reservation.source → VARCHAR(128) → String(64)

(Everything else in this particular paste is sequences info and the repeated computed default warnings.)

Bottom line from this run: your base migrations aren’t enforcing some NOT NULL / defaults your models want, and a few types/lengths don’t match your models.

2) Instruction set for your Replit/Cursor agent (push fixes back into the ≤5 base migrations)

The goal: after you adjust the base chain, running flask db migrate should produce no changes.

A. Fix the cycle (batch ↔ product_sku)

In 0001_base_schema.py (or your first one), create both tables without the circular FKs (product_sku.product_id? batch.sku_id? whatever forms the loop).

In 0002_constraints_indexes_fks.py, add those FKs with op.create_foreign_key(...) once both tables exist.

Confirm down_revision ordering supports this (0002 depends on 0001).

B. Booleans and defaults (cross-DB safe)

For each of these in the base table creation (ideally 0001):

inventory_item.is_active

inventory_item.is_archived

role.is_active

user.is_active

Change column definitions to:

sa.Column("is_active", sa.Boolean(), nullable=False, server_default=sa.false())
# …and where archived exists:
sa.Column("is_archived", sa.Boolean(), nullable=False, server_default=sa.false())


Notes

Use server_default=sa.false() / sa.true() (not 0/1) so Postgres doesn’t error.

If your seed/backfill requires temporary NULLs, then:

In 0001: create as nullable=True with a server_default that matches app logic.

In 0005_cleanup_guardrails.py:

backfill NULLs (UPDATE … SET is_active=false WHERE is_active IS NULL)

alter_column(..., nullable=False)

retain server_default=sa.false().

On SQLite use batch_alter_table.

C. Reservation column corrections

From the diff:

reservation.product_item_id must be NOT NULL.

In 0001: define nullable=False (if there’s seeding that needs NULLs, see the backfill pattern in B).

reservation.customer: String(128)

In 0001: sa.Column("customer", sa.String(128), …)

reservation.source_fifo_id: Integer

In 0001: sa.Column("source_fifo_id", sa.Integer(), …)

reservation.source: String(64)

In 0001: sa.Column("source", sa.String(64), …)

If these were previously created differently in 0001, edit 0001 rather than leaving a later “fixup” migration. The idea is that base migrations reflect the current model contract.

D. Computed defaults (batch., recipe.)

Alembic warns because it can’t diff computed/default expressions. Choose one approach and make it consistent in the base:

Preferred (portable): Remove DB-level computed defaults from the base migrations. Compute in the app/model layer or on save (e.g., @validates, service layer).

If you need DB-side logic (PG only): Move to 0003_postgres_specific.py as PG triggers/functions (guarded by dialect), and no-op on SQLite. Don’t expect autogenerate to compare them cleanly.

Either way, make sure your models and base migrations don’t disagree (or you’ll keep seeing “cannot be modified” warnings).

E. FK placement & idempotency

All non-cyclic FKs can live in 0002_constraints_indexes_fks.py.

Ensure you don’t recreate indexes/uniques already defined in 0001. Keep 0002 for items that must come after tables exist (particularly cross-table constraints).

F. General patterns the agent should follow

Booleans

sa.Column("flag", sa.Boolean(), nullable=False, server_default=sa.false())


Backfill (if needed, in cleanup migration)

# Postgres direct
op.execute(sa.text('UPDATE "table" SET flag = false WHERE flag IS NULL'))
op.alter_column("table","flag", server_default=sa.false(), existing_type=sa.Boolean(), nullable=False)

# SQLite batch mode if altering:
with op.batch_alter_table("table") as b:
    # no backfill here; run the UPDATE via op.execute before batch
    b.alter_column("flag", nullable=False)


Lengths / types

Fix the first migration that introduced the column (0001). Don’t leave a later corrective migration unless there’s a dependency reason.

Indexes/uniques

If your models declare unique=True or explicit Index, either:

let SQLAlchemy emit them in 0001 (table create), or

add them explicitly in 0002 with op.create_index / op.create_unique_constraint.

Don’t duplicate (Alembic will whine).

Cycles

Split FKs across 0002; never try to create a circular FK in 0001.

Postgres-only goodies

Keep uuid-ossp, citext, triggers in 0003_postgres_specific.py guarded by:

bind = op.get_bind()
if bind.dialect.name == "postgresql":
    op.execute('CREATE EXTENSION IF NOT EXISTS "citext";')

3) Concrete to-do list for the agent

Open models for inventory_item, role, user, reservation, batch, recipe, product_sku. Confirm expected:

boolean defaults / NOT NULL

types/lengths for reservation.customer, source_fifo_id, source

whether product_item_id is nullable=False

Edit 0001_base_schema.py so table creation matches the models:

Booleans: nullable=False, server_default=sa.false() for the four columns listed.

Reservation: adjust those three types/lengths + NOT NULL as above.

Remove circular FKs from table definitions (batch ↔ product_sku).

Edit/confirm 0002_constraints_indexes_fks.py:

Add the circular FKs here with op.create_foreign_key(...).

Add any indices/uniques you purposely defer to after table creation.

Ensure no duplicates of what 0001 already creates.

Decide on computed defaults strategy:

If app-level: remove any DB computed defaults from 0001. Make sure models don’t declare server-side defaults Alembic can’t diff.

If DB-level (PG only): implement triggers in 0003_postgres_specific.py (guarded by dialect). No-op for SQLite.

If any seed/backfill is required (e.g., moving from nullable→NOT NULL):

In 0004_seed_presets.py (guarded by SEED_PRESETS=1) handle seed rows.

In 0005_cleanup_guardrails.py do backfills + alter_column(..., nullable=False) using batch on SQLite, direct on PG.

Run drift check locally:

export DATABASE_URL="sqlite:///test_ci.db"
flask db upgrade
flask db migrate -m "ci_check" --rev-id ci_test >/dev/null 2>&1 || true
# Expect: no file created


Repeat drift check on PG (staging DB) after nuking schema:

psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -c \
  'DROP SCHEMA public CASCADE; CREATE SCHEMA public; GRANT ALL ON SCHEMA public TO public;'
flask db upgrade
flask db migrate -m "ci_check" --rev-id ci_test >/dev/null 2>&1 || true
# Expect: no file created

4) Why the auto-migration “found” these

Your base chain currently doesn’t fully match your SQLAlchemy models (nullability/defaults/types).

Autogenerate compares metadata (models) vs live DB. Any mismatch shows up like the ones above.

Fixing the base to reflect today’s models (and pushing circular FKs to 0002) will make your chain clean. After that, new changes go in new migrations—your base five stay frozen.