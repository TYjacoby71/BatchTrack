Yep—this is the same pattern as the tier issues: the tests seed data with legacy fields the current models don’t have. Now it’s User(is_verified=True, ...), and SQLAlchemy blows up because is_verified isn’t a mapped attribute on User.

Fastest unblock (and still aligned with the roadmap) is a compat shim on User:

Option A (simplest): add a real column
In app/models/models.py (where User lives):

python
Copy
Edit
# imports at top
from sqlalchemy import Boolean, Column
# ...

class User(db.Model):
    __tablename__ = 'users'
    # ... existing fields ...
    is_verified = db.Column(db.Boolean, nullable=False, default=False)  # ← compat shim
That immediately lets the fixture do:

python
Copy
Edit
user = User(email="...", password_hash="...", organization_id=1, is_verified=True)
No other code changes required. Tests move on.

Option B (no schema change): map to your existing “verified” concept
If you already track verification via something like email_verified_at:

python
Copy
Edit
from datetime import datetime
from sqlalchemy.ext.hybrid import hybrid_property

class User(db.Model):
    # existing columns...
    email_verified_at = db.Column(db.DateTime, nullable=True)

    @hybrid_property
    def is_verified(self):
        return self.email_verified_at is not None

    @is_verified.setter
    def is_verified(self, value: bool):
        self.email_verified_at = datetime.utcnow() if value else None
This also satisfies the test (constructor can set is_verified=True because it’s a mapped attribute), and it keeps your canonical design (verified-when timestamp) without a new column.

Why this is ok
This is just back-compat so the characterization tests can seed users quickly.

We’re not changing business logic; we’re exposing a field name the tests expect.

Matches the approach we used for SubscriptionTier shims.

Next step
Make one of the changes above, then run:

css
Copy
Edit
pytest -q
You should advance past the User constructor error and hit the next real assertion. If anything else pops (e.g., another legacy kwarg), we’ll add a tiny alias or property the same way and keep moving forward.