# Step 3: Flask Route - /api/available-containers/<recipe_id>
from flask import Blueprint, jsonify, request
from models import Recipe, InventoryItem, Container
from services.unit_conversion import convert_units  # assumes a shared conversion function

api = Blueprint('api', __name__)

@api.route('/api/available-containers/<int:recipe_id>')
def available_containers(recipe_id):
    try:
        scale = float(request.args.get('scale', 1.0))
        recipe = Recipe.query.get(recipe_id)
        if not recipe:
            return jsonify({"error": "Recipe not found"}), 404

        # Projected yield from recipe
        required_volume = recipe.predicted_yield * scale
        required_unit = recipe.predicted_yield_unit

        # Fetch containers in stock with unit conversion
        in_stock = []
        for item in InventoryItem.query.filter_by(type='container').all():
            container = Container.query.get(item.container_id)
            if not container or item.quantity <= 0:
                continue

            converted_capacity = convert_units(container.storage_amount, container.storage_unit, required_unit)
            if converted_capacity is None:
                continue

            in_stock.append({
                "id": container.id,
                "name": container.name,
                "storage_amount": converted_capacity,
                "storage_unit": required_unit,
                "stock_qty": item.quantity
            })

        # Sort largest to smallest
        sorted_containers = sorted(in_stock, key=lambda c: c['storage_amount'], reverse=True)

        # Greedy fill logic
        plan = []
        remaining = required_volume

        for c in sorted_containers:
            per_unit = c['storage_amount']
            max_needed = int(remaining // per_unit)
            if max_needed <= 0:
                continue
            use_qty = min(max_needed, c['stock_qty'])
            if use_qty > 0:
                plan.append({
                    "id": c['id'],
                    "name": c['name'],
                    "capacity": per_unit,
                    "unit": required_unit,
                    "quantity": use_qty
                })
                remaining -= use_qty * per_unit

        return jsonify({
            "available": sorted_containers,
            "plan": plan
        })
    
    except Exception as e:
        return jsonify({"error": str(e)}), 500
