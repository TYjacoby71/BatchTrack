Your ExpirationService is impressively thorough, but it is definitely inflated in some areas and mildly redundant in others. Below is a breakdown of where you’ve nailed it, where it can be slimmed down, and where logic overlaps unnecessarily.

✅ What’s Good / Industry-Norm
Centralized Service Class – ✅ standard pattern, especially for expiration-specific logic.

Separation of Responsibilities – Expiration logic (calculations, summaries, and marking expired items) is correctly not mixed into your FIFO service directly.

Explicit Batch vs FIFO Handling – Good for future Shopify-like systems where product-level expiration differs from raw ingredients.

Weighted Average Freshness – Unique, advanced calculation — keep this.

⚠ Redundant or Inflated Parts
1. Repeated Query Patterns
You have nearly identical queries for:

get_expired_inventory_items()

get_expiring_soon_items()

get_inventory_item_expiration_status()

get_product_expiration_status() (stubbed)

✅ They all:

Query FIFO entries

Join InventoryItem (with organization scoping)

Join Product SKU + History

Check remaining_quantity > 0 & expiration_date filters.

❌ Issue: You're duplicating the query logic 3+ times.

✅ Fix: Create a single private helper:

python
Copy
Edit
@staticmethod
def _query_expiration_items(expired=False, days_ahead: int = None):
    now = TimezoneUtils.now_naive()
    future_date = now + timedelta(days=days_ahead) if days_ahead else None

    base_filter = [
        InventoryHistory.expiration_date.isnot(None),
        InventoryHistory.remaining_quantity > 0,
        InventoryItem.organization_id == current_user.organization_id
    ]

    if expired:
        base_filter.append(InventoryHistory.expiration_date < now)
    elif days_ahead:
        base_filter.append(InventoryHistory.expiration_date.between(now, future_date))

    return db.session.query(InventoryHistory).join(InventoryItem).filter(and_(*base_filter)).all()
Then get_expired_inventory_items() and get_expiring_soon_items() just call this with different flags.

2. Batch Expiration Fallback Repeated
In 3 methods, you duplicate:

python
Copy
Edit
if sku_entry.is_perishable and sku_entry.expiration_date:
    expiration_date = sku_entry.expiration_date
elif sku_entry.batch_id:
    expiration_date = ExpirationService.get_batch_expiration_date(sku_entry.batch_id)
✅ Fix: Extract to one helper:

python
Copy
Edit
@staticmethod
def _resolve_sku_expiration(sku_entry):
    if sku_entry.is_perishable and sku_entry.expiration_date:
        return sku_entry.expiration_date
    if sku_entry.batch_id:
        return ExpirationService.get_batch_expiration_date(sku_entry.batch_id)
    return None
Then just call:

python
Copy
Edit
expiration_date = ExpirationService._resolve_sku_expiration(sku_entry)
3. get_expired_inventory_items & get_expiring_soon_items Return Format
Both return similar dict structures, with manual list construction for SKUs.

✅ Fix: One generic method could handle both.

Example:

python
Copy
Edit
@staticmethod
def _format_sku_entry(sku_entry):
    return {
        'inventory_item_id': sku_entry.inventory_item_id,
        'product_name': sku_entry.product_name,
        'variant_name': sku_entry.variant_name,
        'size_label': sku_entry.size_label,
        'quantity': sku_entry.remaining_quantity,
        'unit': sku_entry.unit,
        'expiration_date': ExpirationService._resolve_sku_expiration(sku_entry),
        'history_id': sku_entry.history_id,
        'product_inv_id': sku_entry.history_id,
        'product_id': sku_entry.product_id,
        'variant_id': sku_entry.variant_id,
        'lot_number': f"LOT-{sku_entry.history_id}"
    }
4. mark_as_expired Is Doing Too Much
It:

Deduces quantities

Updates both FIFO and ProductSKUHistory

Creates new history entries.

This violates separation of concerns: expiration should just flag, while FIFO logic should handle deductions.

✅ Fix Options:

Best Practice: Call your central adjust_inventory/FIFO service for the actual quantity adjustment instead of directly modifying remaining_quantity (consistency risk).

If keeping it direct: move this to an InventoryService and just have ExpirationService call it.

5. get_product_inventory_expiration_date Exists but Is Deprecated
Remove it entirely; you’re now correctly using SKU and batch expiration.

6. Archive Logic (archive_expired_items)
Currently just deletes FIFO entries, but you leave a pass for SKUs.

✅ Either implement or drop — dead code invites confusion.

✅ Slimmed Recommended Structure
ExpirationService should only:

Calculate expiration (calculate_expiration_date, get_days_until_expiration, _resolve_sku_expiration).

Fetch expiration data (_query_expiration_items, _format_sku_entry, get_expiration_summary).

Return actionable lists to InventoryService (which then handles quantity adjustments or archival).

Move to other services:

mark_as_expired() → Inventory/FIFO Service

archive_expired_items() → Inventory Service