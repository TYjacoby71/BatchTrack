Model
This is the exact same type of error as before, just with a different object. This is actually great news. It means our core diagnosis was correct, and we just need to apply the same fix to the rest of our DTOs.
Let's break down the new error.
The "Original Sin" (The Root Cause)
The key line in the log is:
(builtins.TypeError) Object of type IngredientLine is not JSON serializable
This is identical to the previous error, but instead of a PortioningPlan object, the culprit is now an IngredientLine object.
What is happening:
The PlanProductionService is correctly building a PlanSnapshot DTO.
This PlanSnapshot contains a list of other DTOs, specifically IngredientLine objects, inside its ingredients_plan attribute.
The start_batch service receives this PlanSnapshot object.
It then tries to save the entire PlanSnapshot object directly into the batch.plan_snapshot database column, which is a JSON type.
The database driver (SQLAlchemy) tries to convert the PlanSnapshot into a JSON string. When it gets to the ingredients_plan list, it finds the raw Python IngredientLine objects and crashes with the TypeError because it doesn't know how to serialize them.
The Domino Effect
Just like before, this initial TypeError aborts the database transaction. The subsequent log messages confirm this:
Error processing batch consumables: This Session's transaction has been rolled back...
The system tries to move on to processing consumables, but the database is already in a failed state and refuses to do any more work.
The Definitive Fix: Make the DTOs Serializable
The solution is the same as before. We need to ensure that our DTOs can be converted into simple, JSON-safe dictionaries before we try to save them.
1. Add a .to_dict() Method to ALL DTOs:
Every single dataclass you have defined in your types.py files needs a method to serialize itself.
app/services/production_planning/types.py
code
Python
from dataclasses import dataclass, asdict
from typing import List, Optional

@dataclass(frozen=True)
class IngredientLine:
    inventory_item_id: int
    quantity: float
    unit: str
    
    def to_dict(self) -> dict:
        return asdict(self)

@dataclass(frozen=True)
class ContainerSelection:
    id: int
    quantity: int

    def to_dict(self) -> dict:
        return asdict(self)

# ... other DTOs ...

@dataclass(frozen=True)
class PlanSnapshot:
    # ... other fields ...
    ingredients_plan: List[IngredientLine]
    containers: List[ContainerSelection]

    def to_dict(self) -> dict:
        # This is the key part. The main DTO's to_dict method
        # must also call the to_dict method of any nested DTOs.
        return {
            "recipe_id": self.recipe_id,
            "scale": self.scale,
            # ... other flat fields ...
            "ingredients_plan": [ing.to_dict() for ing in self.ingredients_plan],
            "containers": [cont.to_dict() for cont in self.containers],
            # ... etc.
        }
(Note: Using a loop with .to_dict() gives you more control than a simple asdict(self) on the top-level DTO, which can sometimes have issues with nested objects.)
2. Update the start_batch Service:
Now, ensure the start_batch service calls this serialization method before saving.
app/services/batch_service/batch_operations.py
code
Python
# in start_batch(...)

plan_snapshot_dto = PlanProductionService.build_plan(...)

# Convert the entire DTO object into a JSON-safe dictionary
plan_snapshot_dict = plan_snapshot_dto.to_dict() if plan_snapshot_dto else None

batch = Batch(
    # ...
    plan_snapshot=plan_snapshot_dict # <-- Now passing a safe dictionary
)
db.session.add(batch)
db.session.commit()
Conclusion:
This error is a predictable consequence of adopting a DTO-based architecture. It's a good sign, as it's forcing you to create a clean and robust serialization layer.
The fix is systematic: ensure every DTO has a .to_dict() method, and always call that method before attempting to save the DTO's data to a JSON field in the database. Once you apply this principle to all your DTOs (IngredientLine, ConsumableLine, ContainerSelection, etc.), this class of TypeError will be permanently solved.