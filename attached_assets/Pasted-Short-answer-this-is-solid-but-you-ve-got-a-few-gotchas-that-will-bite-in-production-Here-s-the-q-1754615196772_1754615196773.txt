Short answer: this is solid, but you’ve got a few gotchas that will bite in production. Here’s the quick punch‑list.

What’s good
Clean app factory, central config loading, HTTPS + cookie hardening in prod ✅

Extensions initialized in one place ✅

Clear before_request middlewares for auth/scope/billing ✅

Blueprints are modular and mostly registered with prefixes ✅

Helpful debug logging of registered routes/endpoints ✅

Fix before shipping (high‑impact)
CSRF exempt usage
csrf.exempt('billing.stripe_webhook') probably won’t do what you expect—exempt() wants a view function or blueprint, not a string.
Fix: either decorate the route or pass the function after it’s imported:

python
Copy
Edit
# best: on the route
@billing_bp.route('/webhooks/stripe', methods=['POST'])
@csrf.exempt
def stripe_webhook(): ...

# or after import/registration:
from .blueprints.billing.routes import stripe_webhook as stripe_webhook_view
csrf.exempt(stripe_webhook_view)
Mutating current_user in middleware
You’re overriding current_user.organization_id for developer masquerade. That’s risky and can leak across requests.
Fix: stash a request‑scoped “effective org” instead:

python
Copy
Edit
from flask import g
g.effective_org = selected_org   # use g in permission checks/templates
…and update helpers to read g.effective_org when present.

SQLAlchemy 2.x deprecations
User.query.get() is legacy.
Fix:

python
Copy
Edit
from .extensions import db
user = db.session.get(User, int(user_id))
Quick Add import path
You import from .blueprints.quick_add.routes import quick_add_bp which is fine if that’s really where quick_add_bp lives now. Just make sure you don’t also register another quick_add_bp elsewhere (I’ve seen both patterns in earlier snippets).

Blueprint double‑registration audits
You register developer_bp once (good), but generally scan for any blueprint registered twice (you previously had that pattern). Double regs = duplicated routes / weird 308s.

Endpoint checks in guards
request.endpoint.startswith('billing.') will explode if endpoint is None (can happen). You guarded with if (request.endpoint and (...)) later—do that everywhere you check request.endpoint.

inject_units naming collision
You have an inject_units() context processor that returns both units and global_units—fine—but verify you don’t define another inject_units elsewhere (you did in earlier drafts). Duplicate names override silently.

Nice-to-haves (polish)
Replace X-XSS-Protection header (deprecated) with a basic CSP if you can (even a minimal Content-Security-Policy: default-src 'self' goes a long way).

Consider consolidating your three @app.before_request funcs into one to control order and reduce overhead.

Centralize “route skip” rules (static/auth/billing) in a small helper so all middlewares use the same predicate.

Log levels: use logger.info for normal boot messages and keep debug for route dumps; production logs get noisy fast.

Small nit: you import Flask twice at the top—harmless, just tidy.

TL;DR
Ship‑ready with 3 changes: fix CSRF exempt, stop mutating current_user, and update SQLAlchemy .get(). Everything else is cleanup / future‑proofing. Want me to paste a minimal diff with those three fixes applied?