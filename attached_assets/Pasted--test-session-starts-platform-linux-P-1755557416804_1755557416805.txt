============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 5 items                                                              

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED [ 20%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order PASSED [ 40%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly PASSED [ 60%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 80%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service FAILED [100%]

=================================== FAILURES ===================================
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

self = <tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7fd8406a0850>
mock_route_user = <AsyncMock name='current_user' id='140566718601936'>
mock_middleware_user = <AsyncMock name='current_user' id='140566719172048'>
mock_item = <MagicMock name='InventoryItem' id='140566716535312'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140566752080592'>
mock_user_query = <MagicMock name='_get_user' id='140566750800208'>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>

    @patch('flask_login.utils._get_user')
    @patch('app.blueprints.inventory.routes.process_inventory_adjustment')
    @patch('app.blueprints.inventory.routes.InventoryItem')
    @patch('app.middleware.current_user')
    @patch('app.blueprints.inventory.routes.current_user')
    def test_adjust_inventory_initial_stock_calls_canonical_service(self, mock_route_user, mock_middleware_user, mock_item, mock_process, mock_user_query, app, client):
        """Test that initial stock adjustment uses canonical inventory service"""
    
        with app.app_context():
            # THE FIX: Now it's safe to create the mock user inside the app context
            mock_user_query.get.return_value = mock_user_with_org()
            # Mock the inventory item with no history
            mock_inventory_item = MagicMock()
            mock_inventory_item.id = 1
            mock_inventory_item.type = 'ingredient'
            mock_inventory_item.unit = 'g'
            mock_inventory_item.cost_per_unit = 2.5
            mock_inventory_item.is_perishable = False
            mock_inventory_item.organization_id = 1
    
            mock_item.query.get_or_404.return_value = mock_inventory_item
    
            # Configure both middleware and route user mocks
            mock_user_obj = mock_user_with_org()
    
            for mock_user in [mock_route_user, mock_middleware_user]:
                mock_user.id = mock_user_obj.id
                mock_user.organization_id = mock_user_obj.organization_id
                mock_user.is_authenticated = mock_user_obj.is_authenticated
                mock_user.user_type = mock_user_obj.user_type
                mock_user.organization = mock_user_obj.organization
    
            # Mock the user loader to return our mock user
            mock_process.return_value = True
    
            # Log in the mock user for the test
            with client.session_transaction() as sess:
                sess['_user_id'] = str(mock_user_obj.id)
                sess['_fresh'] = True
    
            # Mock db.session.get to return the mock user when queried by middleware
>           with patch('app.middleware.db.session.get') as mock_db_get:

tests/test_inventory_routes_canonicalization.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.middleware.db.session'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.middleware' has no attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
________________ test_recount_adjustment_uses_canonical_service ________________

client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>
test_user = <User testuser_1755557408933443>

    def test_recount_adjustment_uses_canonical_service(client, app, test_user):
        """Test that inventory recount routes use the canonical adjustment service"""
    
        with app.app_context():
            # Create test inventory item
            item = InventoryItem(
                name="Test Item",
                quantity=100,
                unit="count",
                organization_id=test_user.organization_id
            )
            db.session.add(item)
            db.session.commit()
    
            # Log in the user for the test
            with client.session_transaction() as sess:
                sess['_user_id'] = str(test_user.id)
                sess['_fresh'] = True
    
            # Mock the canonical service at the route import path
            with patch('app.blueprints.inventory.routes.process_inventory_adjustment') as mock_adjustment:
                mock_adjustment.return_value = True
    
                # Make recount request
>               response = client.post(f'/inventory/adjust/{item.id}', data={
                    'adjustment_type': 'recount',
                    'quantity': '80',
                    'notes': 'Physical count adjustment'
                })

tests/test_inventory_routes_canonicalization.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
.pythonlibs/lib/python3.11/site-packages/flask/testing.py:235: in open
    response = super().open(
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
.pythonlibs/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
.pythonlibs/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
.pythonlibs/lib/python3.11/site-packages/flask_login/utils.py:290: in decorated_view
    return current_app.ensure_sync(func)(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item_id = 1

    @inventory_bp.route('/adjust/<int:item_id>', methods=['POST'])
    @login_required
    def adjust_inventory(item_id):
        """
        A thin controller that delegates ALL adjustment logic to the canonical service.
        This fixes the "initial stock" bug.
        """
        item = db.session.get(InventoryItem, int(item_id))
        if not item:
            flash("Inventory item not found.", "error")
            return redirect(url_for('.list_inventory'))
    
        # Authority check
        if not can_edit_inventory_item(item):
            flash('Permission denied.', 'error')
            return redirect(url_for('.list_inventory'))
    
        # --- 1. Gather all data from the form ---
        form_data = request.form
        adjustment_type = form_data.get('adjustment_type', '').strip().lower()
    
        try:
            quantity = float(form_data.get('quantity', 0.0))
        except (ValueError, TypeError):
            flash("Invalid quantity provided.", "error")
            return redirect(url_for('.view_inventory', id=item_id))
    
        # --- 2. Call the ONE canonical service with all the data ---
>       success, message = process_inventory_adjustment(
            item_id=item.id,
            quantity=quantity,
            change_type=adjustment_type,
            notes=form_data.get('notes'),
            unit=form_data.get('input_unit') or item.unit,
            cost_override=float(form_data.get('cost_per_unit')) if form_data.get('cost_per_unit') else None,
            custom_expiration_date=form_data.get('expiration_date'),  # Use correct parameter name
            created_by=current_user.id
        )
E       TypeError: cannot unpack non-iterable bool object

app/blueprints/inventory/routes.py:231: TypeError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured stdout call -----------------------------
--- EXECUTING CORRECT MIDDLEWARE ---
MIDDLEWARE DEBUG: Processing POST /inventory/adjust/1, endpoint=inventory.adjust_inventory
MIDDLEWARE DEBUG: User authenticated=True
DEBUG: User 2, Org billing_status=active
DEBUG: Tier exempt=False
=============================== warnings summary ===============================
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - AttributeError: module 'app.middleware' has no attribute 'db'
FAILED tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service - TypeError: cannot unpack non-iterable bool object
=================== 2 failed, 3 passed, 9 warnings in 11.86s ===================
