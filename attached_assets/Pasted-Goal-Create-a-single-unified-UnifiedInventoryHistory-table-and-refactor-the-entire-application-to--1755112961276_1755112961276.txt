Goal: Create a single, unified UnifiedInventoryHistory table and refactor the entire application to use it, eliminating the need for complex branching logic.
Step 1: Create the New Unified Model
First, we will create the new, combined model. This model will contain all the columns from both of the old tables. The product-specific columns will be made nullable=True so they don't cause issues for ingredient entries.
Action:
Create a new file: app/models/unified_inventory_history.py.
Paste the following code into it. This model is the superset of your two old models.
code
Python
# app/models/unified_inventory_history.py
from . import db
from datetime import datetime
from .mixins import ScopedModelMixin

class UnifiedInventoryHistory(ScopedModelMixin, db.Model):
    __tablename__ = 'unified_inventory_history'

    id = db.Column(db.Integer, primary_key=True)
    inventory_item_id = db.Column(db.Integer, db.ForeignKey('inventory_item.id'), nullable=False, index=True)
    organization_id = db.Column(db.Integer, db.ForeignKey('organization.id'), nullable=False, index=True)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, nullable=False, index=True)
    change_type = db.Column(db.String(50), nullable=False, index=True)
    quantity_change = db.Column(db.Float, nullable=False)
    unit = db.Column(db.String(50))
    unit_cost = db.Column(db.Float)
    remaining_quantity = db.Column(db.Float, default=0.0)

    # FIFO Tracking
    fifo_reference_id = db.Column(db.Integer, db.ForeignKey('unified_inventory_history.id'), nullable=True)
    fifo_code = db.Column(db.String(64), index=True)

    # Contextual Information
    batch_id = db.Column(db.Integer, db.ForeignKey('batch.id'), nullable=True)
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    notes = db.Column(db.Text)

    # Perishability
    is_perishable = db.Column(db.Boolean, default=False)
    shelf_life_days = db.Column(db.Integer)
    expiration_date = db.Column(db.Date, nullable=True, index=True)

    # --- Product-Specific Fields (Nullable) ---
    customer = db.Column(db.String(255), nullable=True)
    sale_price = db.Column(db.Float, nullable=True)
    order_id = db.Column(db.String(255), nullable=True)

    # Relationships
    inventory_item = db.relationship('InventoryItem')
    batch = db.relationship('Batch')
    creator = db.relationship('User')
    fifo_reference = db.relationship('UnifiedInventoryHistory', remote_side=[id])

    def __repr__(self):
        return f'<UnifiedInventoryHistory {self.id} | Item {self.inventory_item_id} | Qty {self.quantity_change}>'
Step 2: The Database Migration (The Critical Part)
This is the most important step. We will create a database migration that safely moves all your existing data into the new table.
Action:
From your terminal, generate a new, empty migration file:
code
Bash
flask db revision -m "Create unified inventory history and merge data"
Open the newly created file in your migrations/versions/ folder.
Delete everything in that file and replace it with the code below. This script will:
Create the new unified_inventory_history table.
Copy all data from inventory_history into the new table.
Copy all data from product_sku_history into the new table.
Safely drop the two old tables.
code
Python
"""Create unified inventory history and merge data

Revision ID: [Alembic will generate this]
Revises: [The previous revision ID]
Create Date: [Date]

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '[PASTE THE NEW REVISION ID HERE]'
down_revision = '[PASTE THE PREVIOUS REVISION ID HERE]'
branch_labels = None
depends_on = None

def upgrade():
    # Step 1: Create the new unified table
    op.create_table('unified_inventory_history',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('inventory_item_id', sa.Integer(), nullable=False),
        sa.Column('organization_id', sa.Integer(), nullable=False),
        sa.Column('timestamp', sa.DateTime(), nullable=False),
        sa.Column('change_type', sa.String(length=50), nullable=False),
        sa.Column('quantity_change', sa.Float(), nullable=False),
        sa.Column('unit', sa.String(length=50), nullable=True),
        sa.Column('unit_cost', sa.Float(), nullable=True),
        sa.Column('remaining_quantity', sa.Float(), nullable=True),
        sa.Column('fifo_reference_id', sa.Integer(), nullable=True),
        sa.Column('fifo_code', sa.String(length=64), nullable=True),
        sa.Column('batch_id', sa.Integer(), nullable=True),
        sa.Column('created_by', sa.Integer(), nullable=True),
        sa.Column('notes', sa.Text(), nullable=True),
        sa.Column('is_perishable', sa.Boolean(), nullable=True),
        sa.Column('shelf_life_days', sa.Integer(), nullable=True),
        sa.Column('expiration_date', sa.Date(), nullable=True),
        sa.Column('customer', sa.String(length=255), nullable=True),
        sa.Column('sale_price', sa.Float(), nullable=True),
        sa.Column('order_id', sa.String(length=255), nullable=True),
        sa.ForeignKeyConstraint(['batch_id'], ['batch.id'], ),
        sa.ForeignKeyConstraint(['created_by'], ['user.id'], ),
        sa.ForeignKeyConstraint(['fifo_reference_id'], ['unified_inventory_history.id'], ),
        sa.ForeignKeyConstraint(['inventory_item_id'], ['inventory_item.id'], ),
        sa.ForeignKeyConstraint(['organization_id'], ['organization.id'], ),
        sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('unified_inventory_history', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_unified_inventory_history_change_type'), ['change_type'], unique=False)
        batch_op.create_index(batch_op.f('ix_unified_inventory_history_expiration_date'), ['expiration_date'], unique=False)
        batch_op.create_index(batch_op.f('ix_unified_inventory_history_fifo_code'), ['fifo_code'], unique=False)
        batch_op.create_index(batch_op.f('ix_unified_inventory_history_inventory_item_id'), ['inventory_item_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_unified_inventory_history_organization_id'), ['organization_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_unified_inventory_history_timestamp'), ['timestamp'], unique=False)

    # Step 2: Copy data from the old tables into the new one
    # Note: We are mapping old columns to new ones. 'note' from InventoryHistory becomes 'notes'.
    op.execute("""
        INSERT INTO unified_inventory_history (
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id,
            created_by, notes, is_perishable, shelf_life_days, expiration_date
        )
        SELECT
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, used_for_batch_id,
            created_by, note, is_perishable, shelf_life_days, expiration_date
        FROM inventory_history;
    """)

    op.execute("""
        INSERT INTO unified_inventory_history (
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id,
            created_by, notes, is_perishable, shelf_life_days, expiration_date,
            customer, sale_price, order_id
        )
        SELECT
            id, inventory_item_id, organization_id, timestamp, change_type, quantity_change,
            unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id,
            created_by, notes, is_perishable, shelf_life_days, expiration_date,
            customer, sale_price, order_id
        FROM product_sku_history;
    """)

    # Step 3: Drop the old tables
    op.drop_table('product_sku_history')
    op.drop_table('inventory_history')

def downgrade():
    # (For safety, a downgrade script to recreate the old tables as empty)
    op.create_table('inventory_history', ...) # Recreate old schema
    op.create_table('product_sku_history', ...) # Recreate old schema
    op.drop_table('unified_inventory_history')
Step 3: Refactor the Application Code
Now we perform a global search-and-replace to update all code that uses the old models.
Action:
Search: Find every file that imports InventoryHistory or ProductSKUHistory.
Replace:
Replace from app.models.inventory import InventoryHistory with from app.models.unified_inventory_history import UnifiedInventoryHistory.
Replace from app.models.product import ProductSKUHistory with from app.models.unified_inventory_history import UnifiedInventoryHistory.
Replace all uses of InventoryHistory and ProductSKUHistory with UnifiedInventoryHistory.
Simplify: This is the payoff. Find every if item.type == 'product': ... else: ... block that was choosing between the two history models and delete it. You now only need one code path. This will dramatically simplify _fifo_ops.py, _recount_logic.py, and expiration/services.py.
Step 4: Update the Tests and Run
Finally, update the tests to use the new unified model and confirm that everything still works.
Action:
Perform the same search-and-replace in your tests/ directory.
Update conftest.py and any other test fixtures that create history records.
Run the full test suite:
code
Bash
pytest -q
We are aiming for a 34/34 passed result. Once this is done, you will have completed a major architectural improvement that will pay dividends for the entire future of your project. This is a big step, so take it carefully, but it is the right one.