            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3d9e090>
cursor = <sqlite3.Cursor object at 0x7f15a2e89fc0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Item', None, None, 100.0, 'count', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8e34d90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    def test_expiration_service_uses_canonical_adjustment(app, db_session):
        """Test that expiration disposal uses the canonical inventory adjustment service"""
    
        # Create test data
        item = InventoryItem(name="Test Item", quantity=100, unit="count")
        db_session.add(item)
>       db_session.commit()

tests/test_expiration_canonicalization.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3d9e090>
cursor = <sqlite3.Cursor object at 0x7f15a2e89fc0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Item', None, None, 100.0, 'count', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8e34d90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Test Item', None, None, 100.0, 'count', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:49:59.617301', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', None)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
______________________ test_extras_cannot_use_expired_lot ______________________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a3a2f050>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2c14e90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8660110>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a8661010>
parameters = [('Expired Apple', None, None, 0.0, 'g', 1.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2c14e90>
cursor = <sqlite3.Cursor object at 0x7f15a829fec0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Expired Apple', None, None, 0.0, 'g', 1.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8660110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...', 3)]\n(Background on this error at: https://sqlalche.me/e/20/e3q8)") raised in repr()] User object at 0x7f15a3a38a90>
test_org = <Organization 3>

    def test_extras_cannot_use_expired_lot(app, db_session, test_user, test_org):
        from app.models import InventoryItem, Recipe
        from app.models.inventory_lot import InventoryLot
        from app.services.batch_service.batch_operations import BatchOperationsService
        from app.services.production_planning.service import PlanProductionService
        from app.utils.timezone_utils import TimezoneUtils
        from datetime import timedelta
    
        # Create perishable inventory item
        item = InventoryItem(
            name="Expired Apple",
            unit="g",
            quantity=0.0,
            is_perishable=True,
            shelf_life_days=7,
            cost_per_unit=1.0,
            organization_id=test_org.id
        )
        db_session.add(item)
>       db_session.flush()

tests/test_extras_expiration.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2c14e90>
cursor = <sqlite3.Cursor object at 0x7f15a829fec0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Expired Apple', None, None, 0.0, 'g', 1.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8660110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Expired Apple', None, None, 0.0, 'g', 1.0, 0.0, None, 'ingredient', 1, 0, 1, 7, None, None, None, None, None, None, None, None, '2025-11-12 21:50:04.819984', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
__________________ test_global_link_suggestions_and_link_flow __________________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a36dda10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3613dd0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8df1790>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a8df1350>
parameters = [('Milk', 'ingredient', 1.03, 'ml', 1, 0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3613dd0>
cursor = <sqlite3.Cursor object at 0x7f15a2b90ac0>
statement = 'INSERT INTO global_item (name, item_type, density, default_unit, ingredient_category_id, default_is_perishable, recom...d_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Milk', 'ingredient', 1.03, 'ml', 1, 0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8df1790>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table global_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    @pytest.mark.usefixtures("app", "db_session")
    def test_global_link_suggestions_and_link_flow(app, db_session):
        from app.models import InventoryItem, GlobalItem, IngredientCategory, Unit, User, Organization
    
        # Ensure base units exist (weight, volume, count)
        if not Unit.query.filter_by(name='g').first():
            db_session.add(Unit(name='g', symbol='g', unit_type='weight', conversion_factor=1.0))
        if not Unit.query.filter_by(name='ml').first():
            db_session.add(Unit(name='ml', symbol='ml', unit_type='volume', conversion_factor=1.0))
        if not Unit.query.filter_by(name='count').first():
            db_session.add(Unit(name='count', symbol='ct', unit_type='count', conversion_factor=1.0))
        db_session.commit()
    
        # Create org and user context
        org = Organization(name='Test Org')
        db_session.add(org)
        db_session.flush()
    
        user = User(email='test@example.com', user_type='developer', is_active=True, organization_id=org.id)
        db_session.add(user)
        db_session.commit()
    
        # Create a curated category and global item 'Milk' stored in volume (ml) with density
        cat = IngredientCategory(name='Liquids', default_density=1.0, organization_id=None, is_global_category=True)
        db_session.add(cat)
        db_session.flush()
    
        gi = GlobalItem(name='Milk', item_type='ingredient', default_unit='ml', density=1.03, ingredient_category_id=cat.id)
        db_session.add(gi)
>       db_session.commit()

tests/test_global_link_drawer.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3613dd0>
cursor = <sqlite3.Cursor object at 0x7f15a2b90ac0>
statement = 'INSERT INTO global_item (name, item_type, density, default_unit, ingredient_category_id, default_is_perishable, recom...d_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Milk', 'ingredient', 1.03, 'ml', 1, 0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a8df1790>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table global_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO global_item (name, item_type, density, default_unit, ingredient_category_id, default_is_perishable, recommended_shelf_life_days, recommended_usage_rate, recommended_fragrance_load_pct, is_active_ingredient, inci_name, capacity, capacity_unit, container_material, container_type, container_style, container_color, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, ph_min, ph_max, moisture_content_percent, comedogenic_rating, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, is_archived, archived_at, archived_by, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Milk', 'ingredient', 1.03, 'ml', 1, 0, None, None, None, 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 0, None, None, '2025-11-12 21:50:09.339421', '2025-11-12 21:50:09.339424')]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_ TestInventoryCostingToggleAndWAC.test_wac_updates_after_restock_and_deduct_fifo_mode _

self = <sqlalchemy.engine.base.Connection object at 0x7f15a8fdf3d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8780c50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a32a0390>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a32a3550>
parameters = [('Olive Oil', None, None, 0.0, 'ml', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8780c50>
cursor = <sqlite3.Cursor object at 0x7f15a3b8bbc0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Olive Oil', None, None, 0.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a32a0390>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_costing_toggle.TestInventoryCostingToggleAndWAC object at 0x7f15ab7b1250>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <User testuser_1762984241680452>, test_org = <Organization 3>

    def test_wac_updates_after_restock_and_deduct_fifo_mode(self, app, db_session, test_user, test_org):
        with app.test_request_context():
            # Ensure org is in FIFO mode
            test_org.inventory_cost_method = 'fifo'
            db_session.add(test_org)
    
            login_user(test_user)
    
            # Create an ingredient
            item = InventoryItem(
                name="Olive Oil",
                type="ingredient",
                unit="ml",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id,
                cost_per_unit=0.0
            )
            db_session.add(item)
>           db_session.flush()

tests/test_inventory_costing_toggle.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8780c50>
cursor = <sqlite3.Cursor object at 0x7f15a3b8bbc0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Olive Oil', None, None, 0.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a32a0390>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Olive Oil', None, None, 0.0, 'ml', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, 2, '2025-11-12 21:50:41.718047', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_ TestInventoryCostingToggleAndWAC.test_wac_updates_after_restock_average_mode _

self = <sqlalchemy.engine.base.Connection object at 0x7f15a27b4a50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a876c6d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a29292d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a292ae10>
parameters = [('Sugar', None, None, 0.0, 'g', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a876c6d0>
cursor = <sqlite3.Cursor object at 0x7f15a33cfc40>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Sugar', None, None, 0.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a29292d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_costing_toggle.TestInventoryCostingToggleAndWAC object at 0x7f15ab7b1790>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <User testuser_1762984246297548>, test_org = <Organization 3>

    def test_wac_updates_after_restock_average_mode(self, app, db_session, test_user, test_org):
        with app.test_request_context():
            # Switch org to Average mode
            test_org.inventory_cost_method = 'average'
            db_session.add(test_org)
    
            login_user(test_user)
    
            # Create an ingredient
            item = InventoryItem(
                name="Sugar",
                type="ingredient",
                unit="g",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id,
                cost_per_unit=0.0
            )
            db_session.add(item)
>           db_session.flush()

tests/test_inventory_costing_toggle.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a876c6d0>
cursor = <sqlite3.Cursor object at 0x7f15a33cfc40>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Sugar', None, None, 0.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a29292d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Sugar', None, None, 0.0, 'g', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, 2, '2025-11-12 21:50:46.350428', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_________ TestInventoryFIFOCharacterization.test_fifo_deduction_order __________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a8416ad0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a335eb90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a23d1050>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a23d1950>
parameters = [('Test Ingredient', None, None, 0.0, 'g', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a335eb90>
cursor = <sqlite3.Cursor object at 0x7f15a83a98c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Ingredient', None, None, 0.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a23d1050>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f15ab7b44d0>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <User testuser_1762984254355507>, test_org = <Organization 3>

    def test_fifo_deduction_order(self, app, db_session, test_user, test_org):
        """Test FIFO deduction follows first-in-first-out order."""
        with app.test_request_context():
            login_user(test_user)
    
            # Create inventory item
            item = InventoryItem(
                name="Test Ingredient",
                type="ingredient",
                unit="g",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
>           db_session.flush()

tests/test_inventory_fifo.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a335eb90>
cursor = <sqlite3.Cursor object at 0x7f15a83a98c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Ingredient', None, None, 0.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a23d1050>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Test Ingredient', None, None, 0.0, 'g', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, 2, '2025-11-12 21:50:54.399422', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_ TestInventoryFIFOCharacterization.test_inventory_adjustment_delegates_properly _

self = <sqlalchemy.engine.base.Connection object at 0x7f15aabd2c90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15abde6890>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15aac30090>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15aac31a90>
parameters = [('Test Product', None, None, 0.0, 'ml', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15abde6890>
cursor = <sqlite3.Cursor object at 0x7f15a302a0c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Product', None, None, 0.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15aac30090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f15ab7b49d0>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <User testuser_1762984258665053>, test_org = <Organization 3>

    def test_inventory_adjustment_delegates_properly(self, app, db_session, test_user, test_org):
        """Verify inventory adjustment service delegates to proper internal systems."""
        with app.test_request_context():
            login_user(test_user)
    
            item = InventoryItem(
                name="Test Product",
                type="product",
                unit="ml",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
>           db_session.commit()  # Commit instead of flush

tests/test_inventory_fifo.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15abde6890>
cursor = <sqlite3.Cursor object at 0x7f15a302a0c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Product', None, None, 0.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15aac30090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Test Product', None, None, 0.0, 'ml', 0.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, 2, '2025-11-12 21:50:58.708794', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_______ test_batch_start_routes_all_deductions_through_canonical_service _______

self = <sqlalchemy.engine.base.Connection object at 0x7f15a291b650>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2af9d50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a904b710>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a904a910>
parameters = [('Canon Ingredient 82964cc722514d6a85db1c0fbe646e9a', None, None, 500.0, 'g', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2af9d50>
cursor = <sqlite3.Cursor object at 0x7f15a25a14c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Canon Ingredient 82964cc722514d6a85db1c0fbe646e9a', None, None, 500.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a904b710>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...', 2)]\n(Background on this error at: https://sqlalche.me/e/20/e3q8)") raised in repr()] User object at 0x7f15a8bc3650>

    @pytest.mark.usefixtures('app', 'db_session')
    def test_batch_start_routes_all_deductions_through_canonical_service(app, db_session, test_user):
        ingredient = InventoryItem(
            name=f"Canon Ingredient {uuid4().hex}",
            type='ingredient',
            unit='g',
            quantity=500,
            organization_id=test_user.organization_id,
        )
        db_session.add(ingredient)
>       db_session.flush()

tests/test_inventory_routes_canonicalization.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2af9d50>
cursor = <sqlite3.Cursor object at 0x7f15a25a14c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Canon Ingredient 82964cc722514d6a85db1c0fbe646e9a', None, None, 500.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a904b710>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Canon Ingredient 82964cc722514d6a85db1c0fbe646e9a', None, None, 500.0, 'g', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:02.859468', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
______________ test_expiration_service_uses_canonical_adjustment _______________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a8eeb610>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2ed4e90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a3d1d190>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a3d1ce90>
parameters = [('Perishable fe780ad2b5444c6da4d62b3bc5502ff7', None, None, 50.0, 'ml', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2ed4e90>
cursor = <sqlite3.Cursor object at 0x7f15a83c95c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Perishable fe780ad2b5444c6da4d62b3bc5502ff7', None, None, 50.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a3d1d190>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...', 2)]\n(Background on this error at: https://sqlalche.me/e/20/e3q8)") raised in repr()] User object at 0x7f15a2cb8fd0>

    @pytest.mark.usefixtures('app', 'db_session')
    def test_expiration_service_uses_canonical_adjustment(app, db_session, test_user):
        item = InventoryItem(
            name=f"Perishable {uuid4().hex}",
            type='ingredient',
            unit='ml',
            quantity=50,
            organization_id=test_user.organization_id,
        )
        db_session.add(item)
>       db_session.flush()

tests/test_inventory_routes_canonicalization.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a2ed4e90>
cursor = <sqlite3.Cursor object at 0x7f15a83c95c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Perishable fe780ad2b5444c6da4d62b3bc5502ff7', None, None, 50.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a3d1d190>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Perishable fe780ad2b5444c6da4d62b3bc5502ff7', None, None, 50.0, 'ml', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:07.193183', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_____________________ test_plan_start_finish_non_portioned _____________________

app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    def test_plan_start_finish_non_portioned(app, client, db_session):
        # Arrange: create a simple recipe
        from app.models import Recipe
        r = Recipe(name='Simple Syrup', predicted_yield=10.0, predicted_yield_unit='oz', category_id=1)
        db_session.add(r)
        db_session.commit()
    
        # Act: start batch with no portioning
        resp = _api(client, app, '/batches/api/start-batch', {
            'recipe_id': r.id,
            'scale': 1,
            'batch_type': 'ingredient',
            'notes': '',
            'requires_containers': False,
            'containers': []
        })
        assert resp.status_code == 200
        data = resp.get_json()
        assert data['success'] is True
        batch_id = data['batch_id']
    
        # Assert: batch in progress page renders and shows projected yield
        page = client.get(f'/batches/in-progress/{batch_id}')
>       assert page.status_code == 200
E       assert 302 == 200
E        +  where 302 = <WrapperTestResponse streamed [302 FOUND]>.status_code

tests/test_plan_production_integration.py:44: AssertionError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
----------------------------- Captured stdout call -----------------------------
🔍 BATCH_SERVICE DEBUG: Starting batch from snapshot for recipe Simple Syrup
🔍 BATCH_SERVICE DEBUG: Creating batch with portioning snapshot: None
🔍 BATCH_SERVICE DEBUG: Batch object created with label: SS-2025-001
🔍 BATCH_SERVICE DEBUG: ✅ BATCH CREATED SUCCESSFULLY!
🔍 BATCH_SERVICE DEBUG: Final batch ID: 1
🔍 BATCH_SERVICE DEBUG: Final batch label: SS-2025-001
DEBUG: Looking for active batch 1
DEBUG: get_batch_by_identifier called with: 1
DEBUG: Current user organization_id: 1
DEBUG: Batch exists (unscoped): True
DEBUG: Batch organization_id: 1
DEBUG: Found batch: SS-2025-001, status: in_progress
_______________________ test_plan_start_finish_portioned _______________________

app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    def test_plan_start_finish_portioned(app, client, db_session):
        # Arrange: create a portioned recipe
        from app.models import Recipe
        r = Recipe(
            name='Goat Milk Soap',
            predicted_yield=10.0,
            predicted_yield_unit='oz',
            category_id=1,
            portioning_data={'is_portioned': True, 'portion_name': 'bars', 'portion_count': 20},
            is_portioned=True,
            portion_name='bars',
            portion_count=20
        )
        db_session.add(r)
        db_session.commit()
    
        # Act: start batch with flat portion fields
        resp = _api(client, app, '/batches/api/start-batch', {
            'recipe_id': r.id,
            'scale': 1,
            'batch_type': 'product',
            'notes': '',
            'requires_containers': False,
            'containers': [],
            'is_portioned': True,
            'portion_name': 'bars',
            'portion_count': 20
        })
        assert resp.status_code == 200
        data = resp.get_json()
        assert data['success'] is True
        batch_id = data['batch_id']
    
        # Assert: batch in progress shows projected portions
        page = client.get(f'/batches/in-progress/{batch_id}')
>       assert page.status_code == 200
E       assert 302 == 200
E        +  where 302 = <WrapperTestResponse streamed [302 FOUND]>.status_code

tests/test_plan_production_integration.py:95: AssertionError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
----------------------------- Captured stdout call -----------------------------
🔍 BATCH_SERVICE DEBUG: Starting batch from snapshot for recipe Goat Milk Soap
🔍 BATCH_SERVICE DEBUG: Creating batch with portioning snapshot: {'is_portioned': True, 'portion_name': 'bars', 'portion_count': 20, 'portion_unit_id': None}
🔍 BATCH_SERVICE DEBUG: Batch object created with label: GMS-2025-001
🔍 BATCH_SERVICE DEBUG: ✅ BATCH CREATED SUCCESSFULLY!
🔍 BATCH_SERVICE DEBUG: Final batch ID: 1
🔍 BATCH_SERVICE DEBUG: Final batch label: GMS-2025-001
DEBUG: Looking for active batch 1
DEBUG: get_batch_by_identifier called with: 1
DEBUG: Current user organization_id: 1
DEBUG: Batch exists (unscoped): True
DEBUG: Batch organization_id: 1
DEBUG: Found batch: GMS-2025-001, status: in_progress
______________________ test_portioning_sku_labels_differ _______________________

client = <FlaskClient <Flask 'app'>>

    @pytest.mark.usefixtures('app_context')
    def test_portioning_sku_labels_differ(client):
        # Seed category and count units
        soaps = ProductCategory(name='Soaps', is_typically_portioned=True)
        db.session.add(soaps)
        if not Unit.query.filter_by(name='Piece').first():
            db.session.add(Unit(name='Piece', unit_type='count', conversion_factor=1.0, base_unit='Piece', is_active=True, is_custom=False, is_mapped=True))
        if not Unit.query.filter_by(name='oz').first():
            db.session.add(Unit(name='oz', unit_type='weight', conversion_factor=1.0, base_unit='oz', is_active=True, is_custom=False, is_mapped=True))
        if not Unit.query.filter_by(name='lb').first():
            db.session.add(Unit(name='lb', unit_type='weight', conversion_factor=16.0, base_unit='oz', is_active=True, is_custom=False, is_mapped=True))
        db.session.commit()
    
        # Create product and variant
        product = Product(name='Salt Soap', category_id=soaps.id)
        db.session.add(product)
        db.session.flush()
        variant = ProductVariant(product_id=product.id, name='Lavender')
        db.session.add(variant)
        db.session.commit()
    
        # Create portioned recipe (5 lb bulk, 10 portions)
        ok, recipe = create_recipe(
            name='Salt Soap Base - Lavender',
            instructions='Mix and pour',
            yield_amount=0,
            yield_unit='',
            ingredients=[],
            allowed_containers=[],
            label_prefix='SOAP',
            category_id=soaps.id,
            portioning_data={
                'is_portioned': True,
                'portion_count': 10,
                'portion_name': 'Bar',
                'bulk_yield_quantity': 5.0,
                'bulk_yield_unit_id': Unit.query.filter_by(name='lb').first().id
            }
        )
        assert ok, f"Failed to create recipe: {recipe}"
    
        # Start batch
        snapshot = PlanProductionService.build_plan(recipe=recipe, scale=1.0, batch_type='product', notes='Test batch', containers=[])
        batch, errs = BatchOperationsService.start_batch(snapshot.to_dict())
        assert batch is not None, f"Start batch failed: {errs}"
    
        # Finish batch with 5 lb final bulk and 10 portions
        resp_ok, msg = BatchOperationsService.complete_batch(batch.id, {
            'output_type': 'product',
            'product_id': product.id,
            'variant_id': variant.id,
            'final_quantity': '5',
            'output_unit': 'lb',
            'final_portions': '10'
        })
>       assert resp_ok, f"Complete batch failed: {msg}"
E       AssertionError: Complete batch failed: Error completing batch: This Session's transaction has been rolled back due to a previous exception during flush. To begin a new transaction with this Session, first issue Session.rollback(). Original exception was: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E         [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E         [parameters: ('Salt Soap - Lavender - 0.5 lb Bar', None, None, 0.0, 'count', 0.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, 1, '2025-11-12 21:51:18.892203', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 1)]
E         (Background on this error at: https://sqlalche.me/e/20/e3q8) (Background on this error at: https://sqlalche.me/e/20/7s2a)
E       assert False

tests/test_portioning_sku_derivation.py:69: AssertionError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
----------------------------- Captured stdout call -----------------------------
🔍 BATCH_SERVICE DEBUG: Starting batch from snapshot for recipe Salt Soap Base - Lavender
🔍 BATCH_SERVICE DEBUG: Creating batch with portioning snapshot: {'is_portioned': True, 'portion_name': 'Bar', 'portion_count': 10, 'portion_unit_id': None}
🔍 BATCH_SERVICE DEBUG: Batch object created with label: SOAP-2025-001
🔍 BATCH_SERVICE DEBUG: ✅ BATCH CREATED SUCCESSFULLY!
🔍 BATCH_SERVICE DEBUG: Final batch ID: 1
🔍 BATCH_SERVICE DEBUG: Final batch label: SOAP-2025-001
________________ test_reserve_inventory_calls_canonical_service ________________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a8d07490>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a13e0cd0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a2c7c150>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a2c7fa10>
parameters = [('POS Item 6e822158a30646d28b3c0498ac9bc8bd', None, None, 25.0, 'count', 3.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a13e0cd0>
cursor = <sqlite3.Cursor object at 0x7f15a0bfa5c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('POS Item 6e822158a30646d28b3c0498ac9bc8bd', None, None, 25.0, 'count', 3.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a2c7c150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...', 2)]\n(Background on this error at: https://sqlalche.me/e/20/e3q8)") raised in repr()] User object at 0x7f15a3b32e90>

    @pytest.mark.usefixtures('app', 'db_session')
    def test_reserve_inventory_calls_canonical_service(app, db_session, test_user):
        suffix = uuid4().hex
        item = InventoryItem(
            name=f"POS Item {suffix}",
            type='product',
            unit='count',
            quantity=25,
            organization_id=test_user.organization_id,
            cost_per_unit=3.0,
        )
        db_session.add(item)
>       db_session.commit()

tests/test_pos_integration_canonicalization.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a13e0cd0>
cursor = <sqlite3.Cursor object at 0x7f15a0bfa5c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('POS Item 6e822158a30646d28b3c0498ac9bc8bd', None, None, 25.0, 'count', 3.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a2c7c150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('POS Item 6e822158a30646d28b3c0498ac9bc8bd', None, None, 25.0, 'count', 3.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:22.755673', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
___________________ test_confirm_sale_uses_canonical_service ___________________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a8cb7810>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8243dd0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a301d290>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8243dd0>
cursor = <sqlite3.Cursor object at 0x7f15a83ea0c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh... ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id'
parameters = ('Sold Product 6e00a2559a2f449abfa92a2d3e34656d', None, None, 30.0, 'piece', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a301d290>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    @pytest.mark.usefixtures('app', 'db_session')
    def test_confirm_sale_uses_canonical_service(app, db_session):
        suffix = uuid4().hex
        org = Organization(name=f"POS Org {suffix}")
        db_session.add(org)
        db_session.flush()
    
        product = InventoryItem(
            name=f"Sold Product {suffix}",
            type='product',
            unit='piece',
            quantity=30,
            organization_id=org.id,
        )
        reserved = InventoryItem(
            name=f"Sold Product {suffix} (Reserved)",
            type='product-reserved',
            unit='piece',
            quantity=5,
            organization_id=org.id,
        )
        db_session.add_all([product, reserved])
>       db_session.flush()

tests/test_pos_integration_canonicalization.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_insertmany_context(dialect, context)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2123: in _exec_insertmany_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2115: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8243dd0>
cursor = <sqlite3.Cursor object at 0x7f15a83ea0c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh... ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id'
parameters = ('Sold Product 6e00a2559a2f449abfa92a2d3e34656d', None, None, 30.0, 'piece', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a301d290>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_mater ... 506 characters truncated ...  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id]
E       [parameters: ('Sold Product 6e00a2559a2f449abfa92a2d3e34656d', None, None, 30.0, 'piece', 0.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:27.392526', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
__________________ test_confirm_return_uses_canonical_service __________________

self = <sqlalchemy.engine.base.Connection object at 0x7f15a8f66590>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3483e90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a81d1550>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3483e90>
cursor = <sqlite3.Cursor object at 0x7f15a3262840>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh... ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id'
parameters = ('Returned Product 3eff61a64e96413b9ab9e38904e09650', None, None, 10.0, 'piece', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a81d1550>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    @pytest.mark.usefixtures('app', 'db_session')
    def test_confirm_return_uses_canonical_service(app, db_session):
        suffix = uuid4().hex
        org = Organization(name=f"POS Org Return {suffix}")
        db_session.add(org)
        db_session.flush()
    
        product = InventoryItem(
            name=f"Returned Product {suffix}",
            type='product',
            unit='piece',
            quantity=10,
            organization_id=org.id,
        )
        reserved = InventoryItem(
            name=f"Returned Product {suffix} (Reserved)",
            type='product-reserved',
            unit='piece',
            quantity=0,
            organization_id=org.id,
        )
        db_session.add_all([product, reserved])
>       db_session.flush()

tests/test_pos_integration_canonicalization.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_insertmany_context(dialect, context)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2123: in _exec_insertmany_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2115: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a3483e90>
cursor = <sqlite3.Cursor object at 0x7f15a3262840>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh... ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id'
parameters = ('Returned Product 3eff61a64e96413b9ab9e38904e09650', None, None, 10.0, 'piece', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a81d1550>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_mater ... 506 characters truncated ...  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id]
E       [parameters: ('Returned Product 3eff61a64e96413b9ab9e38904e09650', None, None, 10.0, 'piece', 0.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:32.133031', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_ TestReservationCanonicalService.test_create_reservation_uses_canonical_service _

self = <sqlalchemy.engine.base.Connection object at 0x7f15a80dc990>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8d5e090>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a39c0850>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a39c0350>
parameters = [('Test Product Res 308172', None, None, 50.0, 'piece', 10.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8d5e090>
cursor = <sqlite3.Cursor object at 0x7f15a2fae1c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Product Res 308172', None, None, 50.0, 'piece', 10.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a39c0850>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_reservation_canonicalization.TestReservationCanonicalService object at 0x7f15ab6dc7d0>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    def test_create_reservation_uses_canonical_service(self, app, db_session):
        """Test that creating reservations uses canonical inventory adjustment"""
    
        # Create test data
        from app.models import Organization, User, SubscriptionTier, InventoryItem
    
        import time
        unique_suffix = str(int(time.time() * 1000))[-6:]
    
        tier = SubscriptionTier(name=f"Test Tier Res {unique_suffix}", tier_type="monthly", user_limit=5)
        db_session.add(tier)
        db_session.flush()
    
        org = Organization(name=f"Test Org Res {unique_suffix}", billing_status="active", subscription_tier_id=tier.id)
        db_session.add(org)
        db_session.flush()
    
        user = User(username=f"testuser_res_{unique_suffix}", email=f"res{unique_suffix}@example.com", organization_id=org.id)
        db_session.add(user)
        db_session.flush()
    
        item = InventoryItem(
            name=f"Test Product Res {unique_suffix}",
            type="product",
            unit="piece",
            quantity=50.0,
            cost_per_unit=10.0,
            organization_id=org.id
        )
        db_session.add(item)
>       db_session.commit()

tests/test_reservation_canonicalization.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f15a8d5e090>
cursor = <sqlite3.Cursor object at 0x7f15a2fae1c0>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Product Res 308172', None, None, 50.0, 'piece', 10.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a39c0850>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Test Product Res 308172', None, None, 50.0, 'piece', 10.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:48.182660', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
_ TestReservationCanonicalService.test_release_reservation_uses_canonical_service _

self = <sqlalchemy.engine.base.Connection object at 0x7f15a1789290>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f159f9a8ed0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a0372a90>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f15a0372a50>
parameters = [('Test Product Rel 312538', None, None, 50.0, 'piece', 10.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f159f9a8ed0>
cursor = <sqlite3.Cursor object at 0x7f15a0343040>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Product Rel 312538', None, None, 50.0, 'piece', 10.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a0372a90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_usage_rate

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_reservation_canonicalization.TestReservationCanonicalService object at 0x7f15ab6dc710>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f15ad5e6410>

    def test_release_reservation_uses_canonical_service(self, app, db_session):
        """Test that releasing reservations uses canonical inventory adjustment"""
    
        # Create test data
        from app.models import Organization, User, SubscriptionTier, InventoryItem, Reservation
    
        import time
        unique_suffix = str(int(time.time() * 1000))[-6:]
    
        tier = SubscriptionTier(name=f"Test Tier Rel {unique_suffix}", tier_type="monthly", user_limit=5)
        db_session.add(tier)
        db_session.flush()
    
        org = Organization(name=f"Test Org Rel {unique_suffix}", billing_status="active", subscription_tier_id=tier.id)
        db_session.add(org)
        db_session.flush()
    
        user = User(username=f"testuser_rel_{unique_suffix}", email=f"rel{unique_suffix}@example.com", organization_id=org.id)
        db_session.add(user)
        db_session.flush()
    
        item = InventoryItem(
            name=f"Test Product Rel {unique_suffix}",
            type="product",
            unit="piece",
            quantity=50.0,
            cost_per_unit=10.0,
            organization_id=org.id
        )
        db_session.add(item)
>       db_session.flush()

tests/test_reservation_canonicalization.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f159f9a8ed0>
cursor = <sqlite3.Cursor object at 0x7f15a0343040>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Test Product Rel 312538', None, None, 50.0, 'piece', 10.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f15a0372a90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_usage_rate
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_usage_rate, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Test Product Rel 312538', None, None, 50.0, 'piece', 10.0, 0.0, None, 'product', 1, 0, 0, None, None, None, None, None, None, None, None, None, '2025-11-12 21:51:52.550062', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 2)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ certifications column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
   ✅ is_active_ingredient column added successfully
   ✅ certifications column added successfully
   ✅ fatty_acid_profile column added successfully
   ✅ brewing_diastatic_power_lintner column added successfully
   ✅ brewing_potential_sg column added successfully
   ✅ brewing_color_srm column added successfully
   ✅ protein_content_pct column added successfully
   ✅ inci_name column added successfully
   ✅ recommended_fragrance_load_pct column added successfully
   ✅ recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
=============================== warnings summary ===============================
tests/developer/test_analytics_catalog.py: 1 warning
tests/test_auth_permissions.py: 3 warnings
tests/test_batch_label_generator.py: 2 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 1 warning
tests/test_extras_expiration.py: 1 warning
tests/test_global_link_drawer.py: 1 warning
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_costing_toggle.py: 2 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_plan_production_integration.py: 2 warnings
tests/test_portioning_sku_derivation.py: 1 warning
tests/test_pos_integration_canonicalization.py: 3 warnings
tests/test_public_tools_and_exports_smoke.py: 2 warnings
tests/test_reservation_canonicalization.py: 6 warnings
tests/test_retention_drawer.py: 1 warning
tests/test_signup_tiers.py: 5 warnings
tests/test_start_batch_integration.py: 1 warning
tests/test_stripe_webhooks.py: 3 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

tests/test_plan_production_integration.py::test_plan_start_finish_non_portioned
tests/test_plan_production_integration.py::test_plan_start_finish_portioned
  /home/runner/workspace/app/blueprints/batches/routes.py:282: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    recipe = Recipe.query.get(recipe_id)

tests/test_plan_production_integration.py::test_plan_start_finish_non_portioned
tests/test_plan_production_integration.py::test_plan_start_finish_portioned
tests/test_portioning_sku_derivation.py::test_portioning_sku_labels_differ
tests/test_start_batch_integration.py::test_start_batch_uses_generator_and_persists_label
  /home/runner/workspace/app/services/batch_service/batch_operations.py:38: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    recipe = Recipe.query.get(snap_recipe_id)

tests/test_plan_production_integration.py::test_plan_start_finish_non_portioned
tests/test_plan_production_integration.py::test_plan_start_finish_portioned
tests/test_portioning_sku_derivation.py::test_portioning_sku_labels_differ
tests/test_start_batch_integration.py::test_start_batch_uses_generator_and_persists_label
  /home/runner/workspace/app/services/batch_service/batch_operations.py:158: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    fresh_batch = Batch.query.get(batch.id)

tests/test_portioning_sku_derivation.py::test_portioning_sku_labels_differ
  /home/runner/workspace/app/services/recipe_service/_core.py:92: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    u = Unit.query.get(buid)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] - assert 200 == 302
FAILED tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_extras_expiration.py::test_extras_cannot_use_expired_lot - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_global_link_drawer.py::test_global_link_suggestions_and_link_flow - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table global_it...
FAILED tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_and_deduct_fifo_mode - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_average_mode - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_inventory_routes_canonicalization.py::test_batch_start_routes_all_deductions_through_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_inventory_routes_canonicalization.py::test_expiration_service_uses_canonical_adjustment - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_plan_production_integration.py::test_plan_start_finish_non_portioned - assert 302 == 200
FAILED tests/test_plan_production_integration.py::test_plan_start_finish_portioned - assert 302 == 200
FAILED tests/test_portioning_sku_derivation.py::test_portioning_sku_labels_differ - AssertionError: Complete batch failed: Error completing batch: This Session...
FAILED tests/test_pos_integration_canonicalization.py::test_reserve_inventory_calls_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_pos_integration_canonicalization.py::test_confirm_sale_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_pos_integration_canonicalization.py::test_confirm_return_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_create_reservation_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_reservation_canonicalization.py::TestReservationCanonicalService::test_release_reservation_uses_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
============ 20 failed, 45 passed, 65 warnings in 221.22s (0:03:41) ============
