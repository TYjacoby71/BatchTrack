Yeah—that app/__init__.py is doing way too much. You’ve got duplicate init paths, multiple context processors (some repeated), 3+ before_request blocks, and both HTML+JSON auth logic sprinkled around. Let’s slim it down by moving the logic into small helpers and making create_app() a clean orchestrator.

Below is a drop-in refactor that keeps all current behavior (including the JSON vs HTML auth responses) but shrinks __init__.py to ~80 lines.

What to change (surgical + reversible)
1) Add a tiny, shared JSON detector
app/utils/http.py

python
Copy
Edit
from flask import request

def wants_json() -> bool:
    if request.path.startswith("/api"):
        return True
    accept = request.accept_mimetypes
    return ("application/json" in accept) and (not accept.accept_html)
2) Centralize Flask-Login’s unauthorized handling
app/authz.py

python
Copy
Edit
from flask import jsonify, redirect, url_for
from .extensions import login_manager
from .utils.http import wants_json

def configure_login_manager(app):
    login_manager.init_app(app)
    login_manager.login_view = "auth.login"

    @login_manager.unauthorized_handler
    def _unauthorized():
        if wants_json():
            return jsonify({"error": "unauthorized"}), 401
        return redirect(url_for("auth.login"))
(Keep your existing @login_manager.user_loader where it already lives, or move it here if you prefer—just don’t duplicate it.)

3) Move middleware into one place
app/middleware.py

python
Copy
Edit
import os
from flask import request, redirect, url_for, jsonify, session, g, flash
from flask_login import current_user
from .extensions import login_manager
from .utils.http import wants_json

def register_middleware(app):
    @app.before_request
    def _global_login_gate():
        # Fast-path public endpoints
        public = {
            "static", "auth.login", "auth.logout", "auth.signup",
            "billing.webhooks", "homepage"
        }
        if request.endpoint and any([
            request.endpoint in public,
            request.path.startswith("/static/"),
            request.path.startswith("/billing/webhooks/"),
            request.path.startswith("/api/waitlist"),
            request.path in ("/", "/homepage"),
        ]):
            return

        # Test bypass for inventory adjust (matches your current behavior)
        if app.config.get("TESTING") and request.path.startswith("/inventory/adjust"):
            return

        # Require auth
        if not current_user.is_authenticated:
            if wants_json():
                return jsonify({"error": "unauthorized"}), 401
            return login_manager.unauthorized()

        # Developer masquerade (exact behavior preserved)
        if current_user.user_type == "developer":
            if request.path.startswith("/developer/") or request.path.startswith("/auth/"):
                return
            selected_org_id = session.get("dev_selected_org_id")
            if not selected_org_id:
                if wants_json():
                    return jsonify({"error": "Developer must select organization"}), 403
                flash("Please select an organization to access customer features", "warning")
                return redirect(url_for("developer.organizations"))

            from .models import Organization
            selected_org = Organization.query.get(selected_org_id)
            if not selected_org:
                session.pop("dev_selected_org_id", None)
                flash("Selected organization no longer exists", "error")
                return redirect(url_for("developer.organizations"))

            g.effective_org_id = selected_org_id
            g.effective_org = selected_org
            g.is_developer_masquerade = True

        elif not current_user.organization_id:
            if wants_json():
                return jsonify({"error": "No organization context"}), 403
            flash("No organization context available", "error")
            return redirect(url_for("auth.logout"))

    @app.before_request
    def _force_https_in_prod():
        if (
            os.environ.get("REPLIT_DEPLOYMENT") == "true"
            and not request.is_secure
            and request.headers.get("X-Forwarded-Proto") != "https"
            and request.url.startswith("http://")
        ):
            return redirect(request.url.replace("http://", "https://"), code=301)

    @app.after_request
    def _security_headers(resp):
        if os.environ.get("REPLIT_DEPLOYMENT") == "true":
            resp.headers.update({
                "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                "X-Content-Type-Options": "nosniff",
                "X-Frame-Options": "DENY",
                "X-XSS-Protection": "1; mode=block",
            })
        return resp
4) Put template context stuff in one module
app/template_context.py

python
Copy
Edit
from flask import current_app, session
from flask_login import current_user
from flask_wtf.csrf import generate_csrf
from .utils.timezone_utils import TimezoneUtils

def register_template_context(app):
    @app.context_processor
    def _inject_csrf():
        return dict(csrf_token=generate_csrf)

    @app.context_processor
    def _inject_units_and_categories():
        from .utils.unit_utils import get_global_unit_list
        from .models import IngredientCategory

        if not hasattr(current_app, "_cached_units"):
            try:
                current_app._cached_units = get_global_unit_list()
                current_app._cached_categories = IngredientCategory.query.order_by(IngredientCategory.name).all()
            except Exception:
                current_app._cached_units = []
                current_app._cached_categories = []

        return dict(
            units=current_app._cached_units,
            categories=current_app._cached_categories,
            global_units=current_app._cached_units,
        )

    @app.context_processor
    def _inject_permissions():
        # Keep your helpers; just expose them once
        from .utils.permissions import has_permission, has_role, is_organization_owner
        return dict(
            has_permission=has_permission,
            has_role=has_role,
            is_organization_owner=is_organization_owner,
            user_tier=lambda: (
                getattr(getattr(current_user, "organization", None), "subscription_tier", "free")
                if current_user.is_authenticated else "free"
            ),
        )

    @app.context_processor
    def _inject_org_helpers():
        from .models import Organization

        def get_organization_by_id(org_id):
            if not org_id:
                return None
            try:
                return app.extensions["sqlalchemy"].session.get(Organization, org_id)
            except Exception:
                return Organization.query.get(org_id)

        def get_current_organization():
            if not current_user.is_authenticated:
                return None
            org_id = session.get("dev_selected_org_id") if current_user.user_type == "developer" else current_user.organization_id
            return get_organization_by_id(org_id) if org_id else None

        return dict(
            get_organization_by_id=get_organization_by_id,
            get_current_organization=get_current_organization,
        )

    @app.context_processor
    def _inject_timezone_utils():
        return dict(
            TimezoneUtils=TimezoneUtils,
            TimezoneUtils_global=TimezoneUtils,
            current_time=TimezoneUtils.utc_now,
        )
5) Keep blueprint registration separate
app/blueprints_registry.py

python
Copy
Edit
import logging
logger = logging.getLogger(__name__)

def register_blueprints(app):
    # Public API that must be before auth
    try:
        from app.blueprints.api.public import public_api
        app.register_blueprint(public_api)
    except Exception as e:
        logger.warning(f"Public API registration failed: {e}")

    # Core
    _regs = [
        ("app.blueprints.auth.routes", "auth_bp", "/auth"),
        ("app.blueprints.recipes.routes", "recipes_bp", "/recipes"),
        ("app.blueprints.inventory.routes", "inventory_bp", "/inventory"),
        ("app.blueprints.batches.routes", "batches_bp", "/batches"),
        ("app.blueprints.batches.finish_batch", "finish_batch_bp", "/batches"),
        ("app.blueprints.batches.start_batch", "start_batch_bp", "/start-batch"),
        ("app.blueprints.conversion.routes", "conversion_bp", "/conversion"),
        ("app.blueprints.expiration.routes", "expiration_bp", "/expiration"),
        ("app.blueprints.settings.routes", "settings_bp", "/settings"),
        ("app.blueprints.organization.routes", "organization_bp", "/organization"),
        ("app.blueprints.timers.routes", "timers_bp", "/timers"),
        ("app.routes.app_routes", "app_routes_bp", None),
        ("app.blueprints.fifo", "fifo_bp", None),
        ("app.blueprints.api.routes", "api_bp", None),
        ("app.blueprints.developer.routes", "developer_bp", None),
        ("app.routes.waitlist_routes", "waitlist_bp", None),
        ("app.blueprints.admin.admin_routes", "admin_bp", None),
        ("app.routes.legal_routes", "legal_bp", None),
    ]

    for module_path, bp_name, prefix in _regs:
        try:
            module = __import__(module_path, fromlist=[bp_name])
            bp = getattr(module, bp_name)
            app.register_blueprint(bp, url_prefix=prefix) if prefix else app.register_blueprint(bp)
        except Exception as e:
            logger.warning(f"Failed to register {bp_name} from {module_path}: {e}")

    # Products family
    try:
        from .blueprints.products.products import products_bp
        from .blueprints.products.api import products_api_bp
        from .blueprints.products.product_inventory_routes import product_inventory_bp
        from .blueprints.products.product_variants import product_variants_bp
        from .blueprints.products.sku import sku_bp
        from .blueprints.products.reservation_routes import reservation_bp
        from .blueprints.api.reservation_routes import reservation_api_bp

        app.register_blueprint(products_bp, url_prefix="/products")
        app.register_blueprint(products_api_bp)
        app.register_blueprint(product_inventory_bp, url_prefix="/products")
        app.register_blueprint(product_variants_bp, url_prefix="/products")
        app.register_blueprint(sku_bp, url_prefix="/products")
        app.register_blueprint(reservation_bp, url_prefix="/reservations")
        app.register_blueprint(reservation_api_bp)
    except Exception as e:
        logger.warning(f"Product blueprints failed: {e}")

    # Billing
    try:
        from .blueprints.billing.routes import billing_bp
        app.register_blueprint(billing_bp)
    except Exception as e:
        logger.error(f"Billing blueprint failed: {e}")

    # CSRF exemptions that you currently rely on
    try:
        from .extensions import csrf
        csrf.exempt(app.view_functions["inventory.adjust_inventory"])
        if "waitlist.join_waitlist" in app.view_functions:
            csrf.exempt(app.view_functions["waitlist.join_waitlist"])
    except Exception:
        pass
6) Minimal create_app() that just orchestrates
app/init.py (replace with this)

python
Copy
Edit
import os
import logging
from flask import Flask, redirect, url_for, render_template
from flask_login import current_user
from .extensions import db, migrate, csrf, limiter
from .extensions import login_manager  # for type/context
from .authz import configure_login_manager
from .middleware import register_middleware
from .template_context import register_template_context
from .blueprints_registry import register_blueprints
from .utils.timezone_utils import TimezoneUtils
from .utils.template_filters import register_template_filters

logger = logging.getLogger(__name__)

def create_app(config=None):
    app = Flask(__name__, static_folder="static", static_url_path="/static")
    app.config.from_object("app.config.Config")
    if config:
        app.config.update(config)

    # Testing tweaks
    if app.config.get("TESTING"):
        app.config["LOGIN_DISABLED"] = True
        app.config.setdefault("WTF_CSRF_ENABLED", False)

    # SQLite engine options for tests / memory dbs (kept from your file)
    _tweak_sqlite_engine_options(app)

    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    csrf.init_app(app)
    limiter.init_app(app)
    configure_login_manager(app)  # sets JSON-aware unauthorized handler

    # Register app-level pieces
    register_middleware(app)
    register_blueprints(app)
    register_template_context(app)
    register_template_filters(app)

    _add_core_routes(app)
    _setup_logging(app)
    return app

def _tweak_sqlite_engine_options(app):
    from sqlalchemy.pool import StaticPool
    uri = app.config.get("SQLALCHEMY_DATABASE_URI", "")
    if app.config.get("TESTING") or uri.startswith("sqlite"):
        opts = dict(app.config.get("SQLALCHEMY_ENGINE_OPTIONS", {}))
        opts.pop("pool_size", None)
        opts.pop("max_overflow", None)
        if uri == "sqlite:///:memory:":
            opts["poolclass"] = StaticPool
            opts["connect_args"] = {"check_same_thread": False}
        app.config["SQLALCHEMY_ENGINE_OPTIONS"] = opts

def _add_core_routes(app):
    @app.route("/")
    def index():
        if current_user.is_authenticated:
            return (redirect(url_for("developer.dashboard"))
                    if current_user.user_type == "developer"
                    else redirect(url_for("app_routes.dashboard")))
        return redirect(url_for("homepage"))

    @app.route("/homepage")
    def homepage():
        return render_template("homepage.html")

def _setup_logging(app):
    from .utils.unit_utils import setup_logging
    setup_logging(app)
    if not app.debug:
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]",
        )
Why this helps immediately
Fixes your API 302→401 problem consistently: JSON behavior lives in one place (authz.configure_login_manager + middleware uses that).

Removes duplication: no more double CSRF/context processors, no second _init_extensions, no repeated permission injections.

Keeps shims working: nothing here changes your service calls or test contracts.

Easy to revert: we only moved code; behavior’s the same.

What to delete from the current __init__.py
The entire _init_extensions function (it’s redundant—extensions are init’d directly).

Duplicate CSRF/template context processors (you had multiple inject_permissions blocks).

The extra unauthorized_handler copy.

The large block of blueprint imports/registrations (now in blueprints_registry.py).

The before/after request blocks (now in middleware.py).

If you want, I can trim only the 2–3 most duplicated bits right now (the unauthorized handler & duplicated context processors) and leave the rest in place. But the modular split above is the cleanest and will stop this file from growing again.