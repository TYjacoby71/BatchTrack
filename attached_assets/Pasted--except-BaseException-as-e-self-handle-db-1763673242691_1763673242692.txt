                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd81f364d0>
cursor = <sqlite3.Cursor object at 0x7fbd82eab640>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd81f60f10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1019: in visit_table
    )._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd81f364d0>
cursor = <sqlite3.Cursor object at 0x7fbd82eab640>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd81f60f10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: 
E       CREATE TABLE batch (
E           id INTEGER NOT NULL, 
E           recipe_id INTEGER NOT NULL, 
E           label_code VARCHAR(32), 
E           batch_type VARCHAR(32) NOT NULL, 
E           projected_yield FLOAT, 
E           projected_yield_unit VARCHAR(50), 
E           sku_id INTEGER, 
E           final_quantity FLOAT, 
E           output_unit VARCHAR(50), 
E           scale FLOAT, 
E           status VARCHAR(50), 
E           status_reason TEXT, 
E           notes TEXT, 
E           tags TEXT, 
E           total_cost FLOAT, 
E           created_by INTEGER, 
E           organization_id INTEGER, 
E           started_at DATETIME, 
E           completed_at DATETIME, 
E           failed_at DATETIME, 
E           cancelled_at DATETIME, 
E           inventory_credited BOOLEAN, 
E           is_perishable BOOLEAN, 
E           shelf_life_days INTEGER, 
E           expiration_date DATETIME, 
E           remaining_quantity FLOAT, 
E           portioning_data JSON, 
E           is_portioned BOOLEAN, 
E           portion_name VARCHAR(64), 
E           projected_portions INTEGER, 
E           final_portions INTEGER, 
E           plan_snapshot JSON, 
E           portion_unit_id INTEGER, 
E           cost_method VARCHAR(16), 
E           cost_method_locked_at DATETIME, 
E           vessel_fill_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'vessel_fill_pct'))::numeric) STORED, 
E           candle_fragrance_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_fragrance_pct'))::numeric) STORED, 
E           candle_vessel_ml NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_vessel_ml'))::numeric) STORED, 
E           soap_superfat NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_superfat'))::numeric) STORED, 
E           soap_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_water_pct'))::numeric) STORED, 
E           soap_lye_type TEXT GENERATED ALWAYS AS (((plan_snapshot -> 'category_extension') ->> 'soap_lye_type')) STORED, 
E           baker_base_flour_g NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_base_flour_g'))::numeric) STORED, 
E           baker_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_water_pct'))::numeric) STORED, 
E           baker_salt_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_salt_pct'))::numeric) STORED, 
E           baker_yeast_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_yeast_pct'))::numeric) STORED, 
E           cosm_emulsifier_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_emulsifier_pct'))::numeric) STORED, 
E           cosm_preservative_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_preservative_pct'))::numeric) STORED, 
E           PRIMARY KEY (id), 
E           FOREIGN KEY(recipe_id) REFERENCES recipe (id), 
E           UNIQUE (label_code), 
E           FOREIGN KEY(sku_id) REFERENCES product_sku (id), 
E           FOREIGN KEY(created_by) REFERENCES user (id), 
E           FOREIGN KEY(organization_id) REFERENCES organization (id), 
E           FOREIGN KEY(portion_unit_id) REFERENCES unit (id)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
________________ ERROR at setup of test_signup_flow_end_to_end _________________

self = <sqlalchemy.engine.base.Connection object at 0x7fbd828f4d10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd83cdf2d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82b1d110>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fbd82a75450>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd83cdf2d0>
cursor = <sqlite3.Cursor object at 0x7fbd81e7dec0>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82b1d110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1019: in visit_table
    )._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd83cdf2d0>
cursor = <sqlite3.Cursor object at 0x7fbd81e7dec0>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82b1d110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: 
E       CREATE TABLE batch (
E           id INTEGER NOT NULL, 
E           recipe_id INTEGER NOT NULL, 
E           label_code VARCHAR(32), 
E           batch_type VARCHAR(32) NOT NULL, 
E           projected_yield FLOAT, 
E           projected_yield_unit VARCHAR(50), 
E           sku_id INTEGER, 
E           final_quantity FLOAT, 
E           output_unit VARCHAR(50), 
E           scale FLOAT, 
E           status VARCHAR(50), 
E           status_reason TEXT, 
E           notes TEXT, 
E           tags TEXT, 
E           total_cost FLOAT, 
E           created_by INTEGER, 
E           organization_id INTEGER, 
E           started_at DATETIME, 
E           completed_at DATETIME, 
E           failed_at DATETIME, 
E           cancelled_at DATETIME, 
E           inventory_credited BOOLEAN, 
E           is_perishable BOOLEAN, 
E           shelf_life_days INTEGER, 
E           expiration_date DATETIME, 
E           remaining_quantity FLOAT, 
E           portioning_data JSON, 
E           is_portioned BOOLEAN, 
E           portion_name VARCHAR(64), 
E           projected_portions INTEGER, 
E           final_portions INTEGER, 
E           plan_snapshot JSON, 
E           portion_unit_id INTEGER, 
E           cost_method VARCHAR(16), 
E           cost_method_locked_at DATETIME, 
E           vessel_fill_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'vessel_fill_pct'))::numeric) STORED, 
E           candle_fragrance_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_fragrance_pct'))::numeric) STORED, 
E           candle_vessel_ml NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_vessel_ml'))::numeric) STORED, 
E           soap_superfat NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_superfat'))::numeric) STORED, 
E           soap_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_water_pct'))::numeric) STORED, 
E           soap_lye_type TEXT GENERATED ALWAYS AS (((plan_snapshot -> 'category_extension') ->> 'soap_lye_type')) STORED, 
E           baker_base_flour_g NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_base_flour_g'))::numeric) STORED, 
E           baker_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_water_pct'))::numeric) STORED, 
E           baker_salt_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_salt_pct'))::numeric) STORED, 
E           baker_yeast_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_yeast_pct'))::numeric) STORED, 
E           cosm_emulsifier_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_emulsifier_pct'))::numeric) STORED, 
E           cosm_preservative_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_preservative_pct'))::numeric) STORED, 
E           PRIMARY KEY (id), 
E           FOREIGN KEY(recipe_id) REFERENCES recipe (id), 
E           UNIQUE (label_code), 
E           FOREIGN KEY(sku_id) REFERENCES product_sku (id), 
E           FOREIGN KEY(created_by) REFERENCES user (id), 
E           FOREIGN KEY(organization_id) REFERENCES organization (id), 
E           FOREIGN KEY(portion_unit_id) REFERENCES unit (id)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
_______ ERROR at setup of test_stripe_webhook_valid_signature_dispatches _______

self = <sqlalchemy.engine.base.Connection object at 0x7fbd82b3c2d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd82a5b790>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82492f50>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fbd82492f90>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd82a5b790>
cursor = <sqlite3.Cursor object at 0x7fbd82443a40>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82492f50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1019: in visit_table
    )._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd82a5b790>
cursor = <sqlite3.Cursor object at 0x7fbd82443a40>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82492f50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: 
E       CREATE TABLE batch (
E           id INTEGER NOT NULL, 
E           recipe_id INTEGER NOT NULL, 
E           label_code VARCHAR(32), 
E           batch_type VARCHAR(32) NOT NULL, 
E           projected_yield FLOAT, 
E           projected_yield_unit VARCHAR(50), 
E           sku_id INTEGER, 
E           final_quantity FLOAT, 
E           output_unit VARCHAR(50), 
E           scale FLOAT, 
E           status VARCHAR(50), 
E           status_reason TEXT, 
E           notes TEXT, 
E           tags TEXT, 
E           total_cost FLOAT, 
E           created_by INTEGER, 
E           organization_id INTEGER, 
E           started_at DATETIME, 
E           completed_at DATETIME, 
E           failed_at DATETIME, 
E           cancelled_at DATETIME, 
E           inventory_credited BOOLEAN, 
E           is_perishable BOOLEAN, 
E           shelf_life_days INTEGER, 
E           expiration_date DATETIME, 
E           remaining_quantity FLOAT, 
E           portioning_data JSON, 
E           is_portioned BOOLEAN, 
E           portion_name VARCHAR(64), 
E           projected_portions INTEGER, 
E           final_portions INTEGER, 
E           plan_snapshot JSON, 
E           portion_unit_id INTEGER, 
E           cost_method VARCHAR(16), 
E           cost_method_locked_at DATETIME, 
E           vessel_fill_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'vessel_fill_pct'))::numeric) STORED, 
E           candle_fragrance_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_fragrance_pct'))::numeric) STORED, 
E           candle_vessel_ml NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_vessel_ml'))::numeric) STORED, 
E           soap_superfat NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_superfat'))::numeric) STORED, 
E           soap_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_water_pct'))::numeric) STORED, 
E           soap_lye_type TEXT GENERATED ALWAYS AS (((plan_snapshot -> 'category_extension') ->> 'soap_lye_type')) STORED, 
E           baker_base_flour_g NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_base_flour_g'))::numeric) STORED, 
E           baker_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_water_pct'))::numeric) STORED, 
E           baker_salt_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_salt_pct'))::numeric) STORED, 
E           baker_yeast_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_yeast_pct'))::numeric) STORED, 
E           cosm_emulsifier_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_emulsifier_pct'))::numeric) STORED, 
E           cosm_preservative_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_preservative_pct'))::numeric) STORED, 
E           PRIMARY KEY (id), 
E           FOREIGN KEY(recipe_id) REFERENCES recipe (id), 
E           UNIQUE (label_code), 
E           FOREIGN KEY(sku_id) REFERENCES product_sku (id), 
E           FOREIGN KEY(created_by) REFERENCES user (id), 
E           FOREIGN KEY(organization_id) REFERENCES organization (id), 
E           FOREIGN KEY(portion_unit_id) REFERENCES unit (id)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
___ ERROR at setup of test_stripe_webhook_returns_400_when_signature_invalid ___

self = <sqlalchemy.engine.base.Connection object at 0x7fbd822b09d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd81f34e90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82897f50>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fbd82894610>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd81f34e90>
cursor = <sqlite3.Cursor object at 0x7fbd829887c0>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82897f50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1019: in visit_table
    )._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd81f34e90>
cursor = <sqlite3.Cursor object at 0x7fbd829887c0>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82897f50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: 
E       CREATE TABLE batch (
E           id INTEGER NOT NULL, 
E           recipe_id INTEGER NOT NULL, 
E           label_code VARCHAR(32), 
E           batch_type VARCHAR(32) NOT NULL, 
E           projected_yield FLOAT, 
E           projected_yield_unit VARCHAR(50), 
E           sku_id INTEGER, 
E           final_quantity FLOAT, 
E           output_unit VARCHAR(50), 
E           scale FLOAT, 
E           status VARCHAR(50), 
E           status_reason TEXT, 
E           notes TEXT, 
E           tags TEXT, 
E           total_cost FLOAT, 
E           created_by INTEGER, 
E           organization_id INTEGER, 
E           started_at DATETIME, 
E           completed_at DATETIME, 
E           failed_at DATETIME, 
E           cancelled_at DATETIME, 
E           inventory_credited BOOLEAN, 
E           is_perishable BOOLEAN, 
E           shelf_life_days INTEGER, 
E           expiration_date DATETIME, 
E           remaining_quantity FLOAT, 
E           portioning_data JSON, 
E           is_portioned BOOLEAN, 
E           portion_name VARCHAR(64), 
E           projected_portions INTEGER, 
E           final_portions INTEGER, 
E           plan_snapshot JSON, 
E           portion_unit_id INTEGER, 
E           cost_method VARCHAR(16), 
E           cost_method_locked_at DATETIME, 
E           vessel_fill_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'vessel_fill_pct'))::numeric) STORED, 
E           candle_fragrance_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_fragrance_pct'))::numeric) STORED, 
E           candle_vessel_ml NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_vessel_ml'))::numeric) STORED, 
E           soap_superfat NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_superfat'))::numeric) STORED, 
E           soap_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_water_pct'))::numeric) STORED, 
E           soap_lye_type TEXT GENERATED ALWAYS AS (((plan_snapshot -> 'category_extension') ->> 'soap_lye_type')) STORED, 
E           baker_base_flour_g NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_base_flour_g'))::numeric) STORED, 
E           baker_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_water_pct'))::numeric) STORED, 
E           baker_salt_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_salt_pct'))::numeric) STORED, 
E           baker_yeast_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_yeast_pct'))::numeric) STORED, 
E           cosm_emulsifier_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_emulsifier_pct'))::numeric) STORED, 
E           cosm_preservative_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_preservative_pct'))::numeric) STORED, 
E           PRIMARY KEY (id), 
E           FOREIGN KEY(recipe_id) REFERENCES recipe (id), 
E           UNIQUE (label_code), 
E           FOREIGN KEY(sku_id) REFERENCES product_sku (id), 
E           FOREIGN KEY(created_by) REFERENCES user (id), 
E           FOREIGN KEY(organization_id) REFERENCES organization (id), 
E           FOREIGN KEY(portion_unit_id) REFERENCES unit (id)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
____ ERROR at setup of test_stripe_webhook_returns_500_when_secret_missing _____

self = <sqlalchemy.engine.base.Connection object at 0x7fbd829e5710>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd821e0090>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82a57ad0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x7fbd82a56950>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd821e0090>
cursor = <sqlite3.Cursor object at 0x7fbd826ca640>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82a57ad0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: unrecognized token: ":"

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='function')  # Changed to function scope for isolation
    def app():
        """Create and configure a new app instance for each test."""
        # Create a temporary file to use as the database
        db_fd, db_path = tempfile.mkstemp()
    
        app = create_app({
            'TESTING': True,
            'DATABASE_URL': f'sqlite:///{db_path}',
            'WTF_CSRF_ENABLED': False,
            'SECRET_KEY': 'test-secret-key',
            'STRIPE_SECRET_KEY': 'sk_test_fake',
            'STRIPE_WEBHOOK_SECRET': 'whsec_test_fake',
            'LOGIN_DISABLED': False,  # Ensure authentication is active in tests
            'TESTING_DISABLE_AUTH': False  # Disable any test-specific auth bypass
            # Don't disable login - we need to test permissions properly
        })
    
        try:
            with app.app_context():
                db.drop_all()
>               db.create_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5925: in create_all
    bind._run_ddl_visitor(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:981: in visit_metadata
    self.traverse_single(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:1019: in visit_table
    )._invoke_with(self.connection)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fbd821e0090>
cursor = <sqlite3.Cursor object at 0x7fbd826ca640>
statement = '\nCREATE TABLE batch (\n\tid INTEGER NOT NULL, \n\trecipe_id INTEGER NOT NULL, \n\tlabel_code VARCHAR(32), \n\tbatch_...OREIGN KEY(organization_id) REFERENCES organization (id), \n\tFOREIGN KEY(portion_unit_id) REFERENCES unit (id)\n)\n\n'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fbd82a57ad0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized token: ":"
E       [SQL: 
E       CREATE TABLE batch (
E           id INTEGER NOT NULL, 
E           recipe_id INTEGER NOT NULL, 
E           label_code VARCHAR(32), 
E           batch_type VARCHAR(32) NOT NULL, 
E           projected_yield FLOAT, 
E           projected_yield_unit VARCHAR(50), 
E           sku_id INTEGER, 
E           final_quantity FLOAT, 
E           output_unit VARCHAR(50), 
E           scale FLOAT, 
E           status VARCHAR(50), 
E           status_reason TEXT, 
E           notes TEXT, 
E           tags TEXT, 
E           total_cost FLOAT, 
E           created_by INTEGER, 
E           organization_id INTEGER, 
E           started_at DATETIME, 
E           completed_at DATETIME, 
E           failed_at DATETIME, 
E           cancelled_at DATETIME, 
E           inventory_credited BOOLEAN, 
E           is_perishable BOOLEAN, 
E           shelf_life_days INTEGER, 
E           expiration_date DATETIME, 
E           remaining_quantity FLOAT, 
E           portioning_data JSON, 
E           is_portioned BOOLEAN, 
E           portion_name VARCHAR(64), 
E           projected_portions INTEGER, 
E           final_portions INTEGER, 
E           plan_snapshot JSON, 
E           portion_unit_id INTEGER, 
E           cost_method VARCHAR(16), 
E           cost_method_locked_at DATETIME, 
E           vessel_fill_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'vessel_fill_pct'))::numeric) STORED, 
E           candle_fragrance_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_fragrance_pct'))::numeric) STORED, 
E           candle_vessel_ml NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'candle_vessel_ml'))::numeric) STORED, 
E           soap_superfat NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_superfat'))::numeric) STORED, 
E           soap_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'soap_water_pct'))::numeric) STORED, 
E           soap_lye_type TEXT GENERATED ALWAYS AS (((plan_snapshot -> 'category_extension') ->> 'soap_lye_type')) STORED, 
E           baker_base_flour_g NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_base_flour_g'))::numeric) STORED, 
E           baker_water_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_water_pct'))::numeric) STORED, 
E           baker_salt_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_salt_pct'))::numeric) STORED, 
E           baker_yeast_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'baker_yeast_pct'))::numeric) STORED, 
E           cosm_emulsifier_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_emulsifier_pct'))::numeric) STORED, 
E           cosm_preservative_pct NUMERIC GENERATED ALWAYS AS ((((plan_snapshot -> 'category_extension') ->> 'cosm_preservative_pct'))::numeric) STORED, 
E           PRIMARY KEY (id), 
E           FOREIGN KEY(recipe_id) REFERENCES recipe (id), 
E           UNIQUE (label_code), 
E           FOREIGN KEY(sku_id) REFERENCES product_sku (id), 
E           FOREIGN KEY(created_by) REFERENCES user (id), 
E           FOREIGN KEY(organization_id) REFERENCES organization (id), 
E           FOREIGN KEY(portion_unit_id) REFERENCES unit (id)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
=========================== short test summary info ============================
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[active-200] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_developer_can_masquerade_regardless_of_billing - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_complete_security_cascade - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_create_checkout_session_preserves_urls - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_signup_stripe_flow.py::test_signup_flow_end_to_end - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_stripe_webhooks.py::test_stripe_webhook_valid_signature_dispatches - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_stripe_webhooks.py::test_stripe_webhook_returns_400_when_signature_invalid - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
ERROR tests/test_stripe_webhooks.py::test_stripe_webhook_returns_500_when_secret_missing - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) unrecognized to...
============================= 12 errors in 16.10s ==============================
