This is a fantastic step forward. Your previous FAILURES have turned into ERRORS, which is a very specific and important distinction in testing.
A FAILURE means your test ran, but an assertion (a self.assertEqual, mock.assert_called_once, etc.) failed. The logic was wrong.
An ERROR means your test couldn't even finish running because the application itself crashed during setup.
You are now seeing a classic circular dependency and import error, which often gets uncovered during refactoring. The application can't even start up properly for the tests to run.
The Root Cause: A Circular Import in permissions.py
Let's look at the captured log output, which is the key to this entire puzzle:
code
Code
WARNING app:__init__.py:335 Failed to import inventory_bp from blueprints.inventory.routes: cannot import name 'permission_required' from 'app.utils.permissions' (/home/runner/workspace/app/utils/permissions.py)
This log is repeated for batches_bp, finish_batch_bp, and others. Hereâ€™s what it means, step-by-step:
Your test starts the app by calling create_app() in app/__init__.py.
create_app() tries to register all the blueprints by calling _register_blueprints().
_register_blueprints() tries to dynamically import all the blueprint files, including app/blueprints/inventory/routes.py.
The Crash: When Python tries to import app/blueprints/inventory/routes.py, that file itself has an import statement at the top: from app.utils.permissions import permission_required.
When Python tries to import app/utils/permissions.py, that file itself is likely trying to import something from a model or a blueprint (perhaps User or current_user) which hasn't been loaded yet. This creates a circle where A imports B, and B imports A. Python cannot resolve this and raises an ImportError.
Because the import of app/blueprints/inventory/routes.py failed, the inventory_bp object was never created and never added to the blueprints dictionary.
The code then proceeds to the core_registrations list and tries to access blueprints['inventory_bp'], which doesn't exist. This results in the final KeyError: 'inventory_bp'.
The KeyError is just the final symptom. The real disease is the import error logged in the warnings.
The Solution: Break the Circular Dependency
The permission_required decorator is the problem. A utility like permissions should be self-contained and not depend on the higher-level application context like blueprints or specific models during the initial import phase.
The most common fix for this pattern is to make the import local to the function where it's needed, rather than at the top of the file (a global import).
Your Action Plan:
Open the problematic file: app/utils/permissions.py.
Examine the imports: Look at the imports at the top of this file. You will likely see something like from app.models.user import User or from flask_login import current_user or even an import from another blueprint. These are what cause the circular dependency.
Move the imports: Take any imports that are causing this issue and move them inside the permission_required function (or any other functions that need them).
Example of the Fix:
Let's assume your app/utils/permissions.py looks something like this:
code
Python
# app/utils/permissions.py (BEFORE - THIS IS THE BROKEN CODE)

from functools import wraps
from flask import abort
from flask_login import current_user # <- This import might be the problem

def permission_required(permission_name):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.can(permission_name):
                abort(403)
            return f(*args, **kwargs)
        return decorated_function
    return decorator
You would change it to this:
code
Python
# app/utils/permissions.py (AFTER - THIS IS THE FIXED CODE)

from functools import wraps
from flask import abort
# We removed `from flask_login import current_user` from the top of the file

def permission_required(permission_name):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # We import `current_user` HERE, when the function is actually called.
            # By this time, the whole app has been initialized.
            from flask_login import current_user

            if not current_user.can(permission_name):
                abort(403)
            return f(*args, **kwargs)
        return decorated_function
    return decorator
By moving the import inside the decorated function, you ensure it only runs when a request is actually being handled. At that point, the entire application, including Flask-Login and all its components, has been safely initialized, and the circular dependency is avoided.
Apply this change, and your application should start up correctly, allowing your tests to run and (most likely) fail with the AssertionErrors from before, putting you right back on track to fix the route logic.