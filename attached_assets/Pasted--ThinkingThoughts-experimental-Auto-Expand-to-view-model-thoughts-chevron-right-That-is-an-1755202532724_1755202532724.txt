
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
That is an excellent and crucial question. It gets to the heart of whether our testing strategy is complete.
The answer is: No, the current test_auth_permissions.py file does not cover this full cascade. And this is by design.
Let me explain the separation, what's missing, and how we'll fix it with new, dedicated tests.
The "Why": Separation of Concerns in Testing
Think of your security model as having two distinct layers:
The Permission System Layer: This layer answers the question, "Given a user and a permission, does their role and tier combination theoretically allow this action?" This is what your user.has_permission() method does, and it's what test_auth_permissions.py is correctly designed to test. It tests the mechanics of the permission logic in isolation.
The Middleware Enforcement Layer: This layer sits in front of the permission system. It answers the question, "Is this user's organization in a valid state to even attempt an action?" This is what your enforce_billing_access and _global_access_control functions in app/middleware.py are responsible for. It checks for a valid billing status before anything else happens.
The current tests are very good at verifying Layer 1. They are not designed to verify Layer 2. We need to add tests for that layer to have complete confidence.
What's Missing and How We'll Add It
Here are the two critical test cases that are missing, which directly correspond to the two parts of your question. We will create a new test file, tests/test_billing_and_tier_enforcement.py, to house them.
1. Test: Organization Submits to Subscription Tier
This test will prove that an organization's tier acts as a hard ceiling on permissions, regardless of what a user's role might say.
Instructions:
"Create a new test file: tests/test_billing_and_tier_enforcement.py. Add the following test case. This test will create a 'Hobbyist' tier that does NOT have the product:create permission. It will then assign a user a role that does have that permission. The test will succeed if the user is still blocked from creating a product, because the organization's tier overrides the user's role."
Code for the new test file:
code
Python
# tests/test_billing_and_tier_enforcement.py

import pytest
from app.models import db, User, Organization, SubscriptionTier, Role, Permission
from app.models.permissions import AppPermission

def test_tier_permission_is_the_hard_ceiling(app):
    """
    Tests that a user is BLOCKED from an action if their org's tier
    does not allow it, even if their role DOES have the permission.
    """
    with app.app_context():
        # ARRANGE: Create a complex state
        
        # 1. Create permissions
        perm_view = Permission(name=AppPermission.PRODUCT_VIEW.value)
        perm_create = Permission(name=AppPermission.PRODUCT_CREATE.value)
        db.session.add_all([perm_view, perm_create])

        # 2. Create a "Hobbyist" tier that can ONLY view products
        hobbyist_tier = SubscriptionTier(name='hobbyist', permissions=[perm_view])
        db.session.add(hobbyist_tier)

        # 3. Create an Organization subscribed to the Hobbyist tier
        org = Organization(name='Test Hobby Org', subscription_tier=hobbyist_tier, billing_status='active')
        db.session.add(org)

        # 4. Create a Role that has MORE permissions than the tier allows
        overpowered_role = Role(name='Manager', organization=org, permissions=[perm_view, perm_create])
        db.session.add(overpowered_role)

        # 5. Create a User with that powerful role
        user = User(email='test@hobby.org', organization=org, roles=[overpowered_role])
        db.session.add(user)
        db.session.commit()

        # ACT & ASSERT
        
        # This should succeed because the Hobbyist tier allows 'product:view'
        assert user.has_permission(AppPermission.PRODUCT_VIEW) is True

        # This MUST FAIL. The tier is the ceiling. This is the critical test.
        assert user.has_permission(AppPermission.PRODUCT_CREATE) is False
2. Test: Tier Submits to Good Billing Return
This test will prove that the enforce_billing_access middleware correctly blocks access for users in organizations with a bad billing status.
Instructions:
"In the same test file, tests/test_billing_and_tier_enforcement.py, add the following test case. This test will check that a user with a perfectly active account can access a protected page. Then, it will change the organization's billing_status to 'past_due' and assert that the user is now redirected to the billing page."
Code to add to the test file:
code
Python
# tests/test_billing_and_tier_enforcement.py (continued)

from flask_login import login_user

@pytest.mark.parametrize("billing_status, expected_status_code", [
    ('active', 200),
    ('past_due', 302),
    ('suspended', 302),
    ('canceled', 302),
])
def test_billing_status_enforcement(app, client, test_user, billing_status, expected_status_code):
    """
    Tests that the billing middleware blocks access for non-active billing statuses.
    """
    with app.app_context():
        # ARRANGE
        # Update the user's organization with the test billing status
        org = test_user.organization
        org.billing_status = billing_status
        db.session.add(org)
        db.session.commit()

        # Create a simple protected route to test against
        @app.route('/_protected_dashboard')
        def _protected_dashboard():
            return "Welcome to the dashboard", 200

        # ACT
        # Log the user in and try to access the protected route
        with client.session_transaction() as sess:
            # We need to manually log the user in for the client
            # This is how you simulate a logged-in session for testing requests
            sess['user_id'] = test_user.id
            sess['_fresh'] = True

        response = client.get('/_protected_dashboard')

        # ASSERT
        assert response.status_code == expected_status_code

        # If redirected, ensure it's to the correct billing page
        if expected_status_code == 302:
            assert '/billing/upgrade' in response.location
By adding these two tests, you will have a rock-solid, verifiable guarantee that your entire security and billing cascade works exactly as you've designed it, from the top (billing status) all the way down to the individual permission check.