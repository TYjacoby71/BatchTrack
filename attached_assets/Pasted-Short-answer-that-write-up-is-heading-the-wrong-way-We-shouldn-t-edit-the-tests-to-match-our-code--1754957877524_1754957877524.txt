Short answer: that write-up is heading the wrong way. We shouldn’t edit the tests to match our code; these are characterization tests. Our job is to add lightweight shims so the current app presents the legacy surface the tests expect. A couple specifics in that note are also factually off.

Here’s what’s actually misaligned and how to fix it—without hard-coding tiers or changing test files:

1) User.is_verified
What tests do: construct User(..., is_verified=True).

Your model right now: doesn’t expose is_verified (error proves it).

Fix (pick one):

Real column (fastest):

python
Copy
Edit
# app/models/models.py
is_verified = db.Column(db.Boolean, nullable=False, default=False)
Or alias to a timestamp (no schema change):

python
Copy
Edit
from datetime import datetime
from sqlalchemy.ext.hybrid import hybrid_property

@hybrid_property
def is_verified(self):
    return self.email_verified_at is not None

@is_verified.setter
def is_verified(self, value: bool):
    self.email_verified_at = datetime.utcnow() if value else None
2) SubscriptionTier + Stripe (no hard-coded tiers)
What tests do: construct SubscriptionTier with stripe_price_id_monthly (and possibly stripe_price_id_yearly) and check signup paths.

Your direction: you want lookup keys (good) not price IDs.

Shim that keeps your design:

Keep your canonical fields (e.g., stripe_lookup_key_monthly, stripe_lookup_key_yearly).

Add compat properties that the tests can set/read:

python
Copy
Edit
# app/models/subscription_tier.py
from sqlalchemy.ext.hybrid import hybrid_property

# canonical fields you already use
stripe_lookup_key_monthly = db.Column(db.String, nullable=True)
stripe_lookup_key_yearly  = db.Column(db.String, nullable=True)

# compat: tests set/read "price_id_*" but we store lookup keys
@hybrid_property
def stripe_price_id_monthly(self):
    return self.stripe_lookup_key_monthly

@stripe_price_id_monthly.setter
def stripe_price_id_monthly(self, v):
    self.stripe_lookup_key_monthly = v

@hybrid_property
def stripe_price_id_yearly(self):
    return self.stripe_lookup_key_yearly

@stripe_price_id_yearly.setter
def stripe_price_id_yearly(self, v):
    self.stripe_lookup_key_yearly = v
That satisfies the tests’ terminology while keeping runtime code using lookup keys under the hood. No hard-coded tiers required.

3) Exports / imports
The draft says tests import models from the “wrong modules.” We shouldn’t change tests. Ensure app/models/__init__.py exports the public names the tests import (e.g., User, Organization, SubscriptionTier, Product, ProductSKU, Reservation, ProductSKUHistory). This we already started and it’s the right move.

Quick validation checklist (order matters)
Add User.is_verified shim (column or hybrid).

Add SubscriptionTier.stripe_price_id_monthly/yearly hybrid props mapped to your lookup keys.

Confirm app/models/__init__.py exports everything tests import.

Run: pytest -q and see the next failure. We’ll rinse-and-repeat tiny shims if another legacy kwarg pops up.

This keeps us on the roadmap: we’re not rewriting tests or hard-coding subscription tiers; we’re just exposing the legacy surface the tests expect while preserving your modern internals (lookup keys, services, etc.).