Thought for 35s
nice grep — this is exactly what we needed. You’re very close to a clean single-entry FIFO world. What the output shows:

What’s already good
Most routes call app.services.inventory_adjustment.process_inventory_adjustment(...) ✅

blueprints/fifo/services.py is marked INTERNAL/DEPRECATED with shims pointing to the canonical service ✅

Read-only usage of FIFO (e.g., get_fifo_entries) appears in a few places — that’s fine ✅

Remaining leaks (writes that bypass the canonical path)
These are the ones to fix in PR2:

Expiration service (mutating FIFO directly)

app/blueprints/expiration/services.py: sets fifo_entry.remaining_quantity = 0.0 and writes history itself.

Fix: route all “mark expired/disposal/spoil” changes through
process_inventory_adjustment(item_id, quantity=-abs(qty), change_type='spoil'|'trash', ...)
(one call per lot if you need to preserve lot linkage/notes).

Inventory routes (direct FIFO edits)

app/blueprints/inventory/routes.py around the lines your grep showed (querying InventoryHistory then decrementing remaining_quantity).

Fix: move those mutations into inventory_adjustment and call the service from the route.

Recount/Cost-override flows should become service calls (change_type='recount' etc.), with any cost propagation handled in the service.

POS integration (adding FIFO entries directly)

app/services/pos_integration.py: multiple FIFOService.add_fifo_entry(...) calls.

Fix: replace with process_inventory_adjustment(...) for adds/credits, so all history + lot coding stays consistent.

Allowlist vs blocklist

Allowed outside the canonical service: read-only calls like FIFOService.get_fifo_entries, get_all_fifo_entries.

Disallowed outside the canonical service (move behind inventory_adjustment):
execute_deduction_plan, create_deduction_history, add_fifo_entry, any direct InventoryHistory writes.

Tiny, surgical plan for PR2
Touch these files only (keep commits small):

app/blueprints/expiration/services.py → replace all FIFO writes with process_inventory_adjustment(...).

app/blueprints/inventory/routes.py → delete direct FIFO mutations; delegate to service.

app/services/pos_integration.py → replace FIFOService.add_fifo_entry and similar with the canonical service.

(Optional hardening) app/blueprints/fifo/services.py → rename writey helpers to _internal_* and keep __all__ = [] so nothing exports.

Add one wiring test per area (keeps behavior locked and prevents regressions):

tests/test_expiration_flow.py: monkeypatch process_inventory_adjustment and assert it’s called when marking expired.

tests/test_inventory_routes_wiring.py: posting to /inventory/adjust/<id> calls the service once.

tests/test_pos_integration_wiring.py: POS flow uses the service (no direct FIFOService.add_fifo_entry).

Greps to prove the consolidation (paste these in the PR body before/after):

bash
Copy
Edit
# no direct FIFO writes outside the service:
rg -n "execute_deduction_plan|create_deduction_history|add_fifo_entry|remaining_quantity\s*[-+]?=" app \
  | rg -v "services/inventory_adjustment\.py|blueprints/fifo/services\.py"

# only read-only FIFO allowed outside the service:
rg -n "FIFOService\.(get_fifo_entries|get_all_fifo_entries)\(" app | sort

# routes must call the service:
rg -n "process_inventory_adjustment\(" app/blueprints | sort
Example replacements (pattern, not paste-blind)
Before (expiration)

python
Copy
Edit
fifo_entry.remaining_quantity = 0.0
db.session.add(InventoryHistory(...))  # manual write
After

python
Copy
Edit
process_inventory_adjustment(
    item_id=fifo_entry.inventory_item_id,
    quantity=-abs(quantity_to_expire),      # deduct
    change_type="spoil",                    # or "trash"
    unit=fifo_entry.unit,
    notes=f"Expired lot {fifo_entry.id} • {notes or ''}".strip(),
    created_by=user_id,                     # if available
    # optionally: pass batch_id / source info via notes if you need linkage
)
Before (pos_integration)

python
Copy
Edit
FIFOService.add_fifo_entry(item_id, qty, change_type="restock", unit=..., notes=...)
After

python
Copy
Edit
process_inventory_adjustment(
    item_id=item_id,
    quantity=abs(qty),                      # positive for additions
    change_type="restock",                  # whatever your app expects
    unit=unit,
    notes=notes,
)
Before (inventory route)

python
Copy
Edit
entries = InventoryHistory.query.filter(...).all()
for entry in entries:
    entry.remaining_quantity -= deduction
After

python
Copy
Edit
success = process_inventory_adjustment(
    item_id=id,
    quantity=-abs(deduction_total),
    change_type="adjustment",   # or 'recount'/'use' depending on form
    unit=item.unit,
    notes=notes,
)
Short Replit prompt (to run PR2 right now)
Create PR “PR2: Canonicalize inventory mutations”.
Change only these files: app/blueprints/expiration/services.py, app/blueprints/inventory/routes.py, app/services/pos_integration.py, and (optionally) tighten app/blueprints/fifo/services.py public surface.
Replace all direct FIFO writes (add_fifo_entry, execute_deduction_plan, create_deduction_history, or InventoryHistory field mutations) with calls to app.services.inventory_adjustment.process_inventory_adjustment(...).
Keep behavior identical.
Add 3 minimal wiring tests ensuring those code paths call the service.
Show before/after outputs for the three greps listed above.
Run pytest and ensure 100% green.
Do not change schemas.

