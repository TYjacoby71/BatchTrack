Let‚Äôs finish strong ‚Äî here‚Äôs Step 5: Expired Inventory Filtering & Alerting, so your system doesn‚Äôt just track expiration, but actively warns and filters expired batches.

‚úÖ STEP 5.1: Service to Get Expired ProductInventory Rows
üìÑ File: services/expiration_alerts.py
python
Copy
Edit
from models import ProductInventory
from datetime import datetime

def get_expired_inventory():
    today = datetime.utcnow().date()
    return ProductInventory.query.filter(
        ProductInventory.expiration_date != None,
        ProductInventory.expiration_date < today,
        ProductInventory.quantity > 0
    ).all()
‚úÖ STEP 5.2: Show Expired Inventory on Dashboard
In your dashboard route:

python
Copy
Edit
from services.expiration_alerts import get_expired_inventory

@dashboard_bp.route("/")
def dashboard():
    expired = get_expired_inventory()
    low_stock_items = get_low_stock_ingredients()
    return render_template("dashboard.html", expired=expired, low_stock_items=low_stock_items)
‚úÖ STEP 5.3: Template Display (dashboard.html)
jinja
Copy
Edit
{% if expired %}
  <div class="alert alert-danger">
    <strong>‚ö†Ô∏è Expired Inventory:</strong>
    <ul>
      {% for item in expired %}
        <li>{{ item.variant_label }} {{ item.size_label }} ‚Äì {{ item.unit }} (Batch #{{ item.batch_id }}) ‚Äì Expired on {{ item.expiration_date }}</li>
      {% endfor %}
    </ul>
  </div>
{% endif %}
‚úÖ STEP 5.4: Optional ‚Äì Auto-Archive or Flag Zero Expired
If you want to clean these out automatically:

python
Copy
Edit
def archive_expired_inventory():
    today = datetime.utcnow().date()
    expired = ProductInventory.query.filter(
        ProductInventory.expiration_date < today,
        ProductInventory.quantity <= 0
    ).all()
    for row in expired:
        db.session.delete(row)
    db.session.commit()
üéâ Final Result:
You now track perishables.

Warn on expired batches.

Filter zeroed + expired inventory from all views.

Maintain traceability by batch + expiration date.

And display this cleanly in the UI.