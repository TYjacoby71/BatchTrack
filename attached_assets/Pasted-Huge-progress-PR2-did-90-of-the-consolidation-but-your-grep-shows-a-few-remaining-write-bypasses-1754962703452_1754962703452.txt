Huge progress. PR2 did ~90% of the consolidation, but your grep shows a few remaining write-bypasses. Let’s knock those out so all mutations go through process_inventory_adjustment (or a tiny public helper that lives in the same module).

Here’s the short, surgical checklist:

1) Expiration service (still mutating FIFO directly)
Files/lines (from your grep):

app/blueprints/expiration/services.py:573–620 (setting remaining_quantity, writing history)

Fix: replace those manual writes with the canonical call per lot:

python
Copy
Edit
from app.services.inventory_adjustment import process_inventory_adjustment

process_inventory_adjustment(
    item_id=fifo_entry.inventory_item_id,
    quantity=-abs(quantity_to_expire),
    change_type="spoil",            # or "trash"
    unit=fifo_entry.unit,
    notes=f"Expired lot #{fifo_entry.id}" + (f" — {notes}" if notes else "")
)
If you must credit/deduct a specific lot (not just FIFO order)
Add a tiny public helper in inventory_adjustment.py and call it from expiration:

python
Copy
Edit
# inventory_adjustment.py (public, tiny shim)
def credit_specific_lot(item_id: int, fifo_entry_id: int, qty: float, notes: str = "") -> bool:
    """Public seam: credit back quantity to an existing lot (by id)."""
    # use internal FIFOService methods *inside* this module
    success, plan, _ = FIFOService._internal_make_specific_credit_plan(fifo_entry_id, qty)
    if not success:
        return False
    FIFOService.execute_deduction_plan(plan, item_id)   # or a dedicated internal credit executor
    FIFOService.create_deduction_history(item_id, plan, 'unexpired', notes)
    return True
…and keep _internal_* methods non-exported from fifo/services.py. This preserves the single public mutation surface while allowing lot-targeted ops.

2) Inventory routes (one direct write)
File/line:

app/blueprints/inventory/routes.py:346 (remaining_quantity=input_quantity)

Fix: delete that write and delegate:

python
Copy
Edit
success = process_inventory_adjustment(
    item_id=id,
    quantity=abs(input_quantity),   # additions are positive
    change_type="restock",
    unit=item.unit,
    notes="Initial stock creation via adjustment modal",
)
3) POS integration (one add bypass)
File/line:

app/services/pos_integration.py:120 (FIFOService.add_fifo_entry(...))

Also a public add_fifo_entry wrapper at :359 — remove or make it internal.

Fix: replace with:

python
Copy
Edit
process_inventory_adjustment(
    item_id=item_id,
    quantity=abs(qty),
    change_type="restock",          # or your exact semantic ('sale_return', etc.)
    unit=unit,
    notes=notes,
)
Keep FIFOService.get_fifo_entries(...) for read-only selection of a source lot — that’s fine.

4) Reservation/audit writers (clean up direct field touches)
Files/lines:

app/services/reservation_service.py:82, 89, 148, 187

app/blueprints/api/reservation_routes.py:109

app/blueprints/products/products.py:42

These write remaining_quantity or craft history records directly. Two options:

If you must restore the original lot on unreserve/cancel, call the new credit_specific_lot(...) helper (above).

If lot identity doesn’t matter, a simple:

python
Copy
Edit
process_inventory_adjustment(
    item_id=reservation.inventory_item_id,
    quantity=abs(reservation.quantity),
    change_type="unreserved",
    unit=source_unit,
    notes=f"Released reservation; credited back (ref #{reservation.source_fifo_id})",
)
(This will create a new lot; only use if that’s acceptable.)

For “audit” records where you were writing history with remaining_quantity=0, move that into an inventory_adjustment.record_audit_entry(...) helper so routes/services never poke history tables directly.

Guardrail greps (run after the changes and paste in PR)
bash
Copy
Edit
# 1) No direct FIFO writes outside the canonical layer
rg -n "execute_deduction_plan|create_deduction_history|add_fifo_entry|remaining_quantity\s*[-+]?=" app \
  | rg -v "services/inventory_adjustment\.py|blueprints/fifo/services\.py" \
  || echo "✅ No external FIFO writes found"

# 2) Only read-only FIFO calls allowed outside the canonical service
rg -n "FIFOService\.(get_fifo_entries|get_all_fifo_entries|get_expired_fifo_entries)\(" app | sort

# 3) Routes call the canonical service
rg -n "process_inventory_adjustment\(" app/blueprints | sort
Tiny wiring tests (keep it simple)
tests/test_expiration_canonicalization.py: monkeypatch process_inventory_adjustment; call “mark expired”; assert it was called with expected args.

tests/test_inventory_routes_canonicalization.py: POST to /inventory/adjust/<id> with a restock; assert process_inventory_adjustment called once.

tests/test_pos_integration_canonicalization.py: run the POS path that used add_fifo_entry; assert it now calls process_inventory_adjustment.

Ping me with the new grep output. Once those last few lines disappear (or are behind a sanctioned inventory_adjustment helper), you’ve achieved a true single public entry point for inventory mutations—clean, auditable, and hard to regress.









Ask ChatGPT
