
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
Excellent. These test failures are exactly what we want to see. They are precise, they pinpoint specific problems, and they are all straightforward to fix. This is the value of a good test suite.
Let's break down each failure and fix it. They fall into three categories.
1. The NameError Failures
Tests: test_tier_permission_is_the_hard_ceiling, test_complete_security_cascade
Error: NameError: name 'AppPermission' is not defined
Root Cause: Just as we fixed in the last step for the other test file, this new file is also missing the crucial import for the AppPermission enum.
Fix: Add the correct import statement to the top of the file.
2. The InvalidRequestError Failures
Test: test_billing_status_enforcement (all 4 versions)
Error: sqlalchemy.exc.InvalidRequestError: Object '<Organization ...>' is already attached to session
Root Cause: The test_user fixture provides an organization object that is already "live" and attached to the database session. The test then tries to call db.session.add(org) on this already-attached object, which SQLAlchemy correctly rejects. You only need to add() brand new objects. For existing objects, you just modify them and then commit().
Fix: Remove the line db.session.add(org). The db.session.commit() is sufficient to save the changes.
3. The TypeError Failure
Test: test_developer_can_masquerade_regardless_of_billing
Error: TypeError: 'max_organizations' is an invalid keyword argument for SubscriptionTier
Root Cause: The test is trying to create a SubscriptionTier object with attributes (max_users, max_organizations) that don't exist on your actual SubscriptionTier model.
Fix: Remove the invalid keyword arguments from the SubscriptionTier constructor.
The Definitive Fix: The Corrected Test File
Here is the complete, corrected code for tests/test_billing_and_tier_enforcement.py. Replace the entire contents of your file with this version. It contains all the fixes for the errors listed above.
File to Edit: tests/test_billing_and_tier_enforcement.py
code
Python
import pytest
from flask_login import login_user
from app.models import db, User, Organization, SubscriptionTier, Role, Permission

# FIX 1: Add the missing import for AppPermission
from app.models.permissions import AppPermission

class TestBillingAndTierEnforcement:

    def test_tier_permission_is_the_hard_ceiling(self, app):
        """
        Tests that a user is BLOCKED from an action if their org's tier
        does not allow it, even if their role DOES have the permission.
        """
        with app.app_context():
            # ARRANGE: Create a complex state
            perm_view = Permission(name=AppPermission.PRODUCT_VIEW.value)
            perm_create = Permission(name=AppPermission.PRODUCT_CREATE.value)
            db.session.add_all([perm_view, perm_create])

            hobbyist_tier = SubscriptionTier(name='hobbyist', allowed_permissions=[perm_view])
            db.session.add(hobbyist_tier)

            org = Organization(name='Test Hobby Org', subscription_tier=hobbyist_tier, billing_status='active')
            db.session.add(org)
            
            # A role that has MORE permissions than the tier allows
            overpowered_role = Role(name='Manager', organization=org, permissions=[perm_view, perm_create])
            db.session.add(overpowered_role)

            user = User(email='test@hobby.org', organization=org, roles=[overpowered_role])
            db.session.add(user)
            db.session.commit()

            # ACT & ASSERT
            assert user.has_permission(AppPermission.PRODUCT_VIEW) is True
            assert user.has_permission(AppPermission.PRODUCT_CREATE) is False

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            org = test_user.organization
            org.billing_status = billing_status
            
            # FIX 2: Remove the redundant db.session.add(org)
            db.session.commit()

            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome", 200

            # ACT
            with client.session_transaction() as sess:
                sess['user_id'] = test_user.id
                sess['_fresh'] = True

            response = client.get('/_protected_dashboard')

            # ASSERT
            assert response.status_code == expected_status_code
            if expected_status_code == 302:
                assert '/billing/upgrade' in response.location

    def test_developer_can_masquerade_regardless_of_billing(self, app, client):
        """
        Tests that developers can access customer data even if billing is bad.
        """
        with app.app_context():
            # ARRANGE
            dev_tier = SubscriptionTier.query.filter_by(name='Developer').first()
            if not dev_tier:
                # FIX 3: Remove invalid keyword arguments
                dev_tier = SubscriptionTier(name='Developer')
                db.session.add(dev_tier)
            
            dev_org = Organization(name='Dev Org', subscription_tier=dev_tier, billing_status='active')
            developer = User(email='dev@example.com', organization=dev_org, user_type='developer')

            customer_org = Organization(name='Customer Org', billing_status='suspended') # Bad billing
            customer = User(email='customer@example.com', organization=customer_org)
            
            db.session.add_all([dev_org, developer, customer_org, customer])
            db.session.commit()

            @app.route('/_customer_dashboard')
            def _customer_dashboard():
                return f"Viewing org {customer.organization.name}", 200

            # ACT
            with client.session_transaction() as sess:
                sess['user_id'] = developer.id
                sess['_fresh'] = True
                sess['dev_selected_org_id'] = customer_org.id # Masquerade as the customer org

            response = client.get('/_customer_dashboard')

            # ASSERT: Developer should get access
            assert response.status_code == 200
            assert 'Viewing org Customer Org' in response.get_data(as_text=True)

    def test_complete_security_cascade(self, app):
        """
        Tests the complete security flow: billing -> tier -> role -> permission
        """
        with app.app_context():
            # ARRANGE
            perm_batch_view = Permission(name=AppPermission.BATCH_VIEW.value)
            perm_batch_create = Permission(name=AppPermission.BATCH_CREATE.value)
            db.session.add_all([perm_batch_view, perm_batch_create])

            pro_tier = SubscriptionTier(name='pro', allowed_permissions=[perm_batch_view, perm_batch_create])
            hobby_tier = SubscriptionTier(name='hobby', allowed_permissions=[perm_batch_view])
            db.session.add_all([pro_tier, hobby_tier])
            
            active_org = Organization(name='Active Pro Org', subscription_tier=pro_tier, billing_status='active')
            suspended_org = Organization(name='Suspended Pro Org', subscription_tier=pro_tier, billing_status='suspended')
            hobby_org = Organization(name='Active Hobby Org', subscription_tier=hobby_tier, billing_status='active')
            db.session.add_all([active_org, suspended_org, hobby_org])

            viewer_role = Role(name='Viewer', permissions=[perm_batch_view])
            creator_role = Role(name='Creator', permissions=[perm_batch_view, perm_batch_create])
            db.session.add_all([viewer_role, creator_role])

            user_active_creator = User(email='creator@active.com', organization=active_org, roles=[creator_role])
            user_suspended_creator = User(email='creator@suspended.com', organization=suspended_org, roles=[creator_role])
            user_hobby_creator = User(email='creator@hobby.com', organization=hobby_org, roles=[creator_role])
            user_hobby_viewer = User(email='viewer@hobby.com', organization=hobby_org, roles=[viewer_role])
            db.session.add_all([user_active_creator, user_suspended_creator, user_hobby_creator, user_hobby_viewer])
            db.session.commit()

            # ASSERT
            # User with active billing, pro tier, and creator role -> CAN create
            assert user_active_creator.has_permission(AppPermission.BATCH_CREATE) is True

            # User with suspended billing -> CANNOT create (even with right tier/role)
            # This is enforced by middleware, so has_permission might be true, but the route would be blocked.
            # We trust the middleware test for this. Let's check their permission logic.
            assert user_suspended_creator.has_permission(AppPermission.BATCH_CREATE) is True

            # User with active billing, but hobby tier -> CANNOT create (tier is ceiling)
            assert user_hobby_creator.has_permission(AppPermission.BATCH_CREATE) is False

            # User with active billing, hobby tier, viewer role -> CAN view
            assert user_hobby_viewer.has_permission(AppPermission.BATCH_VIEW) is True
35.5s
Start typing a prompt
