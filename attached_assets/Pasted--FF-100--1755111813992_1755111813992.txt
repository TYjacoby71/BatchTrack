.FF                                                                      [100%]
=================================== FAILURES ===================================
_________ TestInventoryFIFOCharacterization.test_fifo_deduction_order __________

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f50671a62d0>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f5067ec83d0>
test_user = <User test@example.com>, test_org = <Organization 2>

    def test_fifo_deduction_order(self, app, db_session, test_user, test_org):
        """Test FIFO deduction follows first-in-first-out order."""
        with app.test_request_context():
            login_user(test_user)
    
            # Create inventory item
            item = InventoryItem(
                name="Test Ingredient",
                type="ingredient",
                unit="g",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
            db_session.flush()
    
            # Add stock in layers (oldest first)
>           assert process_inventory_adjustment(
                item_id=item.id,
                quantity=100.0,
                change_type="restock",
                notes="First batch",
                created_by=test_user.id
            )

tests/test_inventory_fifo.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/inventory_adjustment/_core.py:292: in process_inventory_adjustment
    raise e
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item_id = 1, quantity = 100.0, change_type = 'restock', unit = 'g'
notes = 'First batch', created_by = 2, cost_override = None, item_type = None
custom_shelf_life_days = None, kwargs = {}
InventoryItem = <class 'app.models.inventory.InventoryItem'>, batch_id = None
order_id = None, customer = None, sale_price = None
caller_frame = <frame at 0x7f5065f7bc10, file '/home/runner/workspace/tests/test_inventory_fifo.py', line 33, code test_fifo_deduction_order>
caller_file = '/home/runner/workspace/tests/test_inventory_fifo.py'

    def process_inventory_adjustment(
        item_id: int,
        quantity: float,
        change_type: str,
        unit: str | None = None,
        notes: str | None = None,
        created_by: int | None = None,
        cost_override: float | None = None,
        item_type: str | None = None,
        custom_shelf_life_days: int | None = None,
        **kwargs,
    ) -> bool:
        """
        Process inventory adjustments through a centralized, canonical service.
        """
        from app.models.inventory import InventoryItem
    
        if custom_shelf_life_days is None:
            custom_shelf_life_days = kwargs.get("custom_shelf_life_days")
    
        # Extract optional metadata used downstream
        batch_id = kwargs.get("batch_id")
        order_id = kwargs.get("order_id")
        customer = kwargs.get("customer")
        sale_price = kwargs.get("sale_price")
    
        # Log canonical entry point usage for audit
        caller_frame = inspect.currentframe().f_back
        caller_file = caller_frame.f_code.co_filename
        caller_function = caller_frame.f_code.co_name
    
        logger.info(f"CANONICAL INVENTORY ADJUSTMENT: item_id={item_id}, quantity={quantity}, "
                   f"change_type={change_type}, caller={caller_file}:{caller_function}")
    
        # Validate required parameters
        if not item_id:
            logger.error("CANONICAL ENTRY: item_id is required")
            return False
    
        if quantity == 0:
            logger.warning("CANONICAL ENTRY: zero quantity adjustment requested")
            return True  # No-op but not an error
    
        # Start a transaction with explicit rollback protection
        try:
            # Pre-validate FIFO sync BEFORE starting any inventory changes (skip for recount)
            if change_type != 'recount':
                is_valid, error_msg, inv_qty, fifo_total = validate_inventory_fifo_sync(item_id, item_type)
                if not is_valid:
                    raise ValueError(f"Pre-adjustment validation failed - FIFO sync error: {error_msg}")
    
            # Get the item - treat item_id as inventory_item_id for unified handling
            item = InventoryItem.query.get(item_id)
    
            if not item:
                raise ValueError(f"Inventory item not found for ID: {item_id}")
    
            # Organization scoping check
            if current_user and current_user.is_authenticated and current_user.organization_id:
                if item.organization_id and item.organization_id != current_user.organization_id:
                    raise ValueError("Access denied: Item does not belong to your organization")
    
            # Add unit fallback for when unit is None
            if unit is None:
                unit = getattr(item, "unit", None)
    
            # Convert units if needed
            # only attempt conversion when there's something to convert
            if item_type != "product" and getattr(item, "type", None) != "container" and unit and unit != item.unit:
                conversion = safe_convert(quantity, unit, item.unit, ingredient_id=item.id)
                if not conversion["ok"]:
                    raise ValueError(conversion["error"])
                quantity = conversion["value"]
    
            # Determine quantity change and special handling
            current_quantity = item.quantity
    
            if change_type == 'recount':
                # Recount is special - handle independently from FIFO sync validation
                return handle_recount_adjustment(item_id, quantity, notes, created_by, item_type)
            elif change_type in ['spoil', 'trash', 'sold', 'sale', 'gift', 'sample', 'tester', 'quality_fail', 'damaged', 'expired', 'use', 'batch']:
                qty_change = -abs(quantity)
            elif change_type == 'reserved':
                # Handle reservation creation - deduct from available inventory
                qty_change = -abs(quantity)
            elif change_type == 'unreserved':
                # Unreserved operations should only be handled by ReservationService.release_reservation()
                # This should not be called directly through inventory adjustment
                raise ValueError("Unreserved operations must use ReservationService.release_reservation()")
            elif change_type == 'returned':
                qty_change = quantity
            else:
                qty_change = quantity
    
            # Handle expiration using ExpirationService
            from app.blueprints.expiration.services import ExpirationService
    
            expiration_date = None
            shelf_life_to_use = None
    
            is_perishable_override = expiration_date is not None or custom_shelf_life_days is not None
    
            if is_perishable_override:
                if expiration_date:
                    expiration_date = expiration_date
                elif custom_shelf_life_days:
                    expiration_date = ExpirationService.calculate_expiration_date(datetime.utcnow(), custom_shelf_life_days)
                shelf_life_to_use = custom_shelf_life_days
            elif item.is_perishable and item.shelf_life_days:
                # Use ExpirationService to get proper expiration date considering batch hierarchy
                expiration_date = ExpirationService.get_expiration_date_for_new_entry(item_id, batch_id)
                shelf_life_to_use = item.shelf_life_days
    
            # Handle cost calculations
            if change_type in ['spoil', 'trash']:
                cost_per_unit = None
            elif change_type in ['restock', 'finished_batch'] and qty_change > 0:
                # Calculate weighted average
                current_value = item.quantity * item.cost_per_unit
                new_value = qty_change * (cost_override or item.cost_per_unit)
                total_quantity = item.quantity + qty_change
    
                if total_quantity > 0:
                    weighted_avg_cost = (current_value + new_value) / total_quantity
                    item.cost_per_unit = weighted_avg_cost
                else: # If adding to zero quantity, use the new cost
                    item.cost_per_unit = cost_override or item.cost_per_unit
    
                cost_per_unit = cost_override or item.cost_per_unit
            elif cost_override is not None and change_type == 'cost_override':
                cost_per_unit = cost_override
                item.cost_per_unit = cost_override
            else:
                cost_per_unit = item.cost_per_unit
    
            # Track whether we already applied the quantity mutation inside FIFO helpers
            qty_applied_in_fifo = False
    
            # Handle inventory changes using internal FIFO methods
            if qty_change < 0:
                # Deductions - calculate plan first
                deduction_plan, error_msg = _calculate_deduction_plan_internal(
                    item_id, abs(qty_change), change_type
                )
    
                if not deduction_plan:
                    raise ValueError(error_msg or "Insufficient inventory")
    
                # Handle reservations specially - create reservations FIRST before any FIFO changes
                if change_type == 'reserved':
                    # Only products can be reserved
                    if item.type != 'product':
                        raise ValueError("Only products can be reserved, not raw inventory")
    
                    # Create reservation tracking with FIFO lot details BEFORE executing deductions
                    from app.services.reservation_service import ReservationService
    
                    reservations_created = []
                    try:
                        for fifo_entry_id, qty_deducted, cost_per_unit_from_plan in deduction_plan:
                            reservation, error = ReservationService.create_reservation(
                                inventory_item_id=item_id,
                                quantity=qty_deducted,
                                order_id=order_id,
                                source_fifo_id=fifo_entry_id,
                                unit_cost=cost_per_unit_from_plan,
                                customer=customer,
                                sale_price=sale_price,
                                notes=notes or f"Reserved for order {order_id}"
                            )
                            if error:
                                raise ValueError(f"Failed to create reservation: {error}")
                            reservations_created.append(reservation)
                    except Exception as e:
                        # If reservation creation fails, don't execute FIFO deductions
                        raise ValueError(f"Reservation creation failed, no inventory changes made: {str(e)}")
    
                # Execute the deduction plan ONLY after reservations are created successfully
                success, error_msg = _execute_deduction_plan_internal(deduction_plan, item_id)
                if not success:
                    raise ValueError(error_msg or "Failed to execute deduction plan")
    
                # Record deduction history
                success = _record_deduction_plan_internal(
                    item_id,
                    deduction_plan,
                    change_type,
                    notes,
                    batch_id=batch_id,
                    created_by=created_by,
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id,
                )
                if not success:
                    raise ValueError("Failed to record deduction history")
            elif qty_change > 0:
                # Additions - use internal FIFO methods
                if change_type == 'refunded' and batch_id:
                    # TODO: Handle refund credits - for now use standard addition
                    pass
    
                # Determine the correct unit for the history entry
                history_unit = 'count' if getattr(item, 'type', None) == 'container' else item.unit
    
                success, error_msg = _internal_add_fifo_entry_enhanced(
                    item_id=item_id,
                    quantity=qty_change,
                    change_type=change_type,
                    unit=history_unit,
                    notes=notes,
                    cost_per_unit=cost_per_unit,
                    expiration_date=expiration_date,
                    shelf_life_days=shelf_life_to_use,
                    batch_id=batch_id,
                    created_by=created_by,
                    customer=customer,
                    sale_price=sale_price,
                    order_id=order_id,
                    custom_expiration_date=expiration_date,
                    custom_shelf_life_days=shelf_life_to_use
                )
    
                if not success:
>                   raise ValueError(error_msg or "Failed to add FIFO entry")
E                   ValueError: Error creating FIFO entry: 'customer' is an invalid keyword argument for InventoryHistory

app/services/inventory_adjustment/_core.py:246: ValueError
----------------------------- Captured log setup -----------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured log call ------------------------------
INFO     app.services.inventory_adjustment._core:_core.py:53 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=100.0, change_type=restock, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_fifo_deduction_order
_ TestInventoryFIFOCharacterization.test_inventory_adjustment_delegates_properly _

self = <tests.test_inventory_fifo.TestInventoryFIFOCharacterization object at 0x7f50671a6990>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f5067ec83d0>
test_user = <User test@example.com>, test_org = <Organization 2>

    def test_inventory_adjustment_delegates_properly(self, app, db_session, test_user, test_org):
        """Verify inventory adjustment service delegates to proper internal systems."""
        with app.test_request_context():
            login_user(test_user)
    
            item = InventoryItem(
                name="Test Product",
                type="product",
                unit="ml",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id
            )
            db_session.add(item)
            db_session.flush()
    
            # Test product addition (should use ProductSKUHistory)
            result = process_inventory_adjustment(
                item_id=item.id,
                quantity=250.0,
                change_type="finished_batch",
                notes="Batch completion",
                created_by=test_user.id
            )
    
            assert result is True
            db_session.refresh(item)
>           assert item.quantity == 250.0
E           assert 0.0 == 250.0
E            +  where 0.0 = <InventoryItem 1>.quantity

tests/test_inventory_fifo.py:99: AssertionError
----------------------------- Captured log setup -----------------------------
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured log call ------------------------------
INFO     app.services.inventory_adjustment._core:_core.py:53 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=250.0, change_type=finished_batch, caller=/home/runner/workspace/tests/test_inventory_fifo.py:test_inventory_adjustment_delegates_properly
============================== warnings summary ==============================
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment/_validation.py:8: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment/_core.py:74: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment/_fifo_ops.py:199: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
========================== short test summary info ===========================
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order - ValueError: Error creating FIFO entry: 'customer' is an invalid keyword a...
FAILED tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly - assert 0.0 == 250.0
2 failed, 1 passed, 11 warnings in 6.35s
