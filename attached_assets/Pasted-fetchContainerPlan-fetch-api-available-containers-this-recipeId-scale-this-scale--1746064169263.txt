fetchContainerPlan() {
  fetch(`/api/available-containers/${this.recipeId}?scale=${this.scale}`)
    .then(res => res.json())
    .then(data => {
      this.allowedContainers = data.available || [];

      if (this.autoFill) {
        const projected = this.baseYield * this.scale;
        let remainingVolume = projected;
        const used = new Set();
        const selectedContainers = [];

        // Sort containers by capacity efficiency (largest first)
        const availableContainers = [...this.allowedContainers]
          .filter(c => c.stock_qty > 0)
          .sort((a, b) => b.storage_amount - a.storage_amount);

        for (const container of availableContainers) {
          if (used.has(container.id)) continue;

          const capacity = container.storage_amount;
          const stock = container.stock_qty;
          const needed = remainingVolume / capacity;

          // Use either the full number needed or as many as in stock
          const qtyToUse = Math.min(Math.floor(needed), stock);

          if (qtyToUse > 0) {
            selectedContainers.push({
              id: container.id,
              quantity: qtyToUse,
              name: container.name,
              capacity: capacity,
              unit: container.storage_unit
            });
            remainingVolume -= qtyToUse * capacity;
            used.add(container.id);
          }
        }

        // Try to fill remainder with best match, including partial container
        if (remainingVolume > 0) {
          const bestFit = availableContainers.find(c => !used.has(c.id) && c.stock_qty > 0 && c.storage_amount >= remainingVolume);

          if (bestFit) {
            selectedContainers.push({
              id: bestFit.id,
              quantity: 1,
              name: bestFit.name,
              capacity: bestFit.storage_amount,
              unit: bestFit.storage_unit
            });
            remainingVolume = 0;
            used.add(bestFit.id);
          }
        }

        this.containersSelected = selectedContainers;
        this.updateProgress();
        this.evaluateContainment();
      }

      this.refreshContainmentStatus();
    });
}
