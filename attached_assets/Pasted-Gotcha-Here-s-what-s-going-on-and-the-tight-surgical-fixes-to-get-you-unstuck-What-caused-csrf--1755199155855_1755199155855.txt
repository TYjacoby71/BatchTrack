Gotcha. Here’s what’s going on and the tight, surgical fixes to get you unstuck.

What caused “csrf_token is undefined”?
{{ csrf_token() }} is not a built-in Jinja function. It only exists if you expose flask_wtf.csrf.generate_csrf to templates under the name csrf_token. The login manager refactor didn’t cause this; it just surfaced that the token function was never injected (or was inadvertently removed).

The correct fix (keep CSRF + expose the token)
You want both:

CSRFProtect initialized, and

A context processor that maps csrf_token → generate_csrf.

1) Ensure the extension exists and is initialized
app/extensions.py

python
Copy
Edit
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager
from flask_wtf import CSRFProtect
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
# optional if you use email
from flask_mail import Mail

db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()
csrf = CSRFProtect()
limiter = Limiter(key_func=get_remote_address)
mail = Mail()  # if you use it; otherwise you can omit
app/init.py (inside your _init_extensions(app) or equivalent)

python
Copy
Edit
from .extensions import db, migrate, login_manager, csrf, limiter, mail

def _init_extensions(app):
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    csrf.init_app(app)
    limiter.init_app(app)
    try:
        mail.init_app(app)   # only if you’re actually sending email
    except Exception:
        pass
2) Inject csrf_token() into all templates
Still in app/init.py:

python
Copy
Edit
from flask_wtf.csrf import generate_csrf

@app.context_processor
def inject_csrf_token():
    # lets you use {{ csrf_token() }} anywhere
    return dict(csrf_token=generate_csrf)
This eliminates the “undefined csrf_token” error and keeps CSRF protection intact.

API vs HTML auth behavior (so tests stop fighting you)
For PR3 we’re hardening auth/permissions. The desired behavior:

Web pages (HTML): unauthenticated → 302 redirect to /auth/login

API routes (/api/* or requests with Accept: application/json): unauthenticated → 401 JSON, unauthorized → 403 JSON

Configure Flask-Login’s unauthorized handler once
app/init.py

python
Copy
Edit
from flask import request, jsonify, redirect, url_for
from .extensions import login_manager

@login_manager.unauthorized_handler
def _unauthorized():
    wants_json = request.path.startswith("/api") or (
        "application/json" in request.accept_mimetypes and not request.accept_mimetypes.accept_html
    )
    if wants_json:
        return jsonify({"error": "unauthorized"}), 401
    return redirect(url_for("auth.login"))
Keep a single permission decorator (no duplicates)
app/utils/permissions.py

python
Copy
Edit
from functools import wraps
from flask import request, jsonify, current_app
from flask_login import current_user
from werkzeug.exceptions import Forbidden

def _wants_json() -> bool:
    return request.path.startswith("/api") or (
        "application/json" in request.accept_mimetypes and not request.accept_mimetypes.accept_html
    )

def require_permission(permission_name: str):
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            # Auth
            if not current_user or not current_user.is_authenticated:
                if _wants_json():
                    return jsonify({"error":"unauthorized"}), 401
                return current_app.login_manager.unauthorized()

            # Permission
            if not current_user.has_permission(permission_name):
                if _wants_json():
                    return jsonify({"error":"forbidden","permission":permission_name}), 403
                raise Forbidden("You do not have the required permissions.")
            return f(*args, **kwargs)
        return decorated
    return decorator

# Back-compat alias
permission_required = require_permission
Decorator order rule of thumb

Web pages: @login_required then @require_permission(...)

API routes: don’t stack @login_required; just use @require_permission(...) (it already checks auth and returns JSON).

This prevents Flask-Login from intercepting with a 302 before your API JSON logic runs.

Quick smoke checks
CSRF meta tag renders:

Hit any page with <meta name="csrf-token" content="{{ csrf_token() }}">. No Jinja error.

API unauth → 401 JSON:

bash
Copy
Edit
curl -i -H "Accept: application/json" http://localhost:5000/api/whatever-protected
# Expect: HTTP/1.1 401 ...  {"error":"unauthorized"}
Web unauth → 302 redirect:

bash
Copy
Edit
curl -i http://localhost:5000/some/protected/page
# Expect: 302 Location: /auth/login
Minimal tests to lock this in
tests/test_auth_permissions.py

python
Copy
Edit
def test_api_unauth_returns_json_401(client, app):
    @app.route("/api/_perm_test")
    @permission_required("some.permission")
    def _p():
        return {"ok": True}

    resp = client.get("/api/_perm_test", headers={"Accept": "application/json"})
    assert resp.status_code == 401
    assert resp.is_json and resp.get_json().get("error") == "unauthorized"

def test_web_unauth_redirects_to_login(client, app):
    @app.route("/web/_perm_test")
    @login_required
    @permission_required("some.permission")
    def _w():
        return "ok"

    resp = client.get("/web/_perm_test", follow_redirects=False)
    assert resp.status_code == 302
    assert "/auth/login" in resp.headers.get("Location","")

def test_csrf_token_available_in_templates(client, app):
    from flask import render_template_string
    @app.route("/_csrf_check")
    def _csrf_check():
        return render_template_string('<meta name="csrf-token" content="{{ csrf_token() }}">')
    resp = client.get("/_csrf_check")
    assert resp.status_code == 200
    assert b'meta name="csrf-token"' in resp.data
TL;DR
The CSRF error is fixed by exposing generate_csrf as csrf_token via a context processor (and keeping CSRFProtect initialized).

The 302 vs 401 loop is fixed by:

API: use only @require_permission(...) (it returns JSON),

Web: keep @login_required + @require_permission(...).

Add the unauthorized handler that returns JSON on /api/*.

If you hit anything else after applying these, paste the exact traceback or the route + headers you’re hitting, and I’ll pinpoint the next fix.