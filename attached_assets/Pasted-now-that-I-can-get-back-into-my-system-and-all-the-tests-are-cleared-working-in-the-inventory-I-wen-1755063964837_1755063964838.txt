now that I can get back into my system and all the tests are cleared working in the inventory, I went to restock and the submit adjustment button hangs and then after the page reloads it adjusts the history and is creating lots and they do have quantity remaining. The recount function is now broken and allowing the desynching between fio and inventory item quantity. So I recounted from five lots of 10 items with the total quantity of 50 I recounted to zero and now all of the lots remain in the history table but the quantity is at zero. And the Spoil and Trash inventory types functions or inventory change types are taking me to a fresh page that says invalid change type. Is all of this supposed to get resolved again with the rest of the refactor?


ChatGPT said:

Thought for 33s
Not everything you’re seeing will “magically resolve” later—those are real gaps. The good news: you can fix them with two small, surgical changes.

1) Fix the hanging submit + “Invalid change type” (route)
Your /inventory/adjust/<id> route only handled recount and restock and returned 204. A normal form POST expects a redirect (PRG pattern). Also, you need to pass through the other change types (spoil, trash, etc.) to the canonical service.

Edit app/blueprints/inventory/routes.py in adjust_inventory:

Add support for deductive change types

Replace the ('', 204) returns with a redirect to the item page

python
Copy
@inventory_bp.route('/adjust/<int:id>', methods=['POST'])
@login_required
def adjust_inventory(id):
    item = InventoryItem.query.get_or_404(id)

    form = request.form
    adj_type = (form.get('adjustment_type') or form.get('change_type') or '').strip().lower()
    qty = float(form.get('quantity', 0) or 0.0)
    notes = form.get('notes') or None
    unit = form.get('input_unit') or getattr(item, 'unit', None)

    deduct_types = {
        'spoil','trash','expired','gift','sample','tester',
        'quality_fail','damaged','sold','sale','use','batch'
    }

    # Recount (absolute target)
    if adj_type == 'recount':
        process_inventory_adjustment(
            item_id=item.id,
            quantity=qty,
            change_type='recount',
            unit=unit,
            notes=notes,
            created_by=getattr(current_user, 'id', None),
        )
        # PRG: always redirect after POST
        return redirect(url_for('inventory.view_inventory', id=item.id))

    # First-time restock (cost override allowed)
    if adj_type == 'restock':
        has_hist = InventoryHistory.query.filter_by(inventory_item_id=item.id).count() > 0
        cost_override = None
        if not has_hist and form.get('cost_entry_type') == 'per_unit' and form.get('cost_per_unit'):
            try:
                cost_override = float(form.get('cost_per_unit'))
            except ValueError:
                cost_override = None

        process_inventory_adjustment(
            item_id=item.id,
            quantity=qty,
            change_type='restock',
            unit=unit,
            notes=notes,
            created_by=getattr(current_user, 'id', None),
            cost_override=cost_override,
        )
        return redirect(url_for('inventory.view_inventory', id=item.id))

    # Deductive adjustments (spoil/trash/etc.)
    if adj_type in deduct_types:
        process_inventory_adjustment(
            item_id=item.id,
            quantity=qty,               # service will flip sign to deduction
            change_type=adj_type,
            unit=unit,
            notes=notes,
            created_by=getattr(current_user, 'id', None),
        )
        return redirect(url_for('inventory.view_inventory', id=item.id))

    return ('Invalid adjustment type', 400)
Why this helps

No more “blank” 204 to a form POST → browser gets a normal redirect.

spoil/trash/etc. are now passed to the canonical service (which already makes them negative).

2) Fix recount so FIFO entries actually zero when you recount to 0
Right now recount sets the item quantity but doesn’t consume/clear FIFO entries, which causes the desync you saw (item = 0 but lots have remaining quantities).

Replace your handle_recount_adjustment in app/services/inventory_adjustment.py with this implementation (minimal, uses the internal FIFO helpers you already have):

python
Copy
def handle_recount_adjustment(item_id, new_quantity, notes, created_by, item_type=None):
    """
    Recount sets an absolute target. If lowering quantity, it must deduct across
    *all* lots (including expired) so FIFO remaining quantities match the new total.
    If raising quantity, it creates a new FIFO entry for the delta.
    """
    from app.extensions import db
    from app.models.inventory import InventoryItem, InventoryHistory
    # Import internal FIFO helpers (available in your FIFO module)
    from app.blueprints.fifo.services import _FIFOService, FIFOService

    item = InventoryItem.query.get(item_id)
    if not item:
        raise ValueError(f"Inventory item not found for ID: {item_id}")

    current = float(item.quantity or 0.0)
    target = float(new_quantity or 0.0)
    if target == current:
        return True

    delta = target - current

    # Increasing stock: add a single FIFO entry for the delta
    if delta > 0:
        FIFOService._internal_add_fifo_entry(
            inventory_item_id=item_id,
            quantity=delta,
            change_type='recount',
            unit=(item.unit or 'count'),
            notes=notes or 'Recount increase',
            cost_per_unit=item.cost_per_unit,
            created_by=created_by,
        )
        item.quantity = target
        db.session.commit()
        return True

    # Decreasing stock: build a deduction plan over ALL entries (incl. expired)
    to_remove = abs(delta)
    entries = _FIFOService.get_all_fifo_entries(item_id)  # oldest-first with remaining_quantity > 0
    deduction_plan = []
    remaining = to_remove
    for e in entries:
        if remaining <= 0:
            break
        take = min(float(e.remaining_quantity), remaining)
        if take > 0:
            deduction_plan.append((e.id, take, getattr(e, "unit_cost", None)))
            remaining -= take

    # If not enough remaining_quantity to match the recount target, treat as 0
    # (shouldn't happen if current = sum(remaining_quantity), but guard anyway)
    if remaining > 0:
        # zero whatever exists; this keeps item and FIFO consistent
        pass

    # Apply deduction to FIFO entries (decrement remaining_quantity)
    _FIFOService.execute_deduction_plan(deduction_plan, item_id)

    # Record deduction history rows (change_type='recount') without creating new FIFO
    _FIFOService._internal_create_deduction_history(
        inventory_item_id=item_id,
        deduction_plan=deduction_plan,
        change_type='recount',
        notes=notes or 'Recount decrease',
        batch_id=None,
        created_by=created_by,
        customer=None,
        sale_price=None,
        order_id=None,
    )

    # Finally set the item to the absolute target
    item.quantity = target
    db.session.commit()
    return True
Why this helps

Recount down now genuinely consumes from FIFO lots (including expired), bringing their remaining_quantity to zero as needed.

Recount up adds a single controlled FIFO entry for the delta.

What to expect after these two changes
Form no longer hangs; you’ll see the item page after submit (PRG).

spoil/trash work again via the canonical path.

Recount to 0 leaves no stray remaining quantities in FIFO; item quantity and FIFO will be in sync.

If anything still feels off after you drop these in, tell me the exact form payload you’re posting (fields + sample values) and I’ll tailor the handler to it.