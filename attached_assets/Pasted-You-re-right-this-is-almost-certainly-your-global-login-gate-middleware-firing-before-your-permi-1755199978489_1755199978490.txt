You’re right: this is almost certainly your global “login gate” middleware firing before your @permission_required decorator. That before_request guard is returning a 302 redirect, so your test never reaches the decorator that would have sent JSON.

Fix it by making one canonical “wants JSON” check and using it in both the Flask-Login unauthorized handler and your global login middleware.

1) Add a single JSON detector
app/init.py

python
Copy
Edit
from flask import request

def _wants_json() -> bool:
    # Path-first: anything under /api should be JSON
    if request.path.startswith("/api"):
        return True
    # Header-based fallback
    accept = request.accept_mimetypes
    return ("application/json" in accept) and (not accept.accept_html)
2) Make Flask-Login return JSON for API
Still in app/init.py:

python
Copy
Edit
from flask import jsonify, redirect, url_for
from .extensions import login_manager

@login_manager.unauthorized_handler
def _unauthorized():
    if _wants_json():
        return jsonify({"error": "unauthorized"}), 401
    return redirect(url_for("auth.login"))
3) Update your global login middleware
Wherever you enforce “login required” globally (often in _register_middleware(app)):

python
Copy
Edit
from flask import request, jsonify, redirect, url_for
from flask_login import current_user

def _register_middleware(app):
    @app.before_request
    def _global_login_gate():
        # allowlist of public endpoints
        public = {
            "static",
            "auth.login", "auth.logout",
            "auth.oauth_login", "auth.callback",
            "api.server_time",  # if you have it public
            "healthcheck",      # if present
        }
        if request.endpoint in public:
            return None

        if not current_user.is_authenticated:
            if _wants_json():
                return jsonify({"error": "unauthorized"}), 401
            # use the login manager handler so behavior stays centralized
            return login_manager.unauthorized()
Why this matters: the before_request guard runs before your view and decorators. If it redirects, your decorator never executes. With the change above, /api/... (and JSON-accepting clients) get a 401 JSON, matching your test expectation.

4) Keep the permission decorator simple (no redirects)
app/utils/permissions.py

python
Copy
Edit
from functools import wraps
from flask import jsonify, current_app, request
from flask_login import current_user

def _wants_json() -> bool:
    if request.path.startswith("/api"):
        return True
    accept = request.accept_mimetypes
    return ("application/json" in accept) and (not accept.accept_html)

def require_permission(permission_name: str):
    def deco(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            if not current_user.is_authenticated:
                if _wants_json():
                    return jsonify({"error": "unauthorized"}), 401
                return current_app.login_manager.unauthorized()

            if not current_user.has_permission(permission_name):
                if _wants_json():
                    return jsonify({"error": "forbidden", "permission": permission_name}), 403
                from werkzeug.exceptions import Forbidden
                raise Forbidden("You do not have the required permissions.")

            return f(*args, **kwargs)
        return wrapped
    return deco

# Back-compat alias if tests import this name
permission_required = require_permission
5) Ensure CSRF token is available (so templates don’t break)
You mentioned the csrf_token undefined error. Keep this context processor:

app/init.py

python
Copy
Edit
from flask_wtf.csrf import generate_csrf

@app.context_processor
def _inject_csrf():
    return dict(csrf_token=generate_csrf)
Why this fixes your failing test
Your test registers /api/test-perm and calls it unauthenticated. Previously, your global login middleware redirected to login (302). Now, it sees /api/... and returns {"error":"unauthorized"}, 401, so:

py
Copy
Edit
assert response.status_code == 401  # ✅ will pass now
Quick sanity checks
curl -i http://localhost:5000/api/test-perm → 401 with JSON

curl -i http://localhost:5000/some/protected/page → 302 to /auth/login

templates with <meta name="csrf-token" content="{{ csrf_token() }}"> render fine

If it still 302s, you likely have another before_request or an old blueprint-level guard doing a raw redirect(...). Switch those to call login_manager.unauthorized() (which now r