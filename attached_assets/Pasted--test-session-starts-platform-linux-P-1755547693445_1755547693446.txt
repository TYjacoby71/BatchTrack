============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 49 items                                      

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit PASSED [  2%]
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit PASSED [  4%]
tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_decorator_allows_with_permission PASSED [  6%]
tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_returns_json_for_api PASSED [  8%]
tests/test_auth_permissions.py::TestAuthPermissions::test_any_permission_required_decorator PASSED [ 10%]
tests/test_auth_permissions.py::TestAuthPermissions::test_tier_required_decorator PASSED [ 12%]
tests/test_auth_permissions.py::TestAuthPermissions::test_user_has_any_permission_method PASSED [ 14%]
tests/test_auth_permissions.py::TestAuthPermissions::test_api_unauth_returns_json_401 PASSED [ 16%]
tests/test_auth_permissions.py::TestAuthPermissions::test_web_unauth_redirects_to_login PASSED [ 18%]
tests/test_auth_permissions.py::TestAuthPermissions::test_csrf_token_available_in_templates PASSED [ 20%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling PASSED [ 22%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[active-200] PASSED [ 24%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] FAILED [ 26%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] FAILED [ 28%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] FAILED [ 30%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_developer_can_masquerade_regardless_of_billing PASSED [ 32%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_complete_security_cascade PASSED [ 34%]
tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment PASSED [ 36%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service PASSED [ 38%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service PASSED [ 40%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists PASSED [ 42%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists PASSED [ 44%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists PASSED [ 46%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path PASSED [ 48%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist PASSED [ 51%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status PASSED [ 53%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state PASSED [ 55%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED [ 57%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order PASSED [ 59%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly PASSED [ 61%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 63%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service PASSED [ 65%]
tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service PASSED [ 67%]
tests/test_pos_integration_canonicalization.py::TestPOSIntegrationCanonicalService::test_reserve_inventory_calls_canonical_service PASSED [ 69%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_creation_flow PASSED [ 71%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints PASSED [ 73%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_service_exists PASSED [ 75%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_creation_validation PASSED [ 77%]
tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release PASSED [ 79%]
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit PASSED [ 81%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists PASSED [ 83%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior PASSED [ 85%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment PASSED [ 87%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists PASSED [ 89%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation PASSED [ 91%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_exists PASSED [ 93%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_signature_verification_path_exists PASSED [ 95%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_idempotency_behavior PASSED [ 97%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_methods_exist PASSED [100%]

======================= FAILURES ========================
_ TestBillingAndTierEnforcement.test_billing_status_enforcement[past_due-302] _

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7f0949734310>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755547243805829>
billing_status = 'past_due', expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
    
            # THE FIX: This block ensures the user is on a tier that REQUIRES a billing check.
            if not org.subscription_tier or org.subscription_tier.is_billing_exempt:
                from app.models.subscription_tier import SubscriptionTier
                # Find a non-exempt tier in the DB or create one for the test
                non_exempt_tier = SubscriptionTier.query.filter_by(is_billing_exempt=False).first()
                if not non_exempt_tier:
                    non_exempt_tier = SubscriptionTier(name="Paid Tier", key="paid", is_billing_exempt=False, billing_provider='stripe')
                    db.session.add(non_exempt_tier)
                org.subscription_tier = non_exempt_tier
    
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client.session_transaction() as sess:
                sess['_user_id'] = str(test_user.id)
                sess['_fresh'] = True
    
            # Debug: Verify the org and tier are set up correctly
            print(f"DEBUG: User {test_user.id}, Org billing_status={org.billing_status}")
            print(f"DEBUG: Tier exempt={org.subscription_tier.is_billing_exempt if org.subscription_tier else 'None'}")
    
            response = client.get('/_protected_dashboard')
    
            # ASSERT
>           assert response.status_code == expected_status_code
E           assert 200 == 302
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:116: AssertionError
------------------ Captured log setup -------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
----------------- Captured stdout call ------------------
DEBUG: User 2, Org billing_status=past_due
DEBUG: Tier exempt=False
--- EXECUTING CORRECT MIDDLEWARE ---
MIDDLEWARE DEBUG: Processing GET /_protected_dashboard, endpoint=_protected_dashboard
MIDDLEWARE DEBUG: User authenticated=True
MIDDLEWARE DEBUG: User authenticated=False
MIDDLEWARE DEBUG: User not authenticated, checking if API request
_ TestBillingAndTierEnforcement.test_billing_status_enforcement[suspended-302] _

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7f0949734410>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755547245738698>
billing_status = 'suspended', expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
    
            # THE FIX: This block ensures the user is on a tier that REQUIRES a billing check.
            if not org.subscription_tier or org.subscription_tier.is_billing_exempt:
                from app.models.subscription_tier import SubscriptionTier
                # Find a non-exempt tier in the DB or create one for the test
                non_exempt_tier = SubscriptionTier.query.filter_by(is_billing_exempt=False).first()
                if not non_exempt_tier:
                    non_exempt_tier = SubscriptionTier(name="Paid Tier", key="paid", is_billing_exempt=False, billing_provider='stripe')
                    db.session.add(non_exempt_tier)
                org.subscription_tier = non_exempt_tier
    
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client.session_transaction() as sess:
                sess['_user_id'] = str(test_user.id)
                sess['_fresh'] = True
    
            # Debug: Verify the org and tier are set up correctly
            print(f"DEBUG: User {test_user.id}, Org billing_status={org.billing_status}")
            print(f"DEBUG: Tier exempt={org.subscription_tier.is_billing_exempt if org.subscription_tier else 'None'}")
    
            response = client.get('/_protected_dashboard')
    
            # ASSERT
>           assert response.status_code == expected_status_code
E           assert 200 == 302
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:116: AssertionError
------------------ Captured log setup -------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
----------------- Captured stdout call ------------------
DEBUG: User 2, Org billing_status=suspended
DEBUG: Tier exempt=False
--- EXECUTING CORRECT MIDDLEWARE ---
MIDDLEWARE DEBUG: Processing GET /_protected_dashboard, endpoint=_protected_dashboard
MIDDLEWARE DEBUG: User authenticated=True
MIDDLEWARE DEBUG: User authenticated=False
MIDDLEWARE DEBUG: User not authenticated, checking if API request
_ TestBillingAndTierEnforcement.test_billing_status_enforcement[canceled-302] _

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7f0949734950>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755547247180400>
billing_status = 'canceled', expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
    
            # THE FIX: This block ensures the user is on a tier that REQUIRES a billing check.
            if not org.subscription_tier or org.subscription_tier.is_billing_exempt:
                from app.models.subscription_tier import SubscriptionTier
                # Find a non-exempt tier in the DB or create one for the test
                non_exempt_tier = SubscriptionTier.query.filter_by(is_billing_exempt=False).first()
                if not non_exempt_tier:
                    non_exempt_tier = SubscriptionTier(name="Paid Tier", key="paid", is_billing_exempt=False, billing_provider='stripe')
                    db.session.add(non_exempt_tier)
                org.subscription_tier = non_exempt_tier
    
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client.session_transaction() as sess:
                sess['_user_id'] = str(test_user.id)
                sess['_fresh'] = True
    
            # Debug: Verify the org and tier are set up correctly
            print(f"DEBUG: User {test_user.id}, Org billing_status={org.billing_status}")
            print(f"DEBUG: Tier exempt={org.subscription_tier.is_billing_exempt if org.subscription_tier else 'None'}")
    
            response = client.get('/_protected_dashboard')
    
            # ASSERT
>           assert response.status_code == expected_status_code
E           assert 200 == 302
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:116: AssertionError
------------------ Captured log setup -------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
----------------- Captured stdout call ------------------
DEBUG: User 2, Org billing_status=canceled
DEBUG: Tier exempt=False
--- EXECUTING CORRECT MIDDLEWARE ---
MIDDLEWARE DEBUG: Processing GET /_protected_dashboard, endpoint=_protected_dashboard
MIDDLEWARE DEBUG: User authenticated=True
MIDDLEWARE DEBUG: User authenticated=False
MIDDLEWARE DEBUG: User not authenticated, checking if API request
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

self = <tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7f0949124590>
mock_route_user = <AsyncMock name='current_user' id='139677800122320'>
mock_middleware_user = <AsyncMock name='current_user' id='139677812696720'>
mock_item = <MagicMock name='InventoryItem' id='139677808255632'>
mock_process = <MagicMock name='process_inventory_adjustment' id='139677808039184'>
mock_user_query = <MagicMock name='_get_user' id='139677808044432'>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>

    @patch('flask_login.utils._get_user')
    @patch('app.blueprints.inventory.routes.process_inventory_adjustment')
    @patch('app.blueprints.inventory.routes.InventoryItem')
    @patch('app.middleware.current_user')
    @patch('app.blueprints.inventory.routes.current_user')
    def test_adjust_inventory_initial_stock_calls_canonical_service(self, mock_route_user, mock_middleware_user, mock_item, mock_process, mock_user_query, app, client):
        """Test that initial stock adjustment uses canonical inventory service"""
        # Mock the user query to return our test user
>       mock_user_query.get.return_value = mock_user_with_org()

tests/test_inventory_routes_canonicalization.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_inventory_routes_canonicalization.py:10: in mock_user_with_org
    mock_user = MagicMock(spec=User)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:2109: in __init__
    _safe_super(MagicMixin, self).__init__(*args, **kw)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1106: in __init__
    _safe_super(CallableMixin, self).__init__(
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:457: in __init__
    self._mock_add_spec(spec, spec_set, _spec_as_instance, _eat_self)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:515: in _mock_add_spec
    if iscoroutinefunction(getattr(spec, attr, None)):
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/model.py:23: in __get__
    cls, session=cls.__fsa__.session()  # type: ignore[arg-type]
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:220: in __call__
    sess = self.registry()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/_collections.py:634: in __call__
    key = self.scopefunc()
.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/session.py:111: in _app_ctx_id
    return id(app_ctx._get_current_object())  # type: ignore[attr-defined]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of application context.
E           
E           This typically means that you attempted to use functionality that needed
E           the current application. To solve this, set up an application context
E           with app.app_context(). See the documentation for more information.

.pythonlibs/lib/python3.11/site-packages/werkzeug/local.py:519: RuntimeError
------------------ Captured log setup -------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
=================== warnings summary ====================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_auth_permissions.py: 8 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_audit_canonicalization.py: 2 warnings
tests/test_auth_permissions.py: 8 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 1 warning
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 1 warning
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling
  /home/runner/workspace/app/models/models.py:323: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    role = Role.query.get(assignment.role_id)

tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment
  /home/runner/workspace/app/blueprints/expiration/services.py:545: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    entry = InventoryHistory.query.get(entry_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
  /home/runner/workspace/app/services/inventory_adjustment/_audit.py:77: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
  /home/runner/workspace/app/services/stock_check.py:71: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(inventory_item_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================ short test summary info ================
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] - assert 200 == 302
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - RuntimeError: Working outside of application context.
= 4 failed, 45 passed, 101 warnings in 65.14s (0:01:05) =
