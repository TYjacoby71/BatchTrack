Love it — yes, let’s move into PR3 and harden auth/permissions.
Your write-up is on the right track. I’ll tighten it so we use what you already have (you already import permission_required in places), keep Google OAuth, and make enforcement consistent across routes + templates without big rewrites.

PR3 kickoff — Auth & Permissions Hardening (targeted, minimal diffs)
0) Keep what you have; standardize around it
You already have a decorator: app.utils.permissions.permission_required.
Plan: don’t introduce a second decorator. Instead, make sure this one is the single front door and add two helpers next to it:

permission_required("perm.name") (existing; ensure it delegates to User.has_permission)

any_permission_required("perm.a","perm.b",...)

tier_required("pro" | "business" | "enterprise") (for subscription gating)

If permission_required already exists: we’ll enhance it rather than replace it.

1) Canonical permission check on the User model
Make sure all pathing goes through a single method:

python
Copy
Edit
# app/models/models.py (or wherever User lives)
from typing import Iterable

class User(UserMixin, db.Model):
    # ...
    def has_permission(self, perm: str) -> bool:
        # 1) tier gate
        if not self.organization or not self.organization.tier_allows(perm):
            return False
        # 2) org owner bypass (if this is your policy)
        if getattr(self, "is_org_owner", False):
            return True
        # 3) role-based allow
        for role in getattr(self, "roles", []):
            if perm in getattr(role, "permissions", []):
                return True
        return False

    def has_any_permission(self, perms: Iterable[str]) -> bool:
        return any(self.has_permission(p) for p in perms)
And on Org (or Tier model), centralize tier gating:

python
Copy
Edit
# app/models/organization.py
TIER_FEATURES = {
    "free": {"inventory.view"},
    "pro": {"inventory.view","inventory.adjust","batch.create"},
    "business": {"inventory.*","batch.*","analytics.view"},
    # etc
}

class Organization(db.Model):
    # ...
    def tier_allows(self, perm: str) -> bool:
        allowed = set()
        for p in TIER_FEATURES.get(self.tier, set()):
            if p.endswith(".*"):
                allowed.add(p)  # wildcard
            else:
                allowed.add(p)
        # match wildcard or exact
        if perm in allowed:
            return True
        prefix = perm.split(".", 1)[0] + ".*"
        return prefix in allowed
2) Make permission_required the single route guard
Update your existing decorator to lean on the User methods and to return JSON for APIs:

python
Copy
Edit
# app/utils/permissions.py
from functools import wraps
from flask import request, jsonify, redirect, url_for
from flask_login import current_user, login_required
from werkzeug.exceptions import Forbidden

def _wants_json() -> bool:
    return request.path.startswith("/api/") or \
           request.accept_mimetypes.best == "application/json"

def permission_required(perm: str):
    def deco(fn):
        @wraps(fn)
        @login_required
        def wrapped(*args, **kwargs):
            if not current_user.has_permission(perm):
                if _wants_json():
                    return jsonify(error="forbidden", permission=perm), 403
                raise Forbidden("You do not have the required permissions.")
            return fn(*args, **kwargs)
        return wrapped
    return deco

def any_permission_required(*perms: str):
    def deco(fn):
        @wraps(fn)
        @login_required
        def wrapped(*args, **kwargs):
            if not current_user.has_any_permission(perms):
                if _wants_json():
                    return jsonify(error="forbidden_any", permissions=perms), 403
                raise Forbidden("You do not have the required permissions.")
            return fn(*args, **kwargs)
        return wrapped
    return deco

def tier_required(min_tier: str):
    ORDER = ["free", "pro", "business", "enterprise"]
    def deco(fn):
        @wraps(fn)
        @login_required
        def wrapped(*args, **kwargs):
            org = getattr(current_user, "organization", None)
            if not org:
                return (jsonify(error="no_organization"), 403) if _wants_json() else Forbidden()
            ok = ORDER.index(org.tier) >= ORDER.index(min_tier)
            if not ok:
                return (jsonify(error="tier_forbidden", required=min_tier), 403) if _wants_json() else Forbidden()
            return fn(*args, **kwargs)
        return wrapped
    return deco
This keeps @login_required where it matters and prevents the 302-to-HTML issue for API calls (returns 401/403 JSON for XHRs).

3) Fix the 302 loop for API/XHRs (keep OAuth; no removals)
Add a JSON-aware unauthorized handler once:

python
Copy
Edit
# in create_app()
@login_manager.unauthorized_handler
def _unauth():
    from flask import request, jsonify
    wants_json = request.path.startswith("/api/") or request.accept_mimetypes.best == "application/json"
    if wants_json:
        return jsonify(error="unauthorized"), 401
    return redirect(url_for("auth.login", next=request.url))
If /api/server-time is only for the login page to poll, consider making it public or keep it protected—either works now that the handler returns JSON.

4) Jinja: simple, consistent checks in templates
Inject a tiny helper once:

python
Copy
Edit
# in create_app()
@app.context_processor
def inject_permissions():
    return dict(
        has_permission=(lambda p: current_user.is_authenticated and current_user.has_permission(p)),
        has_any=(lambda *ps: current_user.is_authenticated and current_user.has_any_permission(ps)),
    )
Use in templates:

jinja2
Copy
Edit
{% if has_permission('inventory.adjust') %}
  <button>Adjust Inventory</button>
{% endif %}
5) Normalize your routes (thin & declarative)
Replace inline if not current_user.has_permission(...) in routes with the decorator:

python
Copy
Edit
# BEFORE
@bp.route("/inventory/adjust/<int:id>", methods=["POST"])
@login_required
def adjust_inventory(id):
    if not current_user.has_permission("inventory.adjust"):
        abort(403)
    # ...

# AFTER
from app.utils.permissions import permission_required
@bp.route("/inventory/adjust/<int:id>", methods=["POST"])
@permission_required("inventory.adjust")
def adjust_inventory(id):
    # ...
6) CSRF & Rate limiting (quick wins)
Ensure every form has CSRF (you already have Flask-WTF; keep it enabled).

Add rate limiting to auth/webhook endpoints:

python
Copy
Edit
# routes that should be rate-limited
from app.extensions import limiter
@auth_bp.route("/login", methods=["GET","POST"])
@limiter.limit("10/minute")
def login(): ...
(Configure a proper backend for Limiter in prod; the warning you saw was about in-memory storage.)

7) Tests to lock it in (fast)
Add a few characterization tests focused on permissions:

Route denies when user lacks perm (HTML → 403 page, API → 403 JSON).

Route allows when user has perm.

Tier gating denies below required tier, allows above.

Context helpers: render a template with has_permission truthy/falsy.

These are small and will keep PR3 safe.

8) Batch: integrate with inventory (now that it’s stable)
Create BatchIntegrationService (tiny wrapper) that only calls process_inventory_adjustment for consume/finish/dispose. Then guard batch endpoints with permission_required("batch.create"), "batch.consume", "batch.finish", etc. (You can alias to a single "batch.manage" if simpler.)

9) What’s normal about @login_required?
Keep @login_required on all routes that require an authenticated user.

It’s not redundant with permission checks: login answers “who are you?”; permission answers “are you allowed?”

For endpoints the front-end pings anonymously (e.g., /api/server-time), either make them public or rely on the JSON unauthorized handler.

10) When to remove shims?
Not in PR3. Leave them through a short soak. In PR4, once logs show nothing hits the shims (emit logger.warning("DEPRECATED shim X") from them), delete.

TL;DR confirmation
Your plan is solid; we’ll standardize on your existing permission_required, add any_permission_required and tier_required, wire a JSON-aware unauthorized handler, inject has_permission into Jinja, and thin routes.

No removal of Google Auth, roles, or tiers. We’re hardening and making enforcement uniform.

Minimal diffs, immediate wins (no more 302 noise; clean route guards; predictable template gating).

If you want, paste your current app/utils/permissions.py and User model snippets—I can give you a drop-in patch that matches your exact structure.









Sources

Ask ChatGPT
