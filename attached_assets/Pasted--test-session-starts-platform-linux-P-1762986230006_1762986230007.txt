============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 2 items                                                              

tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_and_deduct_fifo_mode FAILED [ 50%]
tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_average_mode FAILED [100%]

=================================== FAILURES ===================================
_ TestInventoryCostingToggleAndWAC.test_wac_updates_after_restock_and_deduct_fifo_mode _

self = <sqlalchemy.engine.base.Connection object at 0x7f921198e3d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f9219213c50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f921199fb50>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f921199fc50>
parameters = [('Olive Oil', None, None, 0.0, 'ml', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f9219213c50>
cursor = <sqlite3.Cursor object at 0x7f92123fe640>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Olive Oil', None, None, 0.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f921199fb50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_fragrance_load_pct

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_costing_toggle.TestInventoryCostingToggleAndWAC object at 0x7f92191c5110>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f9219c5ca90>
test_user = <User testuser_1762985842330578>, test_org = <Organization 3>

    def test_wac_updates_after_restock_and_deduct_fifo_mode(self, app, db_session, test_user, test_org):
        with app.test_request_context():
            # Ensure org is in FIFO mode
            test_org.inventory_cost_method = 'fifo'
            db_session.add(test_org)
    
            login_user(test_user)
    
            # Create an ingredient
            item = InventoryItem(
                name="Olive Oil",
                type="ingredient",
                unit="ml",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id,
                cost_per_unit=0.0
            )
            db_session.add(item)
>           db_session.flush()

tests/test_inventory_costing_toggle.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f9219213c50>
cursor = <sqlite3.Cursor object at 0x7f92123fe640>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Olive Oil', None, None, 0.0, 'ml', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f921199fb50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_fragrance_load_pct
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Olive Oil', None, None, 0.0, 'ml', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, 2, '2025-11-12 22:17:22.377938', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   âœ… brewing_diastatic_power_lintner column added successfully
   âœ… brewing_potential_sg column added successfully
   âœ… brewing_color_srm column added successfully
   âœ… protein_content_pct column added successfully
   âœ… certifications column added successfully
   âœ… inci_name column added successfully
   âœ… recommended_fragrance_load_pct column added successfully
   âœ… recommended_usage_rate column added successfully
   âœ… is_active_ingredient column added successfully
   âœ… certifications column added successfully
   âœ… fatty_acid_profile column added successfully
   âœ… brewing_diastatic_power_lintner column added successfully
   âœ… brewing_potential_sg column added successfully
   âœ… brewing_color_srm column added successfully
   âœ… protein_content_pct column added successfully
   âœ… inci_name column added successfully
   âœ… recommended_fragrance_load_pct column added successfully
   âœ… recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
------------------------------ Captured log setup ------------------------------
INFO     app:blueprints_registry.py:352 === Blueprint Registration Summary ===
INFO     app:blueprints_registry.py:353 Successful: 28
INFO     app:blueprints_registry.py:356    - Authentication
INFO     app:blueprints_registry.py:356    - Admin
INFO     app:blueprints_registry.py:356    - Developer
INFO     app:blueprints_registry.py:356    - Inventory
INFO     app:blueprints_registry.py:356    - Recipes
INFO     app:blueprints_registry.py:356    - Batches
INFO     app:blueprints_registry.py:356    - Organization
INFO     app:blueprints_registry.py:356    - Billing
INFO     app:blueprints_registry.py:356    - Settings
INFO     app:blueprints_registry.py:356    - Timers
INFO     app:blueprints_registry.py:356    - Expiration
INFO     app:blueprints_registry.py:356    - Conversion
INFO     app:blueprints_registry.py:356    - Products Main
INFO     app:blueprints_registry.py:356    - Public API
INFO     app:blueprints_registry.py:356    - Main API
INFO     app:blueprints_registry.py:356    - Drawer Actions
INFO     app:blueprints_registry.py:356    - Retention Drawer API
INFO     app:blueprints_registry.py:356    - Global Link Drawer API
INFO     app:blueprints_registry.py:356    - App Routes
INFO     app:blueprints_registry.py:356    - Legal Routes
INFO     app:blueprints_registry.py:356    - Bulk Stock
INFO     app:blueprints_registry.py:356    - Fault Log
INFO     app:blueprints_registry.py:356    - Tag Manager
INFO     app:blueprints_registry.py:356    - Global Library Public
INFO     app:blueprints_registry.py:356    - Waitlist
INFO     app:blueprints_registry.py:356    - Public Tools
INFO     app:blueprints_registry.py:356    - Production Planning
INFO     app:blueprints_registry.py:356    - Exports
INFO     app:blueprints_registry.py:362 All blueprints registered successfully!
INFO     app:__init__.py:138 ðŸ”’ db.create_all() not enabled; Alembic migrations are the source of truth
_ TestInventoryCostingToggleAndWAC.test_wac_updates_after_restock_average_mode _

self = <sqlalchemy.engine.base.Connection object at 0x7f9210b7b290>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f9212025350>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f9210958f10>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f9210958f50>
parameters = [('Sugar', None, None, 0.0, 'g', 0.0, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f9212025350>
cursor = <sqlite3.Cursor object at 0x7f9210b6e440>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Sugar', None, None, 0.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f9210958f10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: table inventory_item has no column named recommended_fragrance_load_pct

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_costing_toggle.TestInventoryCostingToggleAndWAC object at 0x7f92191c5e90>
app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7f9219c5ca90>
test_user = <User testuser_1762985847065731>, test_org = <Organization 3>

    def test_wac_updates_after_restock_average_mode(self, app, db_session, test_user, test_org):
        with app.test_request_context():
            # Switch org to Average mode
            test_org.inventory_cost_method = 'average'
            db_session.add(test_org)
    
            login_user(test_user)
    
            # Create an ingredient
            item = InventoryItem(
                name="Sugar",
                type="ingredient",
                unit="g",
                quantity=0.0,
                organization_id=test_org.id,
                created_by=test_user.id,
                cost_per_unit=0.0
            )
            db_session.add(item)
>           db_session.flush()

tests/test_inventory_costing_toggle.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:938: in flush
    return self._proxied.flush(objects=objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f9212025350>
cursor = <sqlite3.Cursor object at 0x7f9210b6e440>
statement = 'INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_thresh..., ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Sugar', None, None, 0.0, 'g', 0.0, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f9210958f10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory_item has no column named recommended_fragrance_load_pct
E       [SQL: INSERT INTO inventory_item (name, category_id, inventory_category_id, quantity, unit, cost_per_unit, low_stock_threshold, density, type, is_active, is_archived, is_perishable, shelf_life_days, expiration_date, capacity, capacity_unit, container_material, container_type, container_style, container_color, created_by, created_at, reference_item_name, density_source, intermediate, saponification_value, iodine_value, melting_point_c, flash_point_c, ph_value, moisture_content_percent, comedogenic_rating, recommended_fragrance_load_pct, inci_name, protein_content_pct, brewing_color_srm, brewing_potential_sg, brewing_diastatic_power_lintner, global_item_id, ownership, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Sugar', None, None, 0.0, 'g', 0.0, 0.0, None, 'ingredient', 1, 0, 0, None, None, None, None, None, None, None, None, 2, '2025-11-12 22:17:27.102189', None, 'manual', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'org', 3)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
---------------------------- Captured stdout setup -----------------------------
   âœ… brewing_diastatic_power_lintner column added successfully
   âœ… brewing_potential_sg column added successfully
   âœ… brewing_color_srm column added successfully
   âœ… protein_content_pct column added successfully
   âœ… certifications column added successfully
   âœ… inci_name column added successfully
   âœ… recommended_fragrance_load_pct column added successfully
   âœ… recommended_usage_rate column added successfully
   âœ… is_active_ingredient column added successfully
   âœ… certifications column added successfully
   âœ… fatty_acid_profile column added successfully
   âœ… brewing_diastatic_power_lintner column added successfully
   âœ… brewing_potential_sg column added successfully
   âœ… brewing_color_srm column added successfully
   âœ… protein_content_pct column added successfully
   âœ… inci_name column added successfully
   âœ… recommended_fragrance_load_pct column added successfully
   âœ… recommended_usage_rate column added successfully
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.env] Imported model module: app.models.addon
INFO  [alembic.env] Imported model module: app.models.batch
INFO  [alembic.env] Imported model module: app.models.billing_snapshot
INFO  [alembic.env] Imported model module: app.models.category
INFO  [alembic.env] Imported model module: app.models.developer_permission
INFO  [alembic.env] Imported model module: app.models.developer_role
INFO  [alembic.env] Imported model module: app.models.domain_event
INFO  [alembic.env] Imported model module: app.models.feature_flag
INFO  [alembic.env] Imported model module: app.models.freshness_snapshot
INFO  [alembic.env] Imported model module: app.models.global_item
INFO  [alembic.env] Imported model module: app.models.global_item_alias
INFO  [alembic.env] Imported model module: app.models.inventory
INFO  [alembic.env] Imported model module: app.models.inventory_lot
INFO  [alembic.env] Imported model module: app.models.mixins
INFO  [alembic.env] Imported model module: app.models.models
INFO  [alembic.env] Imported model module: app.models.permission
INFO  [alembic.env] Imported model module: app.models.pricing_snapshot
INFO  [alembic.env] Imported model module: app.models.product
INFO  [alembic.env] Imported model module: app.models.product_category
INFO  [alembic.env] Imported model module: app.models.recipe
INFO  [alembic.env] Imported model module: app.models.reservation
INFO  [alembic.env] Imported model module: app.models.retention
INFO  [alembic.env] Imported model module: app.models.role
INFO  [alembic.env] Imported model module: app.models.statistics
INFO  [alembic.env] Imported model module: app.models.stripe_event
INFO  [alembic.env] Imported model module: app.models.subscription_tier
INFO  [alembic.env] Imported model module: app.models.unified_inventory_history
INFO  [alembic.env] Imported model module: app.models.unit
INFO  [alembic.env] Imported model module: app.models.user_preferences
INFO  [alembic.env] Imported model module: app.models.user_role_assignment
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 0001_base_schema, 0001 base schema (tables only)
INFO  [alembic.runtime.migration] Running upgrade 0001_base_schema -> 0002_constraints_indexes_fks, 0002 add constraints/indexes/fks
INFO  [alembic.runtime.migration] Running upgrade 0002_constraints_indexes_fks -> 0003_postgres_specific, 0003 postgres-specific extensions/enums/indexes
INFO  [alembic.runtime.migration] Running upgrade 0003_postgres_specific -> 0004_seed_presets, 0004 seed presets (guarded)
INFO  [alembic.runtime.migration] Running upgrade 0004_seed_presets -> 0005_cleanup_guardrails, 0005 cleanup guardrails and ingredient attribute expansion
=============================== warnings summary ===============================
tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_and_deduct_fifo_mode
tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_average_mode
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_and_deduct_fifo_mode - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
FAILED tests/test_inventory_costing_toggle.py::TestInventoryCostingToggleAndWAC::test_wac_updates_after_restock_average_mode - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table inventory...
======================== 2 failed, 2 warnings in 12.24s =====