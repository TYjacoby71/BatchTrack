============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.3.5, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
collected 49 items                                                             

tests/test_audit_canonicalization.py::test_api_reservation_routes_uses_canonical_audit PASSED [  2%]
tests/test_audit_canonicalization.py::test_products_routes_uses_canonical_audit PASSED [  4%]
tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_decorator_allows_with_permission PASSED [  6%]
tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_returns_json_for_api FAILED [  8%]
tests/test_auth_permissions.py::TestAuthPermissions::test_any_permission_required_decorator PASSED [ 10%]
tests/test_auth_permissions.py::TestAuthPermissions::test_tier_required_decorator PASSED [ 12%]
tests/test_auth_permissions.py::TestAuthPermissions::test_user_has_any_permission_method PASSED [ 14%]
tests/test_auth_permissions.py::TestAuthPermissions::test_api_unauth_returns_json_401 FAILED [ 16%]
tests/test_auth_permissions.py::TestAuthPermissions::test_web_unauth_redirects_to_login PASSED [ 18%]
tests/test_auth_permissions.py::TestAuthPermissions::test_csrf_token_available_in_templates PASSED [ 20%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling PASSED [ 22%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[active-200] PASSED [ 24%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] FAILED [ 26%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] FAILED [ 28%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] FAILED [ 30%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_developer_can_masquerade_regardless_of_billing PASSED [ 32%]
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_complete_security_cascade PASSED [ 34%]
tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment PASSED [ 36%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_fifo_expired_calls_canonical_service PASSED [ 38%]
tests/test_expiration_canonicalization.py::TestExpirationCanonicalService::test_mark_product_expired_calls_canonical_service PASSED [ 40%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_exists PASSED [ 42%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_login_endpoint_exists PASSED [ 44%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_auth_callback_endpoint_exists PASSED [ 46%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_state_validation_path PASSED [ 48%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_service_methods_exist PASSED [ 51%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_configuration_status PASSED [ 53%]
tests/test_google_oauth.py::TestGoogleOAuthCharacterization::test_oauth_callback_invalid_state PASSED [ 55%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_single_entry_point_exists PASSED [ 57%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order PASSED [ 59%]
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly PASSED [ 61%]
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service FAILED [ 63%]
tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service FAILED [ 65%]
tests/test_pos_integration_canonicalization.py::test_pos_sale_uses_canonical_service PASSED [ 67%]
tests/test_pos_integration_canonicalization.py::TestPOSIntegrationCanonicalService::test_reserve_inventory_calls_canonical_service PASSED [ 69%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_creation_flow PASSED [ 71%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_generation_constraints PASSED [ 73%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_product_service_exists PASSED [ 75%]
tests/test_product_sku.py::TestProductSKUCharacterization::test_sku_creation_validation PASSED [ 77%]
tests/test_reservation_canonicalization.py::test_credit_specific_lot_called_on_reservation_release PASSED [ 79%]
tests/test_reservation_canonicalization.py::test_record_audit_entry_called_for_unreserved_audit PASSED [ 81%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_endpoint_exists PASSED [ 83%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_tier_bypass_behavior PASSED [ 85%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_organization_tier_assignment PASSED [ 87%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_permission_gating_exists PASSED [ 89%]
tests/test_signup_tiers.py::TestSignupTierCharacterization::test_signup_service_delegation PASSED [ 91%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_exists PASSED [ 93%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_signature_verification_path_exists PASSED [ 95%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_webhook_idempotency_behavior PASSED [ 97%]
tests/test_stripe_webhooks.py::TestStripeWebhookCharacterization::test_stripe_service_methods_exist PASSED [100%]

=================================== FAILURES ===================================
______ TestAuthPermissions.test_permission_required_returns_json_for_api _______

self = <tests.test_auth_permissions.TestAuthPermissions object at 0x7fe6ef9b77d0>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>

    def test_permission_required_returns_json_for_api(self, app, client):
        """Test that API endpoints return JSON when permission denied"""
        with app.app_context():
            @app.route('/api/test-perm')
            @permission_required('test.permission')
            def api_test_route():
                return {'status': 'success'}
    
            response = client.get('/api/test-perm')
            # Should return JSON unauthorized response
>           assert response.status_code == 401
E           assert 200 == 401
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_auth_permissions.py:33: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
_____________ TestAuthPermissions.test_api_unauth_returns_json_401 _____________

self = <tests.test_auth_permissions.TestAuthPermissions object at 0x7fe6ef9c5450>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>

    def test_api_unauth_returns_json_401(self, app, client):
        """Test that API endpoints return 401 JSON when unauthorized"""
        with app.app_context():
            @app.route("/api/_perm_test")
            @permission_required("some.permission")
            def _p():
                return {"ok": True}
    
            resp = client.get("/api/_perm_test", headers={"Accept": "application/json"})
>           assert resp.status_code == 401
E           assert 200 == 401
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_auth_permissions.py:77: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
_ TestBillingAndTierEnforcement.test_billing_status_enforcement[past_due-302] __

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7fe6ef9d1390>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755287285564775>, billing_status = 'past_due'
expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client:
                with client.session_transaction() as sess:
                    sess['_user_id'] = str(test_user.id)
                    sess['_fresh'] = True
    
                response = client.get('/_protected_dashboard')
    
                # ASSERT
>               assert response.status_code == expected_status_code
E               assert 200 == 302
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:103: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
_ TestBillingAndTierEnforcement.test_billing_status_enforcement[suspended-302] _

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7fe6ef9d14d0>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755287286791333>, billing_status = 'suspended'
expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client:
                with client.session_transaction() as sess:
                    sess['_user_id'] = str(test_user.id)
                    sess['_fresh'] = True
    
                response = client.get('/_protected_dashboard')
    
                # ASSERT
>               assert response.status_code == expected_status_code
E               assert 200 == 302
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:103: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
_ TestBillingAndTierEnforcement.test_billing_status_enforcement[canceled-302] __

self = <tests.test_billing_and_tier_enforcement.TestBillingAndTierEnforcement object at 0x7fe6ef9d1610>
app = <Flask 'app'>, client = <FlaskClient <Flask 'app'>>
test_user = <User testuser_1755287288374046>, billing_status = 'canceled'
expected_status_code = 302

    @pytest.mark.parametrize("billing_status, expected_status_code", [
        ('active', 200),
        ('past_due', 302),
        ('suspended', 302),
        ('canceled', 302),
    ])
    def test_billing_status_enforcement(self, app, client, test_user, billing_status, expected_status_code):
        """
        Tests that the billing middleware blocks access for non-active billing statuses.
        """
        with app.app_context():
            # ARRANGE
            # Update the user's organization with the test billing status
            org = test_user.organization
            org.billing_status = billing_status
            db.session.commit()
    
            # Create a simple protected route to test against
            @app.route('/_protected_dashboard')
            def _protected_dashboard():
                return "Welcome to the dashboard", 200
    
            # ACT
            # Log the user in and try to access the protected route
            with client:
                with client.session_transaction() as sess:
                    sess['_user_id'] = str(test_user.id)
                    sess['_fresh'] = True
    
                response = client.get('/_protected_dashboard')
    
                # ASSERT
>               assert response.status_code == expected_status_code
E               assert 200 == 302
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_billing_and_tier_enforcement.py:103: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
________________ test_recount_adjustment_uses_canonical_service ________________

client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>
db_session = <sqlalchemy.orm.scoping.scoped_session object at 0x7fe6f0101a90>
test_user = <User testuser_1755287307201754>

    def test_recount_adjustment_uses_canonical_service(client, app, db_session, test_user):
        """Test that inventory recount routes use the canonical adjustment service"""
    
        with app.test_request_context():
            # Create test inventory item
            item = InventoryItem(
                name="Test Item",
                quantity=100,
                unit="count",
                organization_id=test_user.organization_id
            )
            db_session.add(item)
            db_session.commit()
    
            # Log in the user for the test
            with client.session_transaction() as sess:
                sess['_user_id'] = str(test_user.id)
                sess['_fresh'] = True
    
            # Mock the canonical service
            with patch('app.services.inventory_adjustment.process_inventory_adjustment') as mock_adjustment:
                mock_adjustment.return_value = True
    
                # Make recount request
                response = client.post(f'/inventory/adjust/{item.id}', data={
                    'adjustment_type': 'recount',
                    'quantity': '80',
                    'notes': 'Physical count adjustment'
                })
    
                # Verify canonical service was called
>               mock_adjustment.assert_called_once()

tests/test_inventory_routes_canonicalization.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='process_inventory_adjustment' id='140629784116560'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'process_inventory_adjustment' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
----------------------------- Captured stdout call -----------------------------
RECOUNT: Test Item - FIFO total: 0, target: 80.0, delta: 80.0
------------------------------ Captured log call -------------------------------
INFO     app.services.inventory_adjustment._core:_core.py:33 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=80.0, change_type=recount, caller=app/blueprints/inventory/routes.py:adjust_inventory
INFO     app.services.inventory_adjustment._core:_core.py:44 RECOUNT: Processing recount from 100.0 to 80.0
INFO     app.services.inventory_adjustment._core:_core.py:33 CANONICAL INVENTORY ADJUSTMENT: item_id=1, quantity=80.0, change_type=restock, caller=app/services/inventory_adjustment/_recount_logic.py:handle_recount_adjustment
INFO     app.services.inventory_adjustment._fifo_ops:_fifo_ops.py:237 FIFO: Updating inventory item 1 quantity: 100.0 → 180.0
ERROR    app.services.inventory_adjustment._audit:_audit.py:107 Failed to record audit entry for item 1: (builtins.ValueError) could not convert string to float: 'Physical count adjustment - Added 80.0'
[SQL: INSERT INTO unified_inventory_history (inventory_item_id, timestamp, change_type, quantity_change, unit, unit_cost, remaining_quantity, fifo_reference_id, fifo_code, batch_id, created_by, notes, quantity_used, used_for_batch_id, is_perishable, shelf_life_days, expiration_date, location_id, location_name, temperature_at_time, quality_status, compliance_status, quality_checked_by, customer, sale_price, order_id, reservation_id, is_reserved, sale_location, marketplace_order_id, marketplace_source, batch_number, lot_number, container_id, fifo_source, organization_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
[parameters: [{'quantity_change': 'Physical count adjustment - Added 80.0', 'change_type': 'restock', 'unit': 'count', 'remaining_quantity': 0.0, 'inventory_item_id ... (543 characters truncated) ... vation_id': None, 'lot_number': None, 'location_name': None, 'sale_location': None, 'shelf_life_days': None, 'location_id': None, 'fifo_source': None}]]
_ TestInventoryRoutesCanonicalService.test_adjust_inventory_initial_stock_calls_canonical_service _

self = <sqlalchemy.engine.base.Connection object at 0x7fe6ec3e1890>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fe6e7c6aad0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fe6ec3e28d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7fe6ec3e3910>
parameters = [(1,)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fe6e7c6aad0>
cursor = <sqlite3.Cursor object at 0x7fe6e760a2c0>
statement = 'SELECT user.id AS user_id, user.username AS user_username, user.password_hash AS user_password_hash, user.first_name ...ser_deleted_at, user.deleted_by AS user_deleted_by, user.is_deleted AS user_is_deleted \nFROM user \nWHERE user.id = ?'
parameters = (1,)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fe6ec3e28d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: user

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_inventory_routes_canonicalization.TestInventoryRoutesCanonicalService object at 0x7fe6ef407ed0>
mock_user = <AsyncMock name='current_user' id='140629703389968'>
mock_item = <MagicMock name='InventoryItem' id='140629710361424'>
mock_process = <MagicMock name='process_inventory_adjustment' id='140629782187344'>
client = <FlaskClient <Flask 'app'>>, app = <Flask 'app'>

    @patch('app.services.inventory_adjustment.process_inventory_adjustment')
    @patch('app.blueprints.inventory.routes.InventoryItem')
    @patch('app.blueprints.inventory.routes.current_user')
    def test_adjust_inventory_initial_stock_calls_canonical_service(self, mock_user, mock_item, mock_process, client, app):
        """Test that initial stock creation calls process_inventory_adjustment"""
        with app.test_request_context():
            # Mock the inventory item with no history
            mock_inventory_item = MagicMock()
            mock_inventory_item.id = 1
            mock_inventory_item.type = 'ingredient'
            mock_inventory_item.unit = 'g'
            mock_inventory_item.cost_per_unit = 2.5
            mock_inventory_item.is_perishable = False
            mock_inventory_item.organization_id = 1
    
            mock_item.query.get_or_404.return_value = mock_inventory_item
            mock_user.id = 1
            mock_user.organization_id = 1
            mock_process.return_value = True
    
            # Log in the mock user for the test
            with client.session_transaction() as sess:
                sess['_user_id'] = str(mock_user.id)
                sess['_fresh'] = True
    
            # Mock UnifiedInventoryHistory count to simulate no existing history
            with patch('app.blueprints.inventory.routes.UnifiedInventoryHistory') as mock_history:
                mock_history.query.filter_by.return_value.count.return_value = 0
    
                # Make POST request to adjust inventory
>               response = client.post('/inventory/adjust/1', data={
                    'adjustment_type': 'restock',
                    'quantity': '100.0',
                    'input_unit': 'g',
                    'notes': 'Initial stock',
                    'cost_entry_type': 'per_unit',
                    'cost_per_unit': '3.0'
                })

tests/test_inventory_routes_canonicalization.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
.pythonlibs/lib/python3.11/site-packages/flask/testing.py:235: in open
    response = super().open(
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
.pythonlibs/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
.pythonlibs/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
.pythonlibs/lib/python3.11/site-packages/flask/app.py:915: in full_dispatch_request
    rv = self.preprocess_request()
.pythonlibs/lib/python3.11/site-packages/flask/app.py:1291: in preprocess_request
    rv = self.ensure_sync(before_func)()
app/middleware.py:25: in billing_enforcement
    if not current_user.is_authenticated:
.pythonlibs/lib/python3.11/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
.pythonlibs/lib/python3.11/site-packages/werkzeug/local.py:526: in _get_current_object
    return get_name(local())
.pythonlibs/lib/python3.11/site-packages/flask_login/utils.py:25: in <lambda>
    current_user = LocalProxy(lambda: _get_user())
.pythonlibs/lib/python3.11/site-packages/flask_login/utils.py:370: in _get_user
    current_app.login_manager._load_user()
.pythonlibs/lib/python3.11/site-packages/flask_login/login_manager.py:364: in _load_user
    user = self._user_callback(user_id)
app/authz.py:23: in load_user
    user = app.extensions['sqlalchemy'].session.get(User, int(user_id))
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/scoping.py:1058: in get
    return self._proxied.get(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3694: in get
    return self._get_impl(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3874: in _get_impl
    return db_load_fn(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/loading.py:694: in load_on_pk_identity
    session.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7fe6e7c6aad0>
cursor = <sqlite3.Cursor object at 0x7fe6e760a2c0>
statement = 'SELECT user.id AS user_id, user.username AS user_username, user.password_hash AS user_password_hash, user.first_name ...ser_deleted_at, user.deleted_by AS user_deleted_by, user.is_deleted AS user_is_deleted \nFROM user \nWHERE user.id = ?'
parameters = (1,)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7fe6ec3e28d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: user
E       [SQL: SELECT user.id AS user_id, user.username AS user_username, user.password_hash AS user_password_hash, user.first_name AS user_first_name, user.last_name AS user_last_name, user.email AS user_email, user.phone AS user_phone, user.organization_id AS user_organization_id, user.user_type AS user_user_type, user.is_organization_owner AS user_is_organization_owner, user.is_active AS user_is_active, user.created_at AS user_created_at, user.last_login AS user_last_login, user.timezone AS user_timezone, user.email_verified AS user_email_verified, user.email_verification_token AS user_email_verification_token, user.email_verification_sent_at AS user_email_verification_sent_at, user.oauth_provider AS user_oauth_provider, user.oauth_provider_id AS user_oauth_provider_id, user.password_reset_token AS user_password_reset_token, user.password_reset_sent_at AS user_password_reset_sent_at, user.deleted_at AS user_deleted_at, user.deleted_by AS user_deleted_by, user.is_deleted AS user_is_deleted 
E       FROM user 
E       WHERE user.id = ?]
E       [parameters: (1,)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.pythonlibs/lib/python3.11/site-packages/sqlalchemy/engine/default.py:945: OperationalError
------------------------------ Captured log setup ------------------------------
INFO     app.blueprints_registry:blueprints_registry.py:123 Blueprint 'billing' registered successfully.
INFO     app:unit_utils.py:28 BatchTrack startup
=============================== warnings summary ===============================
tests/test_audit_canonicalization.py: 2 warnings
tests/test_auth_permissions.py: 8 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 3 warnings
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 2 warnings
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_limiter/extension.py:333: UserWarning: Using the in-memory storage for tracking rate limits as no storage was explicitly specified. This is not recommended for production use. See: https://flask-limiter.readthedocs.io#configuring-a-storage-backend for documentation about configuring the storage backend.
    warnings.warn(

tests/test_audit_canonicalization.py: 2 warnings
tests/test_auth_permissions.py: 8 warnings
tests/test_billing_and_tier_enforcement.py: 7 warnings
tests/test_expiration_canonicalization.py: 1 warning
tests/test_google_oauth.py: 7 warnings
tests/test_inventory_fifo.py: 3 warnings
tests/test_inventory_routes_canonicalization.py: 1 warning
tests/test_pos_integration_canonicalization.py: 1 warning
tests/test_product_sku.py: 4 warnings
tests/test_reservation_canonicalization.py: 2 warnings
tests/test_signup_tiers.py: 5 warnings
tests/test_stripe_webhooks.py: 4 warnings
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/extension.py:881: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: batch, product_sku; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    getattr(metadata, op_name)(bind=engine)

tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling
tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_tier_permission_is_the_hard_ceiling
  /home/runner/workspace/app/models/models.py:323: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    role = Role.query.get(assignment.role_id)

tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_developer_can_masquerade_regardless_of_billing
  /home/runner/workspace/app/middleware.py:39: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    g.effective_org = Organization.query.get(selected_org_id)

tests/test_expiration_canonicalization.py::test_expiration_service_uses_canonical_adjustment
  /home/runner/workspace/app/blueprints/expiration/services.py:545: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    entry = InventoryHistory.query.get(entry_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_inventory_adjustment_delegates_properly
tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/app/services/inventory_adjustment/_audit.py:77: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

tests/test_inventory_fifo.py::TestInventoryFIFOCharacterization::test_fifo_deduction_order
  /home/runner/workspace/app/services/stock_check.py:71: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(inventory_item_id)

tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/flask_sqlalchemy/query.py:30: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    rv = self.get(ident)

tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service
  /home/runner/workspace/app/services/inventory_adjustment/_recount_logic.py:20: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    item = InventoryItem.query.get(item_id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_auth_permissions.py::TestAuthPermissions::test_permission_required_returns_json_for_api - assert 200 == 401
FAILED tests/test_auth_permissions.py::TestAuthPermissions::test_api_unauth_returns_json_401 - assert 200 == 401
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[past_due-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[suspended-302] - assert 200 == 302
FAILED tests/test_billing_and_tier_enforcement.py::TestBillingAndTierEnforcement::test_billing_status_enforcement[canceled-302] - assert 200 == 302
FAILED tests/test_inventory_routes_canonicalization.py::test_recount_adjustment_uses_canonical_service - AssertionError: Expected 'process_inventory_adjustment' to have been called...
FAILED tests/test_inventory_routes_canonicalization.py::TestInventoryRoutesCanonicalService::test_adjust_inventory_initial_stock_calls_canonical_service - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: ...
============ 7 failed, 42 passed, 105 warnings in 67.10s (0:01:07) =============
