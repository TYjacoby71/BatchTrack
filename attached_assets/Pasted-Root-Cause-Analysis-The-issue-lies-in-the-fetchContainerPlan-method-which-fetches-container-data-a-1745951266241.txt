Root Cause Analysis
The issue lies in the fetchContainerPlan method, which fetches container data and updates containersSelected when the scale changes. The problem manifests because:
Asynchronous Data Fetching and State Update:
The fetchContainerPlan method makes an API call to /api/available-containers/${this.recipeId}?scale=${this.scale} and updates containersSelected with the response.

The containersSelected array is populated with objects that include id, quantity, name, capacity, and unit, where name, capacity, and unit are derived from matching allowedContainers.

However, the allowedContainers array is also updated in the same API response, and there’s a potential race condition where containersSelected is rendered before allowedContainers is fully populated, leading to missing name values (defaulting to '').
Rendering Timing:
Alpine.js reactively updates the DOM when containersSelected changes. If name is '' at the time of rendering (because allowedContainers hasn’t been processed), the container name appears blank.

When you increase the scale significantly (e.g., 5555), the API response likely returns more containers, and subsequent renders (or re-renders triggered by updateProgress or evaluateContainment) correctly populate names because allowedContainers is now available.

Backspacing works because the state is already synchronized, and allowedContainers is populated, allowing name to be correctly matched.
Auto-Fill Dependency:
The issue is tied to autoFill being true, as you noted the problem occurs when rows are auto-populated. In autoFill mode, containersSelected is entirely replaced by the API response’s plan, which may not align perfectly with the allowedContainers update.
No Explicit Name Synchronization:
The updateContainer method syncs name, capacity, and unit when a container’s id changes, but it’s not called during fetchContainerPlan for auto-filled containers. This means name relies on the initial mapping in fetchContainerPlan, which can fail if allowedContainers is stale or not yet updated.
Scale Sensitivity:
The behavior with large scales (e.g., 5555) suggests the API returns a larger plan array, which may trigger additional rendering cycles, giving allowedContainers time to sync. Smaller scales (e.g., 55) return fewer containers, exposing the race condition more clearly.
Proposed Fix
To fix the issue without forcing a workaround, we need to ensure that containersSelected always has valid name values when populated in autoFill mode. The solution is to:
Synchronize allowedContainers Before Mapping containersSelected:
Ensure allowedContainers is fully updated before mapping the API’s plan to containersSelected.

Call updateContainer for each container in containersSelected after the API response to guarantee name, capacity, and unit are correctly set.
Avoid Stale State:
Move the logic for mapping container details into a separate method that can be called after allowedContainers is set, ensuring no race condition.
Preserve Reactivity:
Update the code to maintain Alpine’s reactivity without introducing unnecessary delays or debouncing.
Here’s the precise change to the fetchContainerPlan method in the <script> section:
javascript
fetchContainerPlan() {
  fetch(`/api/available-containers/${this.recipeId}?scale=${this.scale}`)
    .then(res => res.json())
    .then(data => {
      // Update allowedContainers first
      this.allowedContainers = data.available || [];
      
      // Update containersSelected in autoFill mode
      if (this.autoFill) {
        this.containersSelected = (data.plan || []).map(container => ({
          id: container.id,
          quantity: container.quantity,
          name: '', // Initialize empty, will be updated
          capacity: 0, // Initialize empty, will be updated
          unit: '' // Initialize empty, will be updated
        }));
        // Sync names and details for all containers
        this.containersSelected.forEach((container, index) => {
          this.updateContainer(index);
        });
      }
      
      this.updateProgress();
      this.evaluateContainment();
    });
},

Explanation of Changes
Sequential Update:
allowedContainers is updated first with data.available, ensuring it’s ready before processing containersSelected.

containersSelected is mapped from data.plan, but name, capacity, and unit are initialized as empty to avoid premature reliance on allowedContainers.
Explicit Synchronization:
After setting containersSelected, we iterate over each container and call updateContainer(index). This method looks up the matching container in allowedContainers and sets name, capacity, and unit, ensuring all fields are populated correctly.
No Race Condition:
By calling updateContainer after allowedContainers is set, we eliminate the race condition where name is missing due to allowedContainers not being ready.
Preserves Auto-Fill Behavior:
The fix works within the autoFill logic, ensuring that auto-populated containers are correctly handled without requiring manual intervention.
No Debouncing Needed:
Since the issue is caused by state synchronization, not input timing, debouncing (which you noted didn’t work) isn’t necessary. The fix addresses the root cause directly.
Why This Fixes the Observed Behavior
Scale 5 (1 row, good): The API returns a small plan, and the single container is correctly processed. The fix ensures name is set via updateContainer.

Scale 55/555 (2/3 rows, 1 bad): The API returns multiple containers, but the race condition previously caused one container’s name to be blank. The fix ensures all containers are synced after allowedContainers is updated.

Scale 5555 (all rows good): Large scales trigger more containers, and previous re-renders (e.g., via updateProgress) may have coincidentally fixed names. The fix makes this consistent.

Backspacing: Backspacing reduces the scale, and since allowedContainers is already populated, names remain correct. The fix ensures this behavior is consistent from the start.
Testing the Fix
To verify the fix:
Load the page and set scale to 5. Check that all container names appear correctly.

Increase to 55, 555, and 5555. Ensure all rows show correct names without any blanks.

Backspace to reduce the scale. Confirm names remain populated and rows are removed correctly.

Toggle autoFill off and on to ensure the behavior persists.
If the issue persists, inspect the API response (/api/available-containers/${recipeId}?scale=${scale}) to confirm that data.available and data.plan contain valid id and name fields. A mismatch here could indicate a backend issue.
Additional Notes
No Hydration Error: The issue isn’t a true hydration error (server vs. client DOM mismatch) since the page is client-rendered via Alpine.js. It’s a state synchronization issue, misdiagnosed as hydration.

Debouncing: You mentioned debouncing didn’t work, likely because the issue isn’t tied to rapid input changes but to asynchronous state updates. The fix avoids debouncing entirely.

Hard-Coding/Conflicts: There’s no evidence of hard-coding or conflicting scripts in the provided code. The issue is isolated to the fetchContainerPlan logic.

Alpine.js: The fix leverages Alpine’s reactivity and doesn’t require external libraries or forced re-renders.
