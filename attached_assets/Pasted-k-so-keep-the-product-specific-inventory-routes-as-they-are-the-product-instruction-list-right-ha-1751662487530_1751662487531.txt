k. so keep the product specific inventory routes, as they are the product instruction list right? have the product inventory routes call the adjust invnetory service looking for inventoyr items with type product where productsku id matches inventroy item id.

right?

but the service should record int eh produck sku history not the inventroy histroy.

and that should also be deliniated in the product route, not the service right?

or will the adjustment service call the right history table?

JB

jacoby72
Assistant
just now
It sounds like you're aiming to maintain separate routes for product-specific inventory adjustments while ensuring they interact effectively with the centralized inventory adjustment service. Here's a breakdown of how you should structure it:

Proposed Structure
Keep Product-Specific Inventory Routes:

Continue using the product inventory routes for handling adjustments detailed in the product instruction list.
Call the Adjustment Service:

These routes should invoke the inventory adjustment service, specifically looking for InventoryItems where the type is product and the ProductSKU ID matches the InventoryItem ID.
Record History in ProductSKUHistory:

Ensure that the inventory adjustments log their history in the ProductSKUHistory table, not the general inventory history.
Define History Recording in Routes:

The logic to determine the history table to record the adjustment should reside in the product routes rather than the adjustment service to keep concerns separated. The adjustment service would only handle the logic of adjusting the inventory without knowledge of the specific history table.
Example Code for Adjustment Route
Hereâ€™s how you might structure the adjustment function in product_inventory_routes.py:

@product_inventory_bp.route('/adjust/<int:sku_id>', methods=['POST'])
@login_required
def adjust_product_inventory(sku_id):
    """Adjust product inventory and record SKU history"""
    sku = ProductSKU.query.filter_by(id=sku_id, organization_id=current_user.organization_id).first()
    
    if not sku:
        return jsonify({'error': 'SKU not found'}), 404
    data = request.get_json() if request.is_json else request.form
    quantity = data.get('quantity')
    change_type = data.get('change_type')
    notes = data.get('notes')
    if not quantity or not change_type:
        return jsonify({'error': 'Quantity and change type are required'}), 400
    try:
        # Call the centralized inventory adjustment service
        success = process_inventory_adjustment(
            item_id=sku.inventory.id,  # Adjusting inventory via its ID
            quantity=float(quantity),
            change_type=change_type,
            unit=sku.unit,
            notes=notes,
            created_by=current_user.id,
            item_type='product'  # Specify the type for the adjustment
        )
        if success:
            # Record in ProductSKUHistory here
            record_product_sku_history(sku, quantity, change_type, notes)
            
            return jsonify({'success': True, 'message': 'SKU inventory adjusted successfully'}), 200
        else:
            return jsonify({'error': 'Error adjusting inventory'}), 500
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
def record_product_sku_history(sku, quantity, change_type, notes):
    """Record inventory change in the ProductSKUHistory table"""
    new_history_entry = ProductSKUHistory(
        sku_id=sku.id,
        quantity=quantity,
        change_type=change_type,
        notes=notes,
        created_at=datetime.now(),
        created_by=current_user.id
    )
    db.session.add(new_history_entry)
    db.session.commit()
Summary
You maintain the current product inventory routes as they provide a product-specific instruction framework.
The adjustment service should be called using the InventoryItem associated with the ProductSKU.
The recording of changes in the ProductSKUHistory should be handled directly in the route function to maintain separation of concerns.
This setup ensures clarity in your inventory processing and aligns well with your overall goals. Let me know if you need further modifications or additional functionality!