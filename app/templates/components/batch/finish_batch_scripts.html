<script>
// Global variables
let containerBreakdown = [];
let allowedContainers = [];

// Load variants when product is selected
function loadVariants() {
  const productSelect = document.getElementById('product_id');
  const variantSelect = document.getElementById('variant_id');

  if (!productSelect || !variantSelect) {
    console.log('Product or variant dropdown not found');
    return;
  }

  const productId = productSelect.value;
  console.log('Loading variants for product ID:', productId);

  // Reset variant dropdown
  variantSelect.innerHTML = '<option value="">Loading variants...</option>';
  variantSelect.disabled = true;

  if (!productId) {
    variantSelect.innerHTML = '<option value="">Select product first...</option>';
    return;
  }

  // Fetch variants from API
  fetch(`/products/${productId}/variants`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  })
  .then(data => {
    if (data.status === 'success') {
      variantSelect.innerHTML = '';

      if (data.variants && data.variants.length > 0) {
        data.variants.forEach(variant => {
          const option = document.createElement('option');
          option.value = variant.id;
          option.textContent = variant.name;
          variantSelect.appendChild(option);
        });
        variantSelect.disabled = false;
      } else {
        variantSelect.innerHTML = '<option value="">No variants available</option>';
      }
    } else {
      throw new Error(data.message || 'Failed to load variants');
    }
  })
  .catch(error => {
    console.error('Error loading variants:', error);
    variantSelect.innerHTML = '<option value="">Error loading variants</option>';
  });
}

// Load container breakdown from API
function loadContainers() {
  const batchId = getCurrentBatchId();
  if (!batchId) return;

  fetch(`/api/containers/available/${batchId}`)
    .then(response => response.json())
    .then(data => {
      console.log('Container API response:', data);
      if (data.available) {
        allowedContainers = data.available;
        console.log('Allowed containers:', allowedContainers);
        updateContainerSummary();
      }
    })
    .catch(error => {
      console.error('Error loading containers:', error);
    });
}

// Update container summary and calculate bulk
function updateContainerSummary() {
  const finalQuantityInput = document.getElementById('final_quantity');
  if (!finalQuantityInput) return;

  const totalYield = parseFloat(finalQuantityInput.value) || 0;

  // Get all container inputs
  const containerInputs = document.querySelectorAll('.container-final-input');
  let totalContainerized = 0;

  containerInputs.forEach(input => {
    const quantity = parseFloat(input.value) || 0;
    const containerId = input.dataset.containerId;
    const container = allowedContainers.find(c => c.id == containerId);

    if (container && container.storage_amount) {
      totalContainerized += quantity * container.storage_amount;
    }
  });

  const bulk = totalYield - totalContainerized;

  // Update alerts
  updateYieldAlerts(totalYield, totalContainerized, bulk);
}

// Validate yield distribution
function validateYield() {
  const finalQuantityInput = document.getElementById('final_quantity');
  const alertsContainer = document.getElementById('yield-validation-alerts');
  const hasContainers = document.querySelectorAll('.container-final-input').length > 0;

  if (!finalQuantityInput) {
    return;
  }

  const finalQuantity = parseFloat(finalQuantityInput.value);

  if (!finalQuantity || finalQuantity <= 0) {
    if (alertsContainer) {
      alertsContainer.innerHTML = '';
    }
    updateContainerSummary();
    return;
  }

  // Update display with current yield
  const finalYieldDisplay = document.getElementById('finalYieldDisplay');
  if (finalYieldDisplay) {
    finalYieldDisplay.textContent = finalQuantity.toFixed(2);
  }

  if (!hasContainers) {
    console.log('No containers in batch - all yield goes to bulk');
    updateUncontainedYield(finalQuantity);
    return;
  }

  // Update container summary
  updateContainerSummary();
}

function updateContainerTable(containers, finalQuantity) {
  const tbody = document.getElementById('containerTableBody');
  const totalUsed = document.getElementById('totalUsed');
  const totalPassed = document.getElementById('totalPassed');
  const totalCapacity = document.getElementById('totalCapacity');
  const containerDistribution = document.getElementById('containerDistribution');

  if (!tbody) return;

  let totalContainerUsed = 0;
  let totalContainerPassed = 0;
  let totalContainerCapacity = 0;

  tbody.innerHTML = '';

  containers.forEach(container => {
    const row = document.createElement('tr');
    const used = container.used || 0;
    const passed = container.passed || 0;
    const capacity = container.capacity || 0;

    totalContainerUsed += used;
    totalContainerPassed += passed;
    totalContainerCapacity += capacity;

    row.innerHTML = `
      <td>${container.name}</td>
      <td>${used}</td>
      <td>${passed}</td>
      <td>${capacity}</td>
      <td>${((passed / capacity) * 100).toFixed(1)}%</td>
    `;
    tbody.appendChild(row);
  });

  if (totalUsed) totalUsed.textContent = totalContainerUsed;
  if (totalPassed) totalPassed.textContent = totalContainerPassed;
  if (totalCapacity) totalCapacity.textContent = totalContainerCapacity;

  // Update container distribution display
  if (containerDistribution && finalQuantity > 0) {
    const containerized = totalContainerPassed;
    const bulk = finalQuantity - containerized;
    
    containerDistribution.innerHTML = `
      <div class="alert alert-info">
        <strong>Containerized:</strong> ${containerized.toFixed(2)} units<br>
        <strong>Bulk:</strong> ${bulk.toFixed(2)} units
      </div>
    `;
  }
}

function updateUncontainedYield(finalQuantity) {
  const containerDistribution = document.getElementById('containerDistribution');
  if (containerDistribution) {
    containerDistribution.innerHTML = `
      <div class="alert alert-info">
        <strong>All Bulk:</strong> ${finalQuantity.toFixed(2)} units (no containers in this batch)
      </div>
    `;
  }
}

// Update yield distribution alerts
function updateYieldAlerts(totalYield, containerized, bulk) {
  const alertsContainer = document.getElementById('yield-alerts');
  if (!alertsContainer) return;

  let alertHtml = '';

  if (totalYield > 0) {
    if (containerized > 0) {
      alertHtml += `
      <div class="alert alert-success alert-sm mb-1">
        <i class="fas fa-box me-1"></i>
        <strong>Containerized:</strong> ${containerized.toFixed(2)} units will be packaged in containers.
      </div>`;
    }

    if (bulk > 0) {
      alertHtml += `
      <div class="alert alert-info alert-sm mb-1">
        <i class="fas fa-info-circle me-1"></i>
        <strong>Bulk Product:</strong> ${bulk.toFixed(2)} units will be stored as bulk product.
      </div>`;
    }
  }

  alertsContainer.innerHTML = alertHtml;
}

// Shelf life functions
function toggleShelfLife() {
  const isPerishableCheckbox = document.getElementById('is_perishable');
  const shelfLifeField = document.getElementById('shelfLifeField');

  if (!isPerishableCheckbox || !shelfLifeField) return;

  const isPerishable = isPerishableCheckbox.checked;
  shelfLifeField.style.display = isPerishable ? 'block' : 'none';

  const shelfLifeInput = document.getElementById('shelf_life_days');
  if (shelfLifeInput) {
    shelfLifeInput.required = isPerishable;
    if (!isPerishable) {
      shelfLifeInput.value = '';
      const expDateInput = document.getElementById('expiration_date');
      const expDateDisplay = document.getElementById('expiration_date_display');
      if (expDateInput) expDateInput.value = '';
      if (expDateDisplay) expDateDisplay.value = '';
    }
  }
}

function updateExpirationDate() {
  const shelfLifeInput = document.getElementById('shelf_life_days');
  if (!shelfLifeInput) return;

  const shelfLife = parseInt(shelfLifeInput.value);
  if (shelfLife && shelfLife > 0) {
    const expirationDate = new Date();
    expirationDate.setDate(expirationDate.getDate() + shelfLife);
    const dateString = expirationDate.toISOString().split('T')[0];

    const expDateInput = document.getElementById('expiration_date');
    const expDateDisplay = document.getElementById('expiration_date_display');

    if (expDateInput) expDateInput.value = dateString;
    if (expDateDisplay) expDateDisplay.value = dateString;
  }
}

// Utility functions
function getCurrentBatchId() {
  if (window.currentBatchId) {
    return window.currentBatchId;
  }

  const pathParts = window.location.pathname.split('/');
  return pathParts[pathParts.length - 1];
}

function getCSRFToken() {
  const token = document.querySelector('input[name="csrf_token"]')?.value ||
                document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
  return token || '';
}

// Initialize when modal opens
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('finishBatchModal');
  if (modal) {
    modal.addEventListener('shown.bs.modal', function () {
      console.log('Modal opened, initializing...');

      // Initialize shelf life toggle
      toggleShelfLife();

      // Load variants if product fields exist
      const productSelect = document.getElementById('product_id');
      if (productSelect) {
        loadVariants();
      }

      // Load container data if needed
      loadContainers();

      // Validate yield if input exists
      const finalQuantityInput = document.getElementById('final_quantity');
      if (finalQuantityInput) {
        finalQuantityInput.addEventListener('input', validateYield);
        validateYield();
      }

      // Add event listeners to container inputs
      const containerInputs = document.querySelectorAll('.container-final-input');
      containerInputs.forEach(input => {
        input.addEventListener('input', updateContainerSummary);
      });
    });
  }
});
</script>