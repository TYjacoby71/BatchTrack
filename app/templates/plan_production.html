
{% extends 'layout.html' %}
{% block content %}
<input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
<div x-data="planProduction()" x-init="init()" class="container">
  <!-- Page Header -->
  <div class="d-flex justify-content-between align-items-center mb-4">
    <h2>Plan Production: {{ recipe.name }}</h2>
    <a href="{{ url_for('recipes.list_recipes') }}" class="btn btn-secondary">
      <i class="fas fa-arrow-left"></i> Back to Recipes
    </a>
  </div>

  <!-- Batch Configuration Card -->
  <div class="card mb-4">
    <div class="card-header">
      <h5 class="mb-0">
        <i class="fas fa-cogs"></i> Batch Configuration
      </h5>
    </div>
    <div class="card-body">
      <div class="row g-3">
        <div class="col-md-3">
          <div class="form-group">
            <label class="form-label fw-semibold">Batch Scale</label>
            <input type="number" min="0.1" step="0.1" class="form-control" x-model.number="scale" @input="fetchContainerPlan" placeholder="1.0">
          </div>
        </div>
        <div class="col-md-3">
          <div class="form-group">
            <label class="form-label fw-semibold">Projected Yield</label>
            <div class="form-control bg-light border-0 fw-bold text-primary d-flex align-items-center" style="height: 38px;" x-text="(baseYield * scale).toFixed(2) + ' ' + unit"></div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="form-group">
            <label class="form-label fw-semibold">Batch Type <span class="text-danger">*</span></label>
            <select class="form-select" x-model="batchType" :class="batchType === '' ? 'is-invalid' : ''">
              <option value="">Select Type</option>
              <option value="ingredient">Intermediate Ingredient</option>
              <option value="product">Final Product</option>
            </select>
            <div class="invalid-feedback" x-show="batchType === ''">
              Please select a batch type
            </div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="form-group">
            <label class="form-label fw-semibold">Container Options</label>
            <div class="form-control bg-light border-0 d-flex align-items-center" style="height: 38px;">
              <div class="form-check form-switch mb-0">
                <input type="checkbox" class="form-check-input" id="requireContainers" x-model="requiresContainers" @change="onContainerRequirementChange">
                <label class="form-check-label fw-normal" for="requireContainers">
                  <i class="fas fa-box me-1"></i> Require Containers
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Container Management Card -->
  <div class="card mb-4" x-show="requiresContainers">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="mb-0">
        <i class="fas fa-box"></i> Container Management
      </h5>
      <div class="d-flex align-items-center gap-3">
        <button type="button" class="btn btn-outline-primary btn-sm" @click="manualAddContainer">
          <i class="fas fa-plus"></i> Add Container
        </button>
      </div>
    </div>
    <div class="card-body">
      <!-- Auto-Fill Toggle -->
      <div class="form-check mb-3">
        <input type="checkbox" class="form-check-input" id="autoFill" x-model="autoFill" @change="fetchContainerPlan">
        <label class="form-check-label" for="autoFill">
          <i class="fas fa-magic"></i> Auto-Fill Containers
        </label>
      </div>

      <!-- Container Selection -->
      <template x-for="(container, index) in containersSelected" :key="index">
        <div class="row align-items-center mb-3 p-3 border rounded bg-light">
          <div class="col-md-5">
            <label class="form-label small">Container Type</label>
            <select class="form-select form-select-sm" x-model="container.id" :disabled="autoFill" 
              @change="updateContainer(index)"
              @click="autoFill && alert('Please uncheck Auto-Fill to modify containers.')">
              <option value="">Select Container</option>
              <template x-for="allowed in allowedContainers.filter(c => c.stock_qty > 0)" :key="allowed.id">
                <option :value="allowed.id" x-text="allowed.name + ' (' + allowed.storage_amount + ' ' + allowed.storage_unit + ')'"></option>
              </template>
            </select>
          </div>
          <div class="col-md-3">
            <label class="form-label small">Quantity</label>
            <input type="number" min="1" class="form-control form-control-sm" 
              x-model.number="container.quantity" 
              :disabled="autoFill || getRemainingStock(container.id, index) <= 0" 
              @input="updateProgress"
              @click="autoFill && alert('Please uncheck Auto-Fill to modify containers.')">
          </div>
          <div class="col-md-3">
            <label class="form-label small">Available Stock</label>
            <div class="badge bg-info fs-6" x-text="getRemainingStock(container.id, index)"></div>
          </div>
          <div class="col-md-1">
            <label class="form-label small">&nbsp;</label>
            <button type="button" class="btn btn-danger btn-sm d-block" 
              @click="autoFill ? alert('Please uncheck Auto-Fill to modify containers.') : removeContainer(index)" 
              :disabled="autoFill">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
      </template>

      <!-- Containment Progress -->
      <div class="mt-4">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <label class="form-label mb-0">Containment Progress:</label>
          <span class="badge bg-primary" x-text="containmentPercent + '%'"></span>
        </div>
        <div class="progress" style="height: 25px;">
          <div class="progress-bar" role="progressbar" 
            :style="'width: ' + containmentPercent + '%'" 
            :class="containmentPercent >= 100 ? 'bg-success' : 'bg-warning'"
            x-text="containmentPercent + '%'"></div>
        </div>
        <small class="form-text text-muted mt-1" x-text="liveContainmentMessage"></small>
      </div>

      <!-- Warnings -->
      <div class="alert alert-warning mt-3" x-show="containmentIssue">
        <i class="fas fa-exclamation-triangle"></i>
        <span x-text="containmentIssue"></span>
      </div>

      <div class="alert alert-danger mt-3" x-show="containersSelected.length === 0">
        <i class="fas fa-exclamation-circle"></i>
        No containers selected. Please add containers or enable Auto-Fill.
      </div>
    </div>
  </div>

  <!-- Stock Check Card -->
  <div class="card mb-4">
    <div class="card-header">
      <h5 class="mb-0">
        <i class="fas fa-clipboard-check"></i> Ingredient Stock Check
      </h5>
    </div>
    <div class="card-body">
      <div class="d-flex gap-2 mb-3">
        <button type="button" class="btn btn-warning" @click="checkStockOrWarn()">
          <i class="fas fa-search"></i> Check Stock
        </button>
        <div class="ms-auto" x-show="stockChecked">
          <span class="badge" :class="stockCheckPassed ? 'bg-success' : 'bg-danger'">
            <i class="fas" :class="stockCheckPassed ? 'fa-check' : 'fa-times'"></i>
            <span x-text="stockCheckPassed ? 'Stock OK' : 'Stock Issues'"></span>
          </span>
        </div>
      </div>
      {% include 'partials/plan_production_stock_check.html' %}
    </div>
  </div>

  <!-- Action Buttons Card -->
  <div class="card">
    <div class="card-body">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <p class="mb-0 text-muted">
            <i class="fas fa-info-circle"></i>
            Ready to start batch when all requirements are met
          </p>
        </div>
        <div class="d-flex gap-2">
          <a href="{{ url_for('recipes.list_recipes') }}" class="btn btn-secondary">
            <i class="fas fa-times"></i> Cancel
          </a>
          <button type="button" class="btn btn-success" x-show="canStartBatch" @click="startBatch">
            <i class="fas fa-play"></i> Start Batch
          </button>
          <button type="button" class="btn btn-outline-success" x-show="!canStartBatch" disabled>
            <i class="fas fa-clock"></i> Requirements Not Met
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
function planProduction() {
  return {
      recipeId: {{ recipe.id }},
      baseYield: {{ '%.2f'|format(recipe.predicted_yield) }},
      unit: '{{ recipe.predicted_yield_unit }}',
      allowedContainers: [],
      containersSelected: [],
      autoFill: true,
      scale: 1.0,
      batchType: '',
      requiresContainers: false,
      stockChecked: false,
      stockCheckPassed: false,
      stockResults: [],
      containmentPercent: 0,
      remainingToContain: 0,
      containmentIssue: '',
      scaleTimeout: null,

    init() {
      this.fetchContainerPlan();
      
      // Watch for autoFill changes
      this.$watch('autoFill', (newValue) => {
        if (this.requiresContainers && this.allowedContainers.length > 0) {
          if (newValue) {
            this.performAutoFill();
          } else {
            // When turning off auto-fill, keep current selections but validate them
            this.validateExistingSelections();
          }
        }
      });
      
      // Watch for scale changes
      this.$watch('scale', (newValue, oldValue) => {
        if (newValue !== oldValue && newValue > 0) {
          // Debounce the container plan fetch
          clearTimeout(this.scaleTimeout);
          this.scaleTimeout = setTimeout(() => {
            this.fetchContainerPlan();
          }, 500);
        }
      });
    },

    getRemainingStock(containerId, currentIndex) {
      const match = this.allowedContainers.find(c => c.id == containerId);
      if (!match) return 0;

      const allocated = this.containersSelected.reduce((sum, c, idx) => {
        if (idx !== currentIndex && c.id == containerId) {
          return sum + (c.quantity || 0);
        }
        return sum;
      }, 0);

      return match.stock_qty - allocated;
    },

    get totalContained() {
      return this.containersSelected.reduce((sum, c) => sum + (c.capacity * c.quantity), 0);
    },

    get liveContainmentMessage() {
      if (this.containersSelected.length === 0) return '';
      if (this.containmentPercent < 100) {
        return `There will be ${this.remainingToContain.toFixed(2)} ${this.unit} left uncontained.`;
      }
      return 'Full containment achieved.';
    },

    get canStartBatch() {
      const batchTypeSelected = this.batchType !== '';
      if (this.requiresContainers) {
        return batchTypeSelected && this.containmentPercent >= 100 && this.stockChecked && this.stockCheckPassed;
      }
      return batchTypeSelected && this.stockChecked && this.stockCheckPassed;
    },

    onContainerRequirementChange() {
      if (!this.requiresContainers) {
        this.containersSelected = [];
        this.containmentPercent = 0;
        this.remainingToContain = 0;
        this.containmentIssue = '';
        this.allowedContainers = [];
      } else {
        // Small delay to ensure the DOM has updated
        this.$nextTick(() => {
          this.fetchContainerPlan();
        });
      }
    },

    fetchContainerPlan() {
      if (!this.requiresContainers) {
        this.allowedContainers = [];
        this.containersSelected = [];
        this.updateProgress();
        return;
      }

      const scale = this.scale || 1.0;
      fetch(`/api/available-containers/${this.recipeId}?scale=${scale}`)
        .then(res => res.json())
        .then(data => {
          console.log('Container API response:', data);
          this.allowedContainers = data.available || [];
          console.log('Allowed containers:', this.allowedContainers);

          if (this.autoFill && this.requiresContainers && this.allowedContainers.length > 0) {
            this.performAutoFill();
          } else if (!this.autoFill) {
            // Keep existing selections but validate them
            this.validateExistingSelections();
          }

          this.refreshContainmentStatus();
        })
        .catch(err => {
          console.error('Error fetching container plan:', err);
          this.allowedContainers = [];
          this.containersSelected = [];
          this.updateProgress();
        });
    },

    performAutoFill() {
      const projected = this.baseYield * this.scale;
      let remainingVolume = projected;

      // Sort containers by capacity (largest first) - these are already filtered by the API
      const availableContainers = [...this.allowedContainers]
        .filter(c => c.stock_qty > 0)
        .sort((a, b) => b.storage_amount - a.storage_amount);

      let selectedContainers = [];
      
      // First pass: Try to fill with largest containers that fit perfectly or don't exceed target
      for (const container of availableContainers) {
        if (remainingVolume <= 0) break;
        
        const capacity = container.storage_amount;
        const maxNeeded = Math.floor(remainingVolume / capacity);
        const qtyToUse = Math.min(maxNeeded, container.stock_qty);

        if (qtyToUse > 0) {
          selectedContainers.push({
            id: container.id,
            quantity: qtyToUse,
            name: container.name,
            capacity: capacity,
            unit: container.storage_unit
          });
          remainingVolume -= qtyToUse * capacity;
        }
      }

      // Second pass: If there's still remaining volume, add one more container for partial fill
      if (remainingVolume > 0) {
        for (const container of availableContainers) {
          const alreadyUsed = selectedContainers.find(s => s.id === container.id);
          const remainingStock = container.stock_qty - (alreadyUsed ? alreadyUsed.quantity : 0);
          
          if (remainingStock > 0) {
            if (alreadyUsed) {
              alreadyUsed.quantity += 1;
            } else {
              selectedContainers.push({
                id: container.id,
                quantity: 1,
                name: container.name,
                capacity: container.storage_amount,
                unit: container.storage_unit
              });
            }
            break;
          }
        }
      }

      this.containersSelected = selectedContainers;
      this.updateProgress();
      this.evaluateContainment();
    },

    validateExistingSelections() {
      // Remove any selections that are no longer valid
      this.containersSelected = this.containersSelected.filter(selected => {
        const container = this.allowedContainers.find(c => c.id === selected.id);
        if (!container) return false;
        
        // Update container details in case they changed
        selected.name = container.name;
        selected.capacity = container.storage_amount;
        selected.unit = container.storage_unit;
        
        // Ensure quantity doesn't exceed available stock
        const remainingStock = this.getRemainingStock(selected.id, -1);
        if (selected.quantity > remainingStock) {
          selected.quantity = Math.max(0, remainingStock);
        }
        
        return selected.quantity > 0;
      });
      
      this.updateProgress();
      this.evaluateContainment();
    },

    updateProgress() {
      const projected = this.baseYield * this.scale;
      const contained = this.totalContained;
      this.containmentPercent = Math.min((contained / projected) * 100, 100).toFixed(0);
      this.remainingToContain = Math.max(projected - contained, 0);
    },

    refreshContainmentStatus() {
      this.updateProgress();
      this.evaluateContainment();
    },

    evaluateContainment() {
      const projected = this.baseYield * this.scale;
      const totalAvailable = this.allowedContainers.reduce((sum, c) => sum + (c.storage_amount * c.stock_qty), 0);

      this.containmentIssue = '';

      if (totalAvailable < projected) {
        const sizes = this.allowedContainers.map(c => c.storage_amount);
        const smallestContainer = sizes.length ? Math.min(...sizes) : 1;
        const missingUnits = Math.ceil((projected - totalAvailable) / smallestContainer);
        this.containmentIssue = `Error: You need ${missingUnits} more containers to make this batch.`;
        return;
      }

      const totalContained = this.totalContained;
      
      // Check if containment is exactly 100% (within a small tolerance for floating point precision)
      const containmentRatio = totalContained / projected;
      const isExactMatch = Math.abs(containmentRatio - 1) < 0.001; // 0.1% tolerance
      
      if (totalContained < projected) {
        this.containmentIssue = 'Warning: Need one more container for partial fill';
      } else if (totalContained > projected && !isExactMatch) {
        const lastContainer = this.containersSelected[this.containersSelected.length - 1];
        if (lastContainer) {
          const partialAmount = projected - (totalContained - lastContainer.capacity);
          if (partialAmount < lastContainer.capacity && partialAmount > 0) {
            this.containmentIssue = `Warning: Last container will be partially filled (${partialAmount.toFixed(2)} ${this.unit})`;
          }
        }
      }
      // If containment is exactly 100%, no warning is needed
    },

    updateContainer(index) {
      const container = this.containersSelected[index];
      if (!container || !container.id) return;

      const match = this.allowedContainers.find(c => c.id == container.id);
      if (match) {
        container.capacity = match.storage_amount;
        container.unit = match.storage_unit;
        container.name = match.name;
        const remainingStock = this.getRemainingStock(container.id, index);

        if (remainingStock <= 0) {
          container.quantity = 0;
        } else if (container.quantity > remainingStock) {
          container.quantity = remainingStock;
        }
      }
      this.updateProgress();
      this.evaluateContainment();
    },

    removeContainer(index) {
      this.containersSelected.splice(index, 1);
      this.updateProgress();
      this.evaluateContainment();
    },

    manualAddContainer() {
      if (this.autoFill) {
        alert('Please uncheck Auto-Fill to add containers manually.');
        return;
      }
      const availableContainers = this.allowedContainers.filter(c => {
        const remainingStock = this.getRemainingStock(c.id, -1);
        return remainingStock > 0;
      });
      
      if (availableContainers.length === 0) {
        alert('No containers available in stock.');
        return;
      }
      
      this.containersSelected.push({ 
        id: '', 
        name: '', 
        capacity: 0, 
        quantity: 1, 
        unit: '' 
      });
      this.updateProgress();
      this.evaluateContainment();
    },

    checkStockOrWarn() {
      this.checkStock();
    },

    checkStock() {
      const csrfToken = document.querySelector('input[name="csrf_token"]').value;
      fetch('/api/check-stock', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify({ 
          recipe_id: parseInt(this.recipeId), 
          scale: parseFloat(this.scale)
        })
      })
        .then(res => res.json())
        .then(data => {
          this.stockChecked = true;
          this.stockCheckPassed = data.all_ok;
          this.stockResults = data;
        })
        .catch(err => {
          this.stockChecked = false;
          this.stockResults = [];
          console.error(err);
        });
    },

    downloadCSV() {
      if (!this.stockResults?.length) return;
      let csv = "Ingredient,Required,Available,Unit,Status\n";
      this.stockResults.forEach(row => {
        csv += `${row.ingredient},${row.needed},${row.available},${row.unit},${row.status}\n`;
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'stock_check_report.csv';
      link.click();
    },

    downloadShoppingList() {
      if (!this.stockResults?.length) return;
      const needed = this.stockResults.filter(item => item.status === 'LOW' || item.status === 'NEEDED');
      if (!needed.length) {
        alert('No items need restocking!');
        return;
      }
      let text = "Shopping List\n=============\n\n";
      needed.forEach(item => {
        const missing = item.needed - item.available;
        text += `${item.ingredient}: ${missing.toFixed(2)} ${item.unit}\n`;
      });
      const blob = new Blob([text], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'shopping_list.txt';
      link.click();
    },

    async startBatch() {
      if (!this.canStartBatch) {
        if (this.batchType === '') {
          alert('Please select a batch type before starting the batch');
          return;
        }
        alert('Please check stock and ensure containers are properly allocated before starting batch');
        return;
      }

      const csrfToken = document.querySelector('input[name=csrf_token]').value;
      try {
        const response = await fetch('/batches/start_batch', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
          },
          body: JSON.stringify({
            recipe_id: this.recipeId,
            scale: this.scale,
            batch_type: this.batchType,
            requires_containers: this.requiresContainers,
            notes: '',
            containers: this.containersSelected.map(c => ({
              id: c.id,
              quantity: c.quantity
            }))
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Network response was not ok');
        }

        const data = await response.json();
        if (data.batch_id) {
          window.location.href = `/batches/in-progress/${data.batch_id}`;
        } else {
          throw new Error('No batch ID returned');
        }
      } catch (error) {
        alert('Error starting batch: ' + error.message);
      }
    }
  };
}
</script>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/recipes/plan_production.js') }}"></script>
{% endblock %}
