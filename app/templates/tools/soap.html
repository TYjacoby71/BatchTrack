{% extends 'layout.html' %}
{% set tool_enabled = tool_enabled if tool_enabled is defined else True %}
{% set navbar_center_title = 'Soap Formulator' %}
{% block content %}
<div class="py-1" id="soapToolPage">
  <h1 class="visually-hidden">Soap Formulator</h1>
  {% if not tool_enabled %}
  <div class="alert alert-warning d-flex align-items-center" role="alert">
    <i class="fas fa-hourglass-half me-2"></i>
    Public drafting is in previewâ€”feel free to explore the layout while we finish the live calculators.
  </div>
  {% endif %}
  <script>
    window.RECIPE_CATEGORY_NAME = 'Soaps';
    window.SOAP_CALC_LIMIT = {{ calc_limit|tojson if calc_limit is defined else 'null' }};
    window.SOAP_CALC_TIER = {{ calc_tier|tojson if calc_tier is defined else '"guest"' }};
  </script>
  <div id="soapAlertStack" class="mb-3"></div>
  <style>
    #soapToolPage {
      margin-top: calc(-1 * var(--space-4));
    }
    #soapToolPage .soap-quality-row {
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-areas:
        "label hint"
        "bar bar"
        "note note";
      row-gap: var(--space-1);
      column-gap: var(--space-2);
      align-items: center;
    }
    #soapToolPage .soap-quality-label {
      grid-area: label;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: var(--space-3);
    }
    #soapToolPage .soap-quality-name {
      font-size: 0.85rem;
      color: var(--color-muted);
    }
    #soapToolPage .soap-quality-value {
      font-variant-numeric: tabular-nums;
    }
    #soapToolPage .soap-quality-help {
      grid-area: hint;
      align-self: start;
    }
    #soapToolPage .soap-quality-help-placeholder {
      grid-area: hint;
      width: 1rem;
      height: 1rem;
    }
    #soapToolPage .soap-quality-progress {
      grid-area: bar;
      position: relative;
      height: var(--space-4);
      border-radius: var(--radius-2);
      background: var(--color-subtle-bg-2);
      overflow: visible;
    }
    #soapToolPage .soap-quality-range {
      position: absolute;
      inset: 0;
      display: flex;
      border-radius: inherit;
      overflow: hidden;
      z-index: 1;
      opacity: 0.35;
      pointer-events: none;
    }
    #soapToolPage .soap-quality-range-start,
    #soapToolPage .soap-quality-range-ideal,
    #soapToolPage .soap-quality-range-end {
      height: 100%;
    }
    #soapToolPage .soap-quality-progress .progress-bar {
      height: 100%;
      z-index: 2;
      position: relative;
    }
    #soapToolPage .soap-quality-boundary {
      position: absolute;
      top: calc(-1 * var(--space-3));
      font-size: 0.7rem;
      color: var(--color-muted);
    }
    #soapToolPage .soap-quality-boundary-start {
      left: 0;
      transform: translateX(-10%);
    }
    #soapToolPage .soap-quality-boundary-end {
      right: 0;
      transform: translateX(10%);
    }
    #soapToolPage .soap-quality-section-title {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: var(--space-1);
      color: var(--color-text);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: var(--space-2);
    }
    #soapToolPage .soap-quality-legend {
      font-size: 0.7rem;
      font-weight: 400;
      color: var(--color-muted);
    }
    #soapToolPage .soap-fatty-table {
      background: transparent;
      border: none;
      box-shadow: none;
    }
    #soapToolPage .soap-fatty-table td {
      padding: var(--space-1) 0;
      border: none;
      font-size: 0.85rem;
    }
    #soapToolPage .soap-quality-row .small.text-muted:empty {
      display: none;
    }
    #soapToolPage .soap-fatty-table tbody tr:not(:last-child) td {
      border-bottom: 1px solid var(--color-border);
    }
    #soapToolPage #soapConfigCard,
    #soapToolPage #soapQualityCard,
    #soapToolPage #resultsCard {
      margin-bottom: var(--space-2);
    }
    #soapToolPage #resultsCard {
      margin-top: var(--space-2);
    }
    #soapToolPage .soap-mobile-drawer {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1080;
      display: none;
      pointer-events: none;
    }
    #soapToolPage .soap-mobile-drawer .drawer-panel {
      background: var(--color-surface);
      border-top: 1px solid var(--color-border);
      box-shadow: var(--shadow-3);
      max-height: 70vh;
      overflow-y: auto;
      transform: translateY(100%);
      transition: transform 0.2s ease;
      pointer-events: auto;
    }
    #soapToolPage .soap-mobile-drawer.is-open .drawer-panel {
      transform: translateY(0);
    }
    #soapToolPage .soap-mobile-drawer .drawer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem 0.5rem;
      border-bottom: 1px solid var(--color-border);
      position: sticky;
      top: 0;
      background: var(--color-surface);
      z-index: 1;
    }
    #soapToolPage .soap-mobile-drawer .drawer-title {
      font-weight: 600;
    }
    #soapToolPage .soap-mobile-drawer .drawer-content {
      padding: 0.75rem 1rem 1rem;
    }
    #soapToolPage .soap-mobile-drawer .sticky-top {
      position: static !important;
      top: auto !important;
    }
    #soapToolPage .soap-mobile-drawer .drawer-handle {
      background: var(--color-surface);
      border-top: 1px solid var(--color-border);
      padding: 0.5rem 0.75rem;
      display: flex;
      gap: 0.5rem;
      box-shadow: var(--shadow-2);
      pointer-events: auto;
      position: relative;
      z-index: 2;
    }
    #soapToolPage .soap-mobile-drawer .drawer-empty {
      margin: 0.75rem 1rem 1rem;
    }
    #soapToolPage .soap-card-placeholder { min-height: 1px; }
    #soapToolPage .soap-unit-chip {
      font-size: 0.7rem;
      font-weight: 600;
      background: var(--color-subtle-bg-2);
      border: 1px solid var(--color-border);
      color: var(--color-text);
    }
    #soapToolPage .soap-metric-tile {
      border: 1px solid var(--color-border);
      border-radius: var(--radius-2);
      background: var(--color-surface);
      padding: var(--space-3);
      box-shadow: var(--shadow-1);
      height: 100%;
    }
    #soapToolPage .soap-metric-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--color-subtle-bg-2);
    }
    #soapToolPage .soap-quality-range-start {
      background: var(--color-warning-bg);
    }
    #soapToolPage .soap-quality-range-ideal {
      background: var(--overlay-primary-weak);
    }
    #soapToolPage .soap-quality-range-end {
      background: var(--color-warning-bg);
    }
    #soapToolPage .soap-fatty-bar {
      display: flex;
      gap: 2px;
      height: 8px;
    }
    #soapToolPage .soap-fatty-segment {
      flex: 1;
      border-radius: var(--radius-1);
    }
    #soapToolPage .soap-stage-highlight {
      outline: 2px solid var(--color-primary);
      box-shadow: var(--shadow-2);
      transition: box-shadow 0.2s ease, outline 0.2s ease;
    }
    #soapToolPage .soap-stage-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: var(--space-4);
    }
    #soapToolPage .soap-config-row .form-label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin-bottom: 0.25rem;
    }
    #soapToolPage .soap-config-row .form-control,
    #soapToolPage .soap-config-row .form-select,
    #soapToolPage .soap-config-row .btn-group .btn {
      min-height: 38px;
    }
    #soapToolPage .accordion-body .form-label {
      margin-bottom: 0.25rem;
    }
    #soapToolPage .soap-stage-form-row .form-control,
    #soapToolPage .soap-stage-form-row .form-select {
      min-height: 38px;
    }
    #soapToolPage .soap-field .form-text {
      display: none;
    }
    #soapToolPage .soap-field:focus-within .form-text {
      display: block;
    }
    #soapToolPage .soap-number-pulse {
      animation: soapPulse 0.5s ease;
    }
    #soapToolPage .soap-toast {
      background: var(--color-dark);
      color: var(--color-on-primary);
      box-shadow: var(--shadow-3);
    }
    @keyframes soapPulse {
      0% { transform: translateY(0); opacity: 0.7; }
      50% { transform: translateY(-2px); opacity: 1; }
      100% { transform: translateY(0); opacity: 1; }
    }
    #soapToolPage .soap-quality-row .progress { height: var(--space-4); }
    #soapToolPage .quality-target-marker {
      position: absolute;
      top: -4px;
      bottom: -4px;
      border-left: 2px dashed var(--color-primary);
      width: 0;
      z-index: 3;
    }
    #soapToolPage .quality-target-label {
      position: absolute;
      top: -18px;
      left: 0;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: var(--color-primary);
      background: var(--color-surface);
      padding: 0 4px;
      border: 1px solid var(--color-border);
      border-radius: var(--radius-1);
    }
    #soapToolPage .soap-oil-profile td {
      padding: 0.2rem 0.35rem;
    }
    #soapToolPage .soap-stage-note {
      font-size: 0.78rem;
    }
    #soapToolPage .accordion-item {
      border-radius: var(--radius-3);
      border: 1px solid var(--color-border);
      box-shadow: var(--shadow-1);
      overflow: hidden;
      background-color: var(--color-surface);
    }
    #soapToolPage .accordion-button {
      background-color: var(--color-surface);
    }
    #soapToolPage .accordion-button:focus {
      box-shadow: none;
    }
    #soapToolPage .accordion-button:not(.collapsed) {
      color: var(--color-text);
      box-shadow: none;
    }
    #soapToolPage .soap-stage-pane {
      display: flex;
      flex-direction: column;
    }
    #soapToolPage .soap-stage-pane.is-height-synced {
      height: var(--soap-stage-height);
    }
    #soapToolPage .soap-stage-pane.is-height-synced .accordion {
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }
    #soapToolPage .soap-stage-pane.is-height-synced .accordion-item {
      margin: 0;
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    #soapToolPage .soap-stage-pane.is-height-synced .accordion-item.is-open {
      flex: 1 1 auto;
      order: -1;
      z-index: 2;
    }
    #soapToolPage .soap-stage-pane.is-overlay-open {
      height: auto;
      overflow: visible;
      position: relative;
      min-height: var(--soap-stage-height);
    }
    #soapToolPage .soap-stage-pane.is-overlay-open .accordion {
      display: block;
      gap: 0;
      overflow: visible;
      position: relative;
      min-height: var(--soap-stage-height);
    }
    #soapToolPage .soap-stage-pane.is-overlay-open .accordion-item {
      display: none;
    }
    #soapToolPage .soap-stage-pane.is-overlay-open .accordion-item.is-open {
      display: flex;
      flex-direction: column;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      min-height: var(--soap-stage-height);
      z-index: 2;
    }
    #soapToolPage .soap-stage-pane.is-overlay-open .accordion-item.is-open > .accordion-collapse {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    #soapToolPage .soap-stage-pane.is-overlay-open .accordion-item.is-open .accordion-body {
      flex: 1 1 auto;
    }
    #soapToolPage .soap-stage-pane.is-height-synced .accordion-item.is-open > .accordion-collapse {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    #soapToolPage .soap-stage-pane.is-height-synced .accordion-item.is-open .accordion-body {
      flex: 1 1 auto;
      overflow: auto;
    }
    #soapToolPage .soap-stage-pane.is-height-synced .accordion-button {
      padding: var(--space-3) var(--space-4);
    }
    #soapToolPage .soap-stage-pane .accordion {
      margin-bottom: 0;
    }
    #soapToolPage .oil-profile-float {
      position: absolute;
      right: 0;
      top: 0;
      width: 260px;
      max-width: 45%;
      z-index: 1040;
      box-shadow: var(--shadow-2);
    }
    #soapToolPage .oil-profile-open {
      display: none;
    }
    @media (min-width: 1760px) {
      #soapToolPage .oil-profile-float {
        position: fixed;
        top: 120px;
        right: auto;
        left: calc((100vw - 1140px) / 2 - 280px - 24px);
        width: 260px;
        max-width: 260px;
        max-height: calc(100vh - 180px);
        overflow-y: auto;
      }
    }
    #soapToolPage #soapStageQualityRow {
      display: flex !important;
      flex-wrap: nowrap;
      align-items: stretch;
    }
    #soapToolPage #soapStageQualityRow > .soap-stage-col {
      flex: 0 0 50%;
      max-width: 50%;
      min-width: 0;
    }
    #soapToolPage #soapStageQualityRow > .soap-quality-col {
      flex: 0 0 50%;
      max-width: 50%;
      min-width: 0;
    }
    @media (max-width: 767px) {
      #soapToolPage .oil-profile-float {
        position: static;
        width: 100%;
        max-width: 100%;
        display: none !important;
      }
      #soapToolPage .oil-profile-open {
        display: inline-flex;
      }
      #soapToolPage #soapStageQualityRow {
        flex-wrap: wrap;
      }
      #soapToolPage #soapStageQualityRow > .soap-stage-col,
      #soapToolPage #soapStageQualityRow > .soap-quality-col {
        flex: 0 0 100%;
        max-width: 100%;
      }
    }
    @media (max-width: 767px) {
      #soapToolPage { padding-bottom: 4.75rem; }
      #soapToolPage #soapQualityCard {
        position: static !important;
        top: auto !important;
      }
      #soapToolPage .soap-mobile-drawer {
        display: block;
      }
    }
  </style>

  {% include 'tools/soap/_config_card.html' %}

  <div class="row mt-2 g-2" id="soapStageQualityRow">
    <div class="col-lg-6 soap-stage-col">
      <div class="soap-stage-pane" id="soapStagePane">
        {% include 'tools/soap/_stages.html' %}
      </div>
    </div>

    <div class="col-lg-6 soap-quality-col">
      {% include 'tools/soap/_quality_card.html' %}
    </div>

  </div>

  {% include 'tools/soap/_results_card.html' %}

  {% include 'tools/soap/_mobile_drawer.html' %}

  {% include 'tools/soap/_modals.html' %}
  {% include 'tools/soap/_toasts.html' %}

</div>

<script src="{{ url_for('static', filename='js/components/suggestions.js') }}"></script>
<script src="{{ url_for('static', filename='js/components/tool_lines.js') }}"></script>
<script>
(function(){
  const TOOL_UNIT_OPTIONS_HTML = `{% for unit in global_units %}<option value="{{ unit.name }}">{{ unit.name }}</option>{% endfor %}`;
  const QUALITY_RANGES = {
    hardness: [29, 54],
    cleansing: [12, 22],
    conditioning: [44, 69],
    bubbly: [14, 46],
    creamy: [16, 48],
  };
  const QUALITY_HINTS = {
    hardness: 'Durable bar that resists mush.',
    cleansing: 'Higher values feel more stripping.',
    conditioning: 'Silky, moisturizing feel.',
    bubbly: 'Fluffy lather and big bubbles.',
    creamy: 'Stable, creamy lather.',
  };
  const QUALITY_FEEL_HINTS = {
    hardness: {
      low: 'Soft bar, slower unmold.',
      ok: 'Balanced hardness for daily use.',
      high: 'Very hard bar, can feel brittle.',
    },
    cleansing: {
      low: 'Very mild cleansing.',
      ok: 'Balanced cleansing.',
      high: 'Strong cleansing, can be drying.',
    },
    conditioning: {
      low: 'Less conditioning feel.',
      ok: 'Smooth and conditioning.',
      high: 'Very conditioning, may feel oily.',
    },
    bubbly: {
      low: 'Low bubbly lather.',
      ok: 'Balanced bubbly lather.',
      high: 'Very bubbly, big foam.',
    },
    creamy: {
      low: 'Light creamy lather.',
      ok: 'Creamy and stable.',
      high: 'Dense creamy lather.',
    },
  };
  const IODINE_RANGE = [41, 70];
  const IODINE_SCALE_MAX = 100;
  const INS_RANGE = [136, 170];
  const INS_SCALE_MAX = 250;
  const QUALITY_BASE = {
    hardness: (QUALITY_RANGES.hardness[0] + QUALITY_RANGES.hardness[1]) / 2,
    cleansing: (QUALITY_RANGES.cleansing[0] + QUALITY_RANGES.cleansing[1]) / 2,
    conditioning: (QUALITY_RANGES.conditioning[0] + QUALITY_RANGES.conditioning[1]) / 2,
    bubbly: (QUALITY_RANGES.bubbly[0] + QUALITY_RANGES.bubbly[1]) / 2,
    creamy: (QUALITY_RANGES.creamy[0] + QUALITY_RANGES.creamy[1]) / 2,
  };
  const QUALITY_PRESETS = {
    balanced: {
      hardness: 40,
      cleansing: 15,
      conditioning: 55,
      bubbly: 25,
      creamy: 25,
      iodine: 55,
      ins: 160,
    },
    bubbly: {
      hardness: 35,
      cleansing: 20,
      conditioning: 50,
      bubbly: 35,
      creamy: 25,
      iodine: 60,
      ins: 150,
    },
    creamy: {
      hardness: 45,
      cleansing: 12,
      conditioning: 60,
      bubbly: 20,
      creamy: 35,
      iodine: 50,
      ins: 155,
    },
    hard: {
      hardness: 50,
      cleansing: 18,
      conditioning: 48,
      bubbly: 22,
      creamy: 28,
      iodine: 45,
      ins: 165,
    },
    gentle: {
      hardness: 35,
      cleansing: 10,
      conditioning: 65,
      bubbly: 15,
      creamy: 20,
      iodine: 65,
      ins: 140,
    },
    castile: {
      hardness: 20,
      cleansing: 5,
      conditioning: 75,
      bubbly: 10,
      creamy: 15,
      iodine: 80,
      ins: 110,
    },
    shampoo: {
      hardness: 30,
      cleansing: 22,
      conditioning: 50,
      bubbly: 30,
      creamy: 25,
      iodine: 60,
      ins: 145,
    },
    utility: {
      hardness: 70,
      cleansing: 50,
      conditioning: 20,
      bubbly: 50,
      creamy: 20,
      iodine: 10,
      ins: 250,
    },
    luxury: {
      hardness: 55,
      cleansing: 10,
      conditioning: 55,
      bubbly: 15,
      creamy: 40,
      iodine: 50,
      ins: 150,
    },
    palmFree: {
      hardness: 42,
      cleansing: 16,
      conditioning: 58,
      bubbly: 22,
      creamy: 28,
      iodine: 55,
      ins: 155,
    },
  };
  const FATTY_BAR_COLORS = {
    lauric: 'var(--color-primary)',
    myristic: 'var(--color-info)',
    palmitic: 'var(--color-warning)',
    stearic: 'var(--color-muted)',
    ricinoleic: 'var(--color-info-hover)',
    oleic: 'var(--color-success)',
    linoleic: 'var(--color-primary-hover)',
    linolenic: 'var(--color-danger)',
  };
  const FATTY_DISPLAY_KEYS = [
    'lauric',
    'myristic',
    'palmitic',
    'stearic',
    'ricinoleic',
    'oleic',
    'linoleic',
    'linolenic',
  ];
  const OIL_TIP_RULES = [
    { match: /coconut|palm kernel|babassu|murumuru/i, tip: 'High lauric oils trace fast and feel cleansing; keep superfat >= 5%.' },
    { match: /olive|avocado|rice bran|canola|sunflower|safflower|almond|apricot|macadamia|camellia|grapeseed|hazelnut/i, tip: 'High-oleic liquid oils trace slowly and stay softer early on; allow a longer cure.' },
    { match: /castor/i, tip: 'Castor boosts lather but can feel sticky above 10-15%.' },
    { match: /cocoa|shea|mango|kokum|sal|illipe|tallow|lard|palm|stearic/i, tip: 'Hard fats/butters set up quickly; melt fully and keep batter warm for a smooth pour.' },
    { match: /beeswax|candelilla|carnauba|wax/i, tip: 'Waxes harden fast and can seize; keep usage low and add hot.' },
    { match: /hemp|flax|linseed|evening primrose|borage|rosehip|black currant|chia|pomegranate/i, tip: 'High-PUFA oils shorten shelf life; keep low and add antioxidant.' },
  ];
  const state = {
    lastCalc: null,
    lastOilEdit: null,
    selectedOilProfile: null,
    wasCapped: false,
    lastPreviewRow: null,
    lastRemovedOil: null,
    lastRemovedOilIndex: null,
    lastSaveToastAt: 0,
  };
  const alertStack = document.getElementById('soapAlertStack');
  const STATE_STORAGE_KEY = 'soap_tool_state_v2';
  const CALC_LIMIT = Number.isFinite(window.SOAP_CALC_LIMIT) ? window.SOAP_CALC_LIMIT : null;
  const CALC_LIMIT_TIER = window.SOAP_CALC_TIER || 'guest';
  const UNIT_FACTORS = { g: 1, oz: 28.3495, lb: 453.592 };
  let currentUnit = 'g';
  const IS_AUTHENTICATED = window.__IS_AUTHENTICATED__ === true;
  const OIL_CATEGORY_SET = new Set(['Oils (Carrier & Fixed)', 'Butters & Solid Fats', 'Waxes']);
  const FRAGRANCE_CATEGORY_SET = new Set(['Essential Oils', 'Fragrance Oils']);
  const LACTATE_CATEGORY_SET = new Set(['Aqueous Solutions & Blends', 'Preservatives & Additives']);
  const SUGAR_CATEGORY_SET = new Set(['Sugars & Syrups']);
  const SALT_CATEGORY_SET = new Set(['Salts & Minerals']);
  const CITRIC_CATEGORY_SET = new Set(['Preservatives & Additives', 'Salts & Minerals', 'Aqueous Solutions & Blends']);

  const STAGE_CONFIGS = [
    { id: 1, headingId: 'soapStage1Heading', collapseId: 'soapStage1Collapse', required: true },
    { id: 2, headingId: 'soapStage2Heading', collapseId: 'soapStage2Collapse', required: true },
    { id: 3, headingId: 'soapStage3Heading', collapseId: 'soapStage3Collapse', required: true },
    { id: 4, headingId: 'soapStage4Heading', collapseId: 'soapStage4Collapse', required: false },
    { id: 5, headingId: 'soapStage5Heading', collapseId: 'soapStage5Collapse', required: false },
    { id: 6, headingId: 'soapStage6Heading', collapseId: 'soapStage6Collapse', required: false },
    { id: 7, headingId: 'soapStage7Heading', collapseId: 'soapStage7Collapse', required: false },
  ];

  function formatTime(ts){
    if (!ts) return 'Not saved yet';
    const date = new Date(ts);
    return `Saved ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
  }

  function pulseValue(el){
    if (!el) return;
    el.classList.remove('soap-number-pulse');
    void el.offsetWidth;
    el.classList.add('soap-number-pulse');
  }

  function getToastInstance(id){
    const el = document.getElementById(id);
    if (!el || !window.bootstrap?.Toast) return null;
    return bootstrap.Toast.getOrCreateInstance(el);
  }

  function showAutosaveToast(){
    const now = Date.now();
    if (now - state.lastSaveToastAt < 3500) return;
    state.lastSaveToastAt = now;
    const toast = getToastInstance('soapAutosaveToast');
    if (toast) toast.show();
  }

  function showUndoToast(message){
    const toastEl = document.getElementById('soapUndoToast');
    if (!toastEl) return;
    const body = toastEl.querySelector('.toast-body');
    if (body) body.textContent = message || 'Oil removed.';
    const toast = getToastInstance('soapUndoToast');
    if (toast) toast.show();
  }


  function updateResultsMeta(){
    const badge = document.getElementById('resultsReadyBadge');
    const updatedAt = document.getElementById('resultsUpdatedAt');
    if (badge) badge.classList.remove('d-none');
    if (updatedAt) {
      updatedAt.textContent = `Updated ${new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
    }
  }

  function updateResultsWarnings(waterData){
    const concentrationEl = document.getElementById('lyeConcentrationWarning');
    const ratioEl = document.getElementById('waterRatioWarning');
    if (concentrationEl) {
      const concentration = waterData?.lyeConcentration || 0;
      let message = '';
      if (concentration > 40) message = 'High concentration';
      if (concentration > 0 && concentration < 25) message = 'Low concentration';
      concentrationEl.textContent = message;
      concentrationEl.classList.toggle('d-none', !message);
    }
    if (ratioEl) {
      const ratio = waterData?.waterRatio || 0;
      let message = '';
      if (ratio > 0 && ratio < 1.8) message = 'Low water';
      if (ratio > 2.7) message = 'High water';
      ratioEl.textContent = message;
      ratioEl.classList.toggle('d-none', !message);
    }
  }

  function applyHelperVisibility(){
    document.querySelectorAll('#soapToolPage .form-text').forEach(text => {
      const wrapper = text.closest('.col-md-2, .col-md-3, .col-md-4, .col-md-6, .col-md-8, .col-lg-6, .col-lg-4, .col-12');
      if (wrapper) wrapper.classList.add('soap-field');
    });
  }

  function validateNumericField(input){
    if (!input || input.type !== 'number') return;
    const raw = input.value;
    if (raw === '') {
      input.classList.remove('is-invalid');
      return;
    }
    const value = parseFloat(raw);
    const min = input.getAttribute('min');
    const max = input.getAttribute('max');
    const tooLow = min !== null && min !== '' && value < parseFloat(min);
    const tooHigh = max !== null && max !== '' && value > parseFloat(max);
    input.classList.toggle('is-invalid', !isFinite(value) || tooLow || tooHigh);
  }


  function flashStage(stageItem){
    if (!stageItem) return;
    stageItem.classList.add('soap-stage-highlight');
    setTimeout(() => stageItem.classList.remove('soap-stage-highlight'), 900);
  }

  function injectStageActions(){
    const items = Array.from(document.querySelectorAll('#soapStageAccordion .accordion-item'));
    items.forEach((item, index) => {
      const body = item.querySelector('.accordion-body');
      if (!body || body.querySelector('.soap-stage-actions')) return;
      const actions = document.createElement('div');
      actions.className = 'soap-stage-actions';
      actions.innerHTML = `
        <button class="btn btn-sm btn-outline-secondary" type="button" data-stage-action="prev" data-stage-index="${index}">
          <i class="fas fa-arrow-left me-1"></i>Back
        </button>
        <button class="btn btn-sm btn-outline-danger" type="button" data-stage-action="reset" data-stage-index="${index}">
          Reset stage
        </button>
        <button class="btn btn-sm btn-outline-secondary" type="button" data-stage-action="next" data-stage-index="${index}">
          Next<i class="fas fa-arrow-right ms-1"></i>
        </button>
      `;
      body.appendChild(actions);
    });
  }

  function openStageByIndex(index){
    const stage = STAGE_CONFIGS[index];
    if (!stage) return;
    const target = document.getElementById(stage.collapseId);
    if (!target) return;
    const collapses = Array.from(document.querySelectorAll('#soapStageAccordion .accordion-collapse'));
    collapses.forEach(collapse => {
      if (collapse === target) return;
      if (window.bootstrap?.Collapse) {
        bootstrap.Collapse.getOrCreateInstance(collapse, { toggle: false }).hide();
      } else {
        collapse.classList.remove('show');
      }
    });
    if (window.bootstrap?.Collapse) {
      bootstrap.Collapse.getOrCreateInstance(target, { toggle: false }).show();
    } else {
      target.classList.add('show');
    }
    updateStageAccordionLayout();
    scheduleStageHeightSync();
    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  function resetStage(stageId){
    if (stageId === 1) {
      document.getElementById('moldWaterWeight').value = '';
      document.getElementById('moldOilPct').value = '65';
      document.getElementById('oilTotalTarget').value = '';
      document.getElementById('moldShape').value = 'loaf';
      const correction = document.getElementById('moldCylinderCorrection');
      if (correction) correction.checked = false;
      document.getElementById('moldCylinderFactor').value = '0.85';
      updateMoldSuggested();
    }
    if (stageId === 2) {
      const oilRows = document.getElementById('oilRows');
      if (oilRows) {
        oilRows.innerHTML = '';
        oilRows.appendChild(buildOilRow());
      }
      updateOilTotals();
    }
    if (stageId === 3) {
      document.getElementById('lyePurity').value = '100';
      document.getElementById('waterPct').value = '33';
      document.getElementById('lyeConcentration').value = '33';
      document.getElementById('waterRatio').value = '2';
    }
    if (stageId === 4) {
      document.getElementById('additiveLactatePct').value = '1';
      document.getElementById('additiveSugarPct').value = '1';
      document.getElementById('additiveSaltPct').value = '0.5';
      document.getElementById('additiveCitricPct').value = '0';
      ['additiveLactateName', 'additiveSugarName', 'additiveSaltName', 'additiveCitricName']
        .forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
      ['additiveLactateGi', 'additiveSugarGi', 'additiveSaltGi', 'additiveCitricGi']
        .forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
      updateAdditivesOutput(getTotalOilsGrams());
    }
    if (stageId === 5) {
      document.getElementById('additiveFragrancePct').value = '3';
      const name = document.getElementById('additiveFragranceName');
      if (name) name.value = '';
      const gi = document.getElementById('additiveFragranceGi');
      if (gi) gi.value = '';
    }
    if (stageId === 7) {
      ['tool-ingredients', 'tool-consumables', 'tool-containers'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = '';
      });
    }
    queueStateSave();
    queueAutoCalc();
    updateStageStatuses();
  }

  function getStageCompletion(stageId){
    if (stageId === 1) {
      const moldWeight = toNumber(document.getElementById('moldWaterWeight').value);
      const oilTarget = toNumber(document.getElementById('oilTotalTarget').value);
      const moldPct = toNumber(document.getElementById('moldOilPct').value);
      const complete = (moldWeight > 0 || oilTarget > 0) && moldPct > 0;
      return { state: complete ? 'complete' : 'incomplete', label: complete ? 'Complete' : 'Needs target' };
    }
    if (stageId === 2) {
      const rows = Array.from(document.querySelectorAll('#oilRows .oil-row'));
      const hasOil = rows.some(row => {
        const name = row.querySelector('.oil-typeahead')?.value?.trim();
        const grams = toNumber(row.querySelector('.oil-grams')?.value);
        const pct = toNumber(row.querySelector('.oil-percent')?.value);
        return name && (grams > 0 || pct > 0);
      });
      return { state: hasOil ? 'complete' : 'incomplete', label: hasOil ? 'Oils added' : 'Add oils' };
    }
    if (stageId === 3) {
      const purity = toNumber(document.getElementById('lyePurity').value);
      const method = document.getElementById('waterMethod')?.value || 'percent';
      const waterValue = method === 'percent'
        ? toNumber(document.getElementById('waterPct').value)
        : method === 'concentration'
          ? toNumber(document.getElementById('lyeConcentration').value)
          : toNumber(document.getElementById('waterRatio').value);
      const complete = purity > 0 && waterValue > 0;
      return { state: complete ? 'complete' : 'incomplete', label: complete ? 'Configured' : 'Set water' };
    }
    if (stageId === 4) {
      const hasAdditive = ['additiveLactatePct', 'additiveSugarPct', 'additiveSaltPct', 'additiveCitricPct']
        .some(id => toNumber(document.getElementById(id).value) > 0);
      return { state: 'optional', label: hasAdditive ? 'Added' : 'Optional' };
    }
    if (stageId === 5) {
      const pct = toNumber(document.getElementById('additiveFragrancePct').value);
      const name = document.getElementById('additiveFragranceName')?.value?.trim();
      const hasFragrance = pct > 0 || !!name;
      return { state: 'optional', label: hasFragrance ? 'Added' : 'Optional' };
    }
    if (stageId === 6) {
      return { state: 'info', label: 'Reference' };
    }
    if (stageId === 7) {
      const hasLines = ['tool-ingredients', 'tool-consumables', 'tool-containers'].some(id => {
        return document.querySelectorAll(`#${id} .row`).length > 0;
      });
      return { state: 'optional', label: hasLines ? 'Added' : 'Optional' };
    }
    return { state: 'incomplete', label: 'Incomplete' };
  }

  function updateStageStatuses(){
    STAGE_CONFIGS.forEach(stage => {
      const heading = document.getElementById(stage.headingId);
      const button = heading?.querySelector('.accordion-button');
      if (!button) return;
      let badge = button.querySelector('.soap-stage-status');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'badge bg-secondary ms-2 soap-stage-status';
        button.appendChild(badge);
      }
      const status = getStageCompletion(stage.id);
      badge.textContent = status.label;
      badge.classList.remove('bg-secondary', 'bg-success', 'bg-warning', 'bg-info');
      if (status.state === 'complete') badge.classList.add('bg-success');
      if (status.state === 'incomplete') badge.classList.add('bg-warning');
      if (status.state === 'optional') badge.classList.add('bg-secondary');
      if (status.state === 'info') badge.classList.add('bg-info');
    });
    const requiredStages = STAGE_CONFIGS.filter(stage => stage.required);
    const completeCount = requiredStages.filter(stage => getStageCompletion(stage.id).state === 'complete').length;
    const progress = document.getElementById('soapStageProgress');
    if (progress) progress.textContent = `${completeCount}/${requiredStages.length} complete`;
  }

  function initQualityTooltips(){
    document.querySelectorAll('.soap-quality-help').forEach(btn => {
      const key = btn.dataset.quality;
      if (QUALITY_HINTS[key]) {
        btn.setAttribute('title', QUALITY_HINTS[key]);
      }
    });
    if (window.bootstrap?.Tooltip) {
      document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => {
        bootstrap.Tooltip.getOrCreateInstance(el);
      });
    }
  }

  function updateDownloadPreview(){
    const summary = {
      oils: document.getElementById('downloadSummaryOils'),
      lye: document.getElementById('downloadSummaryLye'),
      water: document.getElementById('downloadSummaryWater'),
      yield: document.getElementById('downloadSummaryYield'),
      superfat: document.getElementById('downloadSummarySuperfat'),
    };
    const list = document.getElementById('soapDownloadInciList');
    const empty = document.getElementById('soapDownloadPreviewEmpty');
    if (!list || !empty) return;
    const calc = state.lastCalc || calculateAll({ consumeQuota: false, showAlerts: false });
    if (!calc) {
      empty.classList.remove('d-none');
      list.innerHTML = '';
      Object.values(summary).forEach(el => { if (el) el.textContent = '--'; });
      return;
    }
    empty.classList.add('d-none');
    const payload = buildSoapRecipePayload(calc);
    list.innerHTML = '';
    if (!payload.ingredients.length) {
      const li = document.createElement('li');
      li.textContent = 'Add oils to build an INCI list.';
      list.appendChild(li);
    } else {
      payload.ingredients.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item.name || 'Ingredient';
        list.appendChild(li);
      });
    }
    if (summary.oils) summary.oils.textContent = formatWeight(calc.totalOils || 0);
    if (summary.lye) summary.lye.textContent = formatWeight(calc.lyeAdjusted || 0);
    if (summary.water) summary.water.textContent = formatWeight(calc.water || 0);
    if (summary.yield) summary.yield.textContent = formatWeight(calc.batchYield || 0);
    if (summary.superfat) summary.superfat.textContent = formatPercent(calc.superfat || 0);
  }

  const ALERT_ICONS = {
    info: 'fa-info-circle',
    warning: 'fa-exclamation-triangle',
    danger: 'fa-times-circle',
    success: 'fa-check-circle'
  };

  function showSoapAlert(type, message, options = {}){
    if (!alertStack) return;
    const icon = ALERT_ICONS[type] || ALERT_ICONS.info;
    const alert = document.createElement('div');
    alert.className = `alert alert-${type} d-flex align-items-start gap-2`;
    alert.innerHTML = `
      <i class="fas ${icon} mt-1"></i>
      <div class="flex-grow-1">${message}</div>
      ${options.dismissible ? '<button type="button" class="btn-close" data-role="dismiss"></button>' : ''}
    `;
    if (options.dismissible) {
      alert.querySelector('[data-role="dismiss"]')?.addEventListener('click', () => alert.remove());
    }
    alertStack.prepend(alert);
    if (!options.persist) {
      setTimeout(() => {
        if (alert.parentNode) alert.remove();
      }, options.timeoutMs || 4500);
    }
  }

  function clearSoapAlerts(){
    if (!alertStack) return;
    alertStack.querySelectorAll('.alert').forEach(el => el.remove());
  }

  function round(value, decimals = 3){
    if (!isFinite(value)) return 0;
    const factor = Math.pow(10, decimals);
    return Math.round(value * factor) / factor;
  }

  function toNumber(value){
    let cleaned = value;
    if (typeof cleaned === 'string') {
      cleaned = cleaned.replace(/,/g, '').trim();
    }
    const num = parseFloat(cleaned);
    return isFinite(num) ? num : 0;
  }

  function clamp(value, min, max){
    if (!isFinite(value)) return min;
    if (value < min) return min;
    if (max !== undefined && max !== null && value > max) return max;
    return value;
  }

  function toGrams(value){
    return clamp(toNumber(value), 0) * (UNIT_FACTORS[currentUnit] || 1);
  }

  function fromGrams(value){
    const grams = clamp(value, 0);
    return grams / (UNIT_FACTORS[currentUnit] || 1);
  }

  function updateUnitLabels(){
    document.querySelectorAll('.unit-label').forEach(el => {
      el.textContent = currentUnit;
    });
  }

  function setUnit(unit, options = {}){
    if (!unit) return;
    if (unit === currentUnit) {
      updateUnitLabels();
      return;
    }
    const prevUnit = currentUnit;
    currentUnit = unit;
    updateUnitLabels();
    if (options.skipConvert) return;
    const ratio = (UNIT_FACTORS[prevUnit] || 1) / (UNIT_FACTORS[unit] || 1);
    document.querySelectorAll('.oil-grams').forEach(input => {
      const value = toNumber(input.value);
      if (value > 0) input.value = round(value * ratio, 2);
    });
    const oilTarget = document.getElementById('oilTotalTarget');
    if (oilTarget && oilTarget.value) {
      const value = toNumber(oilTarget.value);
      if (value > 0) oilTarget.value = round(value * ratio, 2);
    }
    const moldWater = document.getElementById('moldWaterWeight');
    if (moldWater && moldWater.value) {
      const value = toNumber(moldWater.value);
      if (value > 0) moldWater.value = round(value * ratio, 2);
    }
    updateOilTotals();
    updateMoldSuggested();
    updateAdditivesOutput(getTotalOilsGrams());
    if (!options.skipAutoCalc) {
      calculateAll({ consumeQuota: false, showAlerts: false });
    }
  }

  function formatWeight(value){
    if (!isFinite(value) || value <= 0) return '--';
    return `${round(fromGrams(value), 2)} ${currentUnit}`;
  }

  function getTotalOilsGrams(){
    return state.totalOilsGrams || 0;
  }

  function formatPercent(value){
    if (!isFinite(value)) return '--';
    return `${round(value, 1)}%`;
  }

  function getItemCategoryName(item){
    if (!item || typeof item !== 'object') return null;
    return (item.ingredient && item.ingredient.ingredient_category_name)
      || item.ingredient_category_name
      || (item.ingredient_category && item.ingredient_category.name)
      || null;
  }

  function matchesCategory(item, allowedSet, source){
    const category = getItemCategoryName(item);
    if (!category) {
      return source === 'inventory';
    }
    return allowedSet.has(category);
  }

  function getLyeSelection(){
    const selected = document.querySelector('input[name="lye_type"]:checked')?.value || 'NaOH';
    const purityInput = document.getElementById('lyePurity');
    let purity = toNumber(purityInput?.value);
    const lyeType = selected === 'NaOH' ? 'NaOH' : 'KOH';
    if (selected === 'KOH90') {
      purity = 90;
    }
    return { selected, lyeType, purity };
  }

  function applyLyeSelection(){
    const purityInput = document.getElementById('lyePurity');
    if (!purityInput) return;
    const selection = getLyeSelection();
    if (selection.selected === 'KOH90') {
      purityInput.value = '90';
      purityInput.setAttribute('readonly', 'readonly');
      const hint = document.getElementById('lyePurityHint');
      if (hint) hint.textContent = '90% KOH selected (purity locked).';
    } else {
      purityInput.removeAttribute('readonly');
      const hint = document.getElementById('lyePurityHint');
      if (hint) hint.textContent = 'Most calculators assume 100%.';
    }
  }

  function attachOilTypeahead(row){
    const input = row.querySelector('.oil-typeahead');
    const hiddenSap = row.querySelector('.oil-sap-koh');
    const hiddenIodine = row.querySelector('.oil-iodine');
    const hiddenFatty = row.querySelector('.oil-fatty');
    const hiddenGi = row.querySelector('.oil-gi-id');
    const list = row.querySelector('[data-role="suggestions"]');
    if (!input || !list || typeof window.attachMergedInventoryGlobalTypeahead !== 'function') {
      return;
    }
    window.attachMergedInventoryGlobalTypeahead({
      inputEl: input,
      listEl: list,
      mode: IS_AUTHENTICATED ? 'recipe' : 'public',
      giHiddenEl: hiddenGi,
      includeInventory: IS_AUTHENTICATED,
      includeGlobal: true,
      ingredientFirst: true,
      searchType: 'ingredient',
      resultFilter: (item, source) => matchesCategory(item, OIL_CATEGORY_SET, source),
      requireHidden: false,
      onSelection: function(picked){
        if (hiddenSap) {
          hiddenSap.value = picked?.saponification_value || '';
        }
        if (hiddenIodine) {
          hiddenIodine.value = picked?.iodine_value || '';
        }
        if (hiddenFatty) {
          hiddenFatty.value = picked?.fatty_acid_profile ? JSON.stringify(picked.fatty_acid_profile) : '';
        }
        setSelectedOilProfile(picked);
        updateOilTotals();
        queueStateSave();
        queueAutoCalc();
      }
    });
    input.addEventListener('input', function(){
      if (!this.value.trim()) {
        if (hiddenSap) hiddenSap.value = '';
        if (hiddenIodine) hiddenIodine.value = '';
        if (hiddenFatty) hiddenFatty.value = '';
        if (hiddenGi) hiddenGi.value = '';
        clearSelectedOilProfile();
      }
    });
  }

  function attachAdditiveTypeahead(inputId, hiddenId, categorySet){
    const input = document.getElementById(inputId);
    const hidden = document.getElementById(hiddenId);
    const list = input?.parentElement?.querySelector('[data-role="suggestions"]');
    if (!input || !list || typeof window.attachMergedInventoryGlobalTypeahead !== 'function') return;
    window.attachMergedInventoryGlobalTypeahead({
      inputEl: input,
      listEl: list,
      mode: IS_AUTHENTICATED ? 'recipe' : 'public',
      giHiddenEl: hidden,
      includeInventory: IS_AUTHENTICATED,
      includeGlobal: true,
      ingredientFirst: false,
      searchType: 'ingredient',
      resultFilter: (item, source) => matchesCategory(item, categorySet, source),
      requireHidden: false,
      onSelection: function(){
        queueStateSave();
      }
    });
  }

  function buildOilRow(){
    const row = document.createElement('div');
    row.className = 'row g-2 align-items-end oil-row mb-2';
    row.innerHTML = `
      <div class="col-md-6">
        <label class="form-label">Oil, fat, or wax</label>
        <div class="position-relative">
          <input type="text" class="form-control oil-typeahead" placeholder="Search oils, butters, waxes...">
          <input type="hidden" class="oil-sap-koh">
          <input type="hidden" class="oil-iodine">
          <input type="hidden" class="oil-fatty">
          <input type="hidden" class="oil-gi-id">
          <div class="list-group position-absolute w-100 d-none" data-role="suggestions" style="z-index:1050"></div>
        </div>
        <div class="form-text small text-muted">Filtered to oils, butters, and waxes.</div>
      </div>
      <div class="col-md-3">
        <label class="form-label">Weight <span class="badge rounded-pill soap-unit-chip unit-label">g</span></label>
        <input type="number" class="form-control oil-grams" min="0" step="0.1">
      </div>
      <div class="col-md-2">
        <label class="form-label">%</label>
        <input type="number" class="form-control oil-percent" min="0" step="0.1">
      </div>
      <div class="col-md-1 d-grid">
        <button class="btn btn-outline-danger remove-oil" type="button">Remove</button>
      </div>`;
    const mobileProfile = document.createElement('div');
    mobileProfile.className = 'col-12 d-lg-none mt-2';
    mobileProfile.innerHTML = '<button class="btn btn-sm btn-outline-secondary w-100 oil-profile-open" type="button">View oil profile</button>';
    row.appendChild(mobileProfile);
    row.querySelectorAll('.form-text').forEach(text => {
      const wrapper = text.closest('.col-md-6, .col-md-3, .col-md-2');
      if (wrapper) wrapper.classList.add('soap-field');
    });
    attachOilTypeahead(row);
    row.querySelectorAll('.unit-label').forEach(el => {
      el.textContent = currentUnit;
    });
    return row;
  }

  function getOilTargetGrams(){
    const mold = getMoldSettings();
    if (mold.targetOils > 0) return mold.targetOils;
    return toGrams(document.getElementById('oilTotalTarget').value);
  }

  function deriveTargetFromRows(rows){
    const derived = [];
    rows.forEach(row => {
      const grams = toGrams(row.querySelector('.oil-grams')?.value);
      const pct = clamp(toNumber(row.querySelector('.oil-percent')?.value), 0);
      if (grams > 0 && pct > 0) {
        derived.push(grams / (pct / 100));
      }
    });
    if (!derived.length) return 0;
    const sum = derived.reduce((acc, value) => acc + value, 0);
    return sum / derived.length;
  }

  function enforceOilTargetCap(rows, target){
    if (!state.lastOilEdit || !state.lastOilEdit.row) return false;
    const lastRow = state.lastOilEdit.row;
    const otherTotal = rows.reduce((acc, row) => {
      if (row === lastRow) return acc;
      return acc + toGrams(row.querySelector('.oil-grams')?.value);
    }, 0);
    const allowed = Math.max(0, target - otherTotal);
    const gramsInput = lastRow.querySelector('.oil-grams');
    const pctInput = lastRow.querySelector('.oil-percent');
    if (!gramsInput || !pctInput) return false;
    gramsInput.value = allowed > 0 ? round(fromGrams(allowed), 2) : '';
    pctInput.value = allowed > 0 ? round((allowed / target) * 100, 2) : '';
    state.wasCapped = true;
    return true;
  }

  function updateOilLimitWarning({ totalWeight, totalPct, target, capped }){
    const warning = document.getElementById('oilLimitWarning');
    if (!warning) return;
    const messages = [];
    if (capped) {
      messages.push('Oil total hit the mold cap and was adjusted.');
    }
    if (target > 0 && totalWeight > target + 0.01) {
      const over = totalWeight - target;
      messages.push(`Oil weights exceed the target by ${round(fromGrams(over), 2)} ${currentUnit}.`);
    }
    if (totalPct > 100.01) {
      messages.push(`Oil percentages are over 100% by ${round(totalPct - 100, 2)}%.`);
    }
    if (messages.length) {
      warning.classList.remove('d-none');
      warning.innerHTML = `${messages.join(' ')} Adjust oils or mold % to continue.`;
    } else {
      warning.classList.add('d-none');
      warning.textContent = '';
    }
  }

  function updateOilTotals(options = {}){
    if (!options.skipEnforce) {
      state.wasCapped = false;
    }
    const rows = Array.from(document.querySelectorAll('#oilRows .oil-row'));
    const mold = getMoldSettings();
    let target = getOilTargetGrams();
    if (!target && !mold.targetOils) {
      const derived = deriveTargetFromRows(rows);
      if (derived > 0) {
        target = derived;
        const targetInput = document.getElementById('oilTotalTarget');
        if (targetInput && !targetInput.value) {
          targetInput.value = round(fromGrams(derived), 2);
        }
      }
    }

    let totalWeight = 0;
    let totalPct = 0;

    rows.forEach(row => {
      const gramsInput = row.querySelector('.oil-grams');
      const pctInput = row.querySelector('.oil-percent');
      let grams = toGrams(gramsInput?.value);
      let pct = clamp(toNumber(pctInput?.value), 0);
      if (target > 0) {
        if (state.lastOilEdit && state.lastOilEdit.row === row && state.lastOilEdit.field === 'percent') {
          grams = pct > 0 ? target * (pct / 100) : 0;
          gramsInput.value = pct > 0 ? round(fromGrams(grams), 2) : '';
        } else {
          if (grams > 0) {
            pct = (grams / target) * 100;
            pctInput.value = round(pct, 2);
          } else if (pct > 0) {
            grams = target * (pct / 100);
            gramsInput.value = round(fromGrams(grams), 2);
          }
        }
        totalPct += pct;
      }
      if (grams > 0) totalWeight += grams;
    });

    if (target <= 0) {
      if (totalWeight > 0) {
        totalPct = 0;
        rows.forEach(row => {
          const gramsInput = row.querySelector('.oil-grams');
          const pctInput = row.querySelector('.oil-percent');
          const grams = toGrams(gramsInput?.value);
          if (grams > 0) {
            const pct = (grams / totalWeight) * 100;
            pctInput.value = round(pct, 2);
            totalPct += pct;
          }
        });
      } else {
        totalPct = rows.reduce((sum, row) => sum + clamp(toNumber(row.querySelector('.oil-percent')?.value), 0), 0);
      }
    }

    if (!options.skipEnforce && mold.targetOils > 0 && totalWeight > mold.targetOils + 0.01) {
      if (enforceOilTargetCap(rows, mold.targetOils)) {
        return updateOilTotals({ skipEnforce: true });
      }
    }

    state.totalOilsGrams = totalWeight;
    const totalLabel = document.getElementById('oilTotalComputed');
    if (totalLabel) {
      totalLabel.textContent = totalWeight > 0 ? `${round(fromGrams(totalWeight), 2)} ${currentUnit}` : '--';
    }
    document.getElementById('oilPercentTotal').textContent = round(totalPct, 2);
    updateOilLimitWarning({ totalWeight, totalPct, target, capped: state.wasCapped });
    updateAdditivesOutput(totalWeight);
    updateMoldSuggested();
    updateOilTips();
    return { totalWeight, totalPct, target };
  }

  function normalizeOils(){
    const rows = Array.from(document.querySelectorAll('#oilRows .oil-row'));
    if (!rows.length) return;
    const target = getOilTargetGrams();
    let totalPct = rows.reduce((sum, row) => sum + clamp(toNumber(row.querySelector('.oil-percent')?.value), 0), 0);
    if (!totalPct && target > 0) {
      totalPct = rows.reduce((sum, row) => {
        const grams = toGrams(row.querySelector('.oil-grams')?.value);
        return sum + (grams > 0 ? (grams / target) * 100 : 0);
      }, 0);
    }
    if (totalPct <= 0) return;
    rows.forEach(row => {
      const pctInput = row.querySelector('.oil-percent');
      const gramsInput = row.querySelector('.oil-grams');
      const pct = clamp(toNumber(pctInput.value), 0);
      const nextPct = (pct / totalPct) * 100;
      pctInput.value = round(nextPct, 2);
      if (target > 0) {
        gramsInput.value = nextPct > 0 ? round(fromGrams(target * (nextPct / 100)), 2) : '';
      }
    });
    updateOilTotals();
  }

  function collectOilData(){
    const oils = [];
    document.querySelectorAll('#oilRows .oil-row').forEach(row => {
      const name = row.querySelector('.oil-typeahead')?.value?.trim();
      const grams = toGrams(row.querySelector('.oil-grams')?.value);
      const sapKoh = toNumber(row.querySelector('.oil-sap-koh')?.value);
      const iodine = toNumber(row.querySelector('.oil-iodine')?.value);
      const fattyRaw = row.querySelector('.oil-fatty')?.value || '';
      const gi = row.querySelector('.oil-gi-id')?.value || '';
      let fattyProfile = null;
      if (fattyRaw) {
        try {
          fattyProfile = JSON.parse(fattyRaw);
        } catch (_) {
          fattyProfile = null;
        }
      }
      if (grams <= 0) return;
      oils.push({
        name: name || null,
        grams,
        sapKoh,
        iodine,
        fattyProfile,
        global_item_id: gi ? parseInt(gi) : null,
      });
    });
    return oils;
  }

  function updateSelectedOilProfileDisplay({ name, sapKoh, iodine, fattyProfile } = {}){
    const floatCard = document.getElementById('oilProfileFloat');
    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    };
    const nameLabel = name || 'Pick an oil to preview';
    setText('selectedOilName', nameLabel);
    setText('selectedOilModalName', nameLabel);
    if (floatCard) {
      floatCard.classList.toggle('d-none', !name);
    }
    const sapValue = sapKoh > 0 ? round(sapKoh, 1) : '--';
    const iodineValue = iodine > 0 ? round(iodine, 1) : '--';
    setText('selectedOilSap', sapValue);
    setText('selectedOilModalSap', sapValue);
    setText('selectedOilIodine', iodineValue);
    setText('selectedOilModalIodine', iodineValue);

    const qualities = fattyProfile ? computeQualities(fattyProfile) : {};
    const setValue = (id, value) => {
      const safe = isFinite(value) && value > 0 ? round(value, 1) : '--';
      setText(id, safe);
    };
    setValue('selectedOilHardness', qualities.hardness);
    setValue('selectedOilModalHardness', qualities.hardness);
    setValue('selectedOilCleansing', qualities.cleansing);
    setValue('selectedOilModalCleansing', qualities.cleansing);
    setValue('selectedOilConditioning', qualities.conditioning);
    setValue('selectedOilModalConditioning', qualities.conditioning);
    setValue('selectedOilBubbly', qualities.bubbly);
    setValue('selectedOilModalBubbly', qualities.bubbly);
    setValue('selectedOilCreamy', qualities.creamy);
    setValue('selectedOilModalCreamy', qualities.creamy);

    const fattyKeys = ['lauric', 'myristic', 'palmitic', 'stearic', 'ricinoleic', 'oleic', 'linoleic', 'linolenic'];
    fattyKeys.forEach(key => {
      const baseId = `selectedOil${key.charAt(0).toUpperCase()}${key.slice(1)}`;
      const modalId = `selectedOilModal${key.charAt(0).toUpperCase()}${key.slice(1)}`;
      const value = fattyProfile ? toNumber(fattyProfile[key]) : 0;
      const safe = value > 0 ? round(value, 1) : '--';
      setText(baseId, safe);
      setText(modalId, safe);
    });
  }

  function setSelectedOilProfile(picked){
    if (!picked) {
      clearSelectedOilProfile();
      return;
    }
    state.selectedOilProfile = picked;
    let fattyProfile = picked.fatty_acid_profile || null;
    if (typeof fattyProfile === 'string') {
      try {
        fattyProfile = JSON.parse(fattyProfile);
      } catch (_) {
        fattyProfile = null;
      }
    }
    updateSelectedOilProfileDisplay({
      name: picked.text || picked.display_name || picked.name,
      sapKoh: toNumber(picked.saponification_value),
      iodine: toNumber(picked.iodine_value),
      fattyProfile,
    });
  }

  function setSelectedOilProfileFromRow(row){
    if (!row) return;
    const name = row.querySelector('.oil-typeahead')?.value?.trim();
    const sapKoh = toNumber(row.querySelector('.oil-sap-koh')?.value);
    const iodine = toNumber(row.querySelector('.oil-iodine')?.value);
    const fattyRaw = row.querySelector('.oil-fatty')?.value || '';
    let fattyProfile = null;
    if (fattyRaw) {
      try {
        fattyProfile = JSON.parse(fattyRaw);
      } catch (_) {
        fattyProfile = null;
      }
    }
    updateSelectedOilProfileDisplay({
      name,
      sapKoh,
      iodine,
      fattyProfile,
    });
  }

  function clearSelectedOilProfile(){
    state.selectedOilProfile = null;
    state.lastPreviewRow = null;
    updateSelectedOilProfileDisplay();
  }

  function syncStageHeight(){
    const stagePane = document.getElementById('soapStagePane');
    const qualityCard = document.getElementById('soapQualityCard');
    if (!stagePane || !qualityCard) return;
    const shouldSync = window.matchMedia('(min-width: 768px)').matches;
    if (!shouldSync) {
      stagePane.classList.remove('is-height-synced');
      stagePane.style.removeProperty('--soap-stage-height');
      return;
    }
    const qualityHeight = qualityCard.offsetHeight;
    if (!qualityHeight) {
      stagePane.classList.remove('is-height-synced');
      stagePane.style.removeProperty('--soap-stage-height');
      return;
    }
    stagePane.style.setProperty('--soap-stage-height', `${qualityHeight}px`);
    if (stagePane.classList.contains('is-overlay-open')) {
      stagePane.classList.remove('is-height-synced');
      return;
    }
    stagePane.classList.add('is-height-synced');
  }

  const scheduleStageHeightSync = () => {
    window.requestAnimationFrame(syncStageHeight);
  };

  function updateStageAccordionLayout(){
    const stageAccordion = document.getElementById('soapStageAccordion');
    const stagePane = document.getElementById('soapStagePane');
    if (!stageAccordion) return;
    const allowOverlay = window.matchMedia('(min-width: 768px)').matches;
    let hasOpen = false;
    stageAccordion.querySelectorAll('.accordion-item').forEach(item => {
      const collapse = item.querySelector('.accordion-collapse');
      const isOpen = collapse ? collapse.classList.contains('show') : false;
      item.classList.toggle('is-open', isOpen);
      if (isOpen) {
        hasOpen = true;
      }
    });
    if (stagePane) {
      const overlay = allowOverlay && hasOpen;
      stagePane.classList.toggle('is-overlay-open', overlay);
      if (overlay) {
        stagePane.classList.remove('is-height-synced');
        stagePane.style.removeProperty('--soap-stage-height');
      }
    }
  }

  function updateOilTips(){
    const tipBox = document.getElementById('oilBlendTips');
    if (!tipBox) return;
    const oils = collectOilData().filter(oil => oil.grams > 0 || oil.percent > 0);
    if (!oils.length) {
      tipBox.classList.add('d-none');
      tipBox.textContent = '';
      return;
    }
    const tips = new Set();
    oils.forEach(oil => {
      const name = (oil.name || '').toLowerCase();
      if (name) {
        OIL_TIP_RULES.forEach(rule => {
          if (rule.match.test(name)) tips.add(rule.tip);
        });
      }
      if (oil.fattyProfile && typeof oil.fattyProfile === 'object') {
        const lauric = toNumber(oil.fattyProfile.lauric);
        const myristic = toNumber(oil.fattyProfile.myristic);
        const palmitic = toNumber(oil.fattyProfile.palmitic);
        const stearic = toNumber(oil.fattyProfile.stearic);
        const ricinoleic = toNumber(oil.fattyProfile.ricinoleic);
        const oleic = toNumber(oil.fattyProfile.oleic);
        const linoleic = toNumber(oil.fattyProfile.linoleic);
        const linolenic = toNumber(oil.fattyProfile.linolenic);
        if (lauric + myristic >= 30) {
          tips.add(`${oil.name || 'This oil'} is high in lauric/myristic; expect faster trace and stronger cleansing.`);
        }
        if (palmitic + stearic >= 40) {
          tips.add(`${oil.name || 'This oil'} is high in palmitic/stearic; expect a harder bar and quicker set-up.`);
        }
        if (oleic >= 60) {
          tips.add(`${oil.name || 'This oil'} is high oleic; trace may be slow and bars may start softer.`);
        }
        if (linoleic + linolenic >= 20) {
          tips.add(`${oil.name || 'This oil'} is high in PUFAs; keep the % lower to reduce DOS risk.`);
        }
        if (ricinoleic >= 60) {
          tips.add(`${oil.name || 'This oil'} boosts lather but can feel tacky; keep under 10-15%.`);
        }
      }
    });
    const tipList = Array.from(tips).slice(0, 6);
    if (!tipList.length) {
      tipBox.classList.add('d-none');
      tipBox.textContent = '';
      return;
    }
    tipBox.classList.remove('d-none');
    tipBox.innerHTML = `<strong>Blend behavior tips:</strong><ul class="mb-0">${tipList.map(tip => `<li>${tip}</li>`).join('')}</ul>`;
  }

  function computeLyeTotals(oils, lyeType){
    let lyeTotal = 0;
    let sapWeighted = 0;
    let sapWeightG = 0;
    let totalWeight = 0;
    oils.forEach(oil => {
      totalWeight += oil.grams;
      if (oil.sapKoh > 0) {
        const perG = lyeType === 'KOH'
          ? (oil.sapKoh / 1000)
          : (oil.sapKoh * 0.713 / 1000);
        lyeTotal += oil.grams * perG;
        sapWeighted += oil.sapKoh * oil.grams;
        sapWeightG += oil.grams;
      }
    });
    const sapAvg = sapWeightG > 0 ? sapWeighted / sapWeightG : 0;
    const usedFallback = lyeTotal <= 0 && totalWeight > 0;
    if (usedFallback) {
      const fallbackPerG = lyeType === 'KOH' ? 0.194 : 0.138;
      lyeTotal = totalWeight * fallbackPerG;
    }
    return { lyeTotal, sapAvg, usedFallback };
  }

  function computeWater(lyeAdjusted, totalOils, method, waterPct, lyeConcentration, waterRatio){
    let waterG = 0;
    if (lyeAdjusted <= 0) {
      return { waterG: 0, lyeConcentration: 0, waterRatio: 0 };
    }
    if (method === 'concentration') {
      const conc = lyeConcentration > 0 ? lyeConcentration : 33;
      waterG = lyeAdjusted * ((100 - conc) / conc);
    } else if (method === 'ratio') {
      const ratio = waterRatio > 0 ? waterRatio : 2;
      waterG = lyeAdjusted * ratio;
    } else {
      const pct = waterPct > 0 ? waterPct : 33;
      waterG = totalOils * (pct / 100);
    }
    const lyeConc = waterG + lyeAdjusted > 0 ? (lyeAdjusted / (lyeAdjusted + waterG)) * 100 : 0;
    const ratio = lyeAdjusted > 0 ? (waterG / lyeAdjusted) : 0;
    return { waterG, lyeConcentration: lyeConc, waterRatio: ratio };
  }

  function computeIodine(oils){
    let totalWeight = 0;
    let weighted = 0;
    oils.forEach(oil => {
      if (oil.iodine > 0) {
        totalWeight += oil.grams;
        weighted += oil.iodine * oil.grams;
      }
    });
    return {
      iodine: totalWeight > 0 ? weighted / totalWeight : 0,
      coverageWeight: totalWeight,
    };
  }

  function computeFattyAcids(oils){
    const totals = {};
    let coveredWeight = 0;
    oils.forEach(oil => {
      if (!oil.fattyProfile || typeof oil.fattyProfile !== 'object') {
        return;
      }
      coveredWeight += oil.grams;
      Object.entries(oil.fattyProfile).forEach(([key, pct]) => {
        const value = toNumber(pct);
        if (value > 0) {
          totals[key] = (totals[key] || 0) + oil.grams * (value / 100);
        }
      });
    });
    const percent = {};
    if (coveredWeight > 0) {
      Object.entries(totals).forEach(([key, grams]) => {
        percent[key] = (grams / coveredWeight) * 100;
      });
    }
    return { percent, coveredWeight };
  }

  function computeQualities(fattyPercent){
    const get = key => fattyPercent[key] || 0;
    return {
      hardness: get('lauric') + get('myristic') + get('palmitic') + get('stearic'),
      cleansing: get('lauric') + get('myristic'),
      conditioning: get('oleic') + get('linoleic') + get('linolenic') + get('ricinoleic'),
      bubbly: get('lauric') + get('myristic') + get('ricinoleic'),
      creamy: get('palmitic') + get('stearic') + get('ricinoleic'),
    };
  }

  function setProgress(id, value, label){
    const bar = document.getElementById(id);
    if (!bar) return;
    if (!isFinite(value)) {
      bar.style.width = '0%';
      return;
    }
    const clamped = Math.max(0, Math.min(100, value));
    bar.style.width = `${clamped}%`;
    bar.setAttribute('aria-valuemin', '0');
    bar.setAttribute('aria-valuemax', '100');
    bar.setAttribute('aria-valuenow', clamped.toFixed(1));
    if (label) {
      bar.setAttribute('aria-label', label);
    }
  }

  function setQualityRangeBars(){
    const rangeConfig = {
      hardness: { range: QUALITY_RANGES.hardness, scale: 100 },
      cleansing: { range: QUALITY_RANGES.cleansing, scale: 100 },
      conditioning: { range: QUALITY_RANGES.conditioning, scale: 100 },
      bubbly: { range: QUALITY_RANGES.bubbly, scale: 100 },
      creamy: { range: QUALITY_RANGES.creamy, scale: 100 },
      iodine: { range: IODINE_RANGE, scale: IODINE_SCALE_MAX },
      ins: { range: INS_RANGE, scale: INS_SCALE_MAX },
    };
    Object.entries(rangeConfig).forEach(([key, config]) => {
      const [min, max] = config.range;
      const scale = config.scale;
      const name = key.charAt(0).toUpperCase() + key.slice(1);
      const start = document.getElementById(`quality${name}RangeStart`);
      const ideal = document.getElementById(`quality${name}RangeIdeal`);
      const end = document.getElementById(`quality${name}RangeEnd`);
      if (start && ideal && end) {
        const startPct = Math.max(0, Math.min(100, (min / scale) * 100));
        const idealPct = Math.max(0, Math.min(100, ((max - min) / scale) * 100));
        const endPct = Math.max(0, Math.min(100, 100 - ((max / scale) * 100)));
        start.style.width = `${startPct}%`;
        ideal.style.width = `${idealPct}%`;
        end.style.width = `${endPct}%`;
      }
      const minLabel = document.getElementById(`quality${name}RangeMin`);
      const maxLabel = document.getElementById(`quality${name}RangeMax`);
      if (minLabel) minLabel.textContent = round(min, 0);
      if (maxLabel) maxLabel.textContent = round(max, 0);
    });
  }

  function setQualityBarColor(bar, value, range){
    if (!bar || !range) return;
    bar.classList.remove('bg-success', 'bg-warning', 'bg-danger', 'bg-secondary');
    if (!isFinite(value)) {
      bar.classList.add('bg-secondary');
      return;
    }
    if (value < range[0]) {
      bar.classList.add('bg-warning');
    } else if (value > range[1]) {
      bar.classList.add('bg-danger');
    } else {
      bar.classList.add('bg-success');
    }
  }

  function setScaledBar(id, value, range, max, label){
    const bar = document.getElementById(id);
    if (!bar) return;
    const safeValue = isFinite(value) ? value : 0;
    const clamped = Math.max(0, Math.min(max, safeValue));
    const width = max > 0 ? (clamped / max) * 100 : 0;
    bar.style.width = `${width}%`;
    bar.setAttribute('aria-valuemin', '0');
    bar.setAttribute('aria-valuemax', String(max));
    bar.setAttribute('aria-valuenow', clamped.toFixed(1));
    if (label) {
      bar.setAttribute('aria-label', label);
    }
    setQualityBarColor(bar, safeValue, range);
  }

  function toggleQualitySliders(){
    const wrap = document.getElementById('qualitySliderWrap');
    const toggle = document.getElementById('qualitySliderToggle');
    if (!wrap || !toggle) return;
    wrap.classList.toggle('d-none', !toggle.checked);
  }

  function updateQualitySliders(qualities, superfat){
    const hardness = clamp(qualities.hardness || 0, 0, 100);
    const bubbly = clamp(qualities.bubbly || 0, 0, 100);
    const conditioning = clamp(qualities.conditioning || 0, 0, 100);
    const greasyScore = clamp(conditioning + (superfat || 0) * 3, 0, 100);
    const hardEl = document.getElementById('feelHardness');
    const bubblyEl = document.getElementById('feelBubbly');
    const conditioningEl = document.getElementById('feelConditioning');
    const greasyEl = document.getElementById('feelGreasy');
    if (hardEl) hardEl.value = round(hardness, 1);
    if (bubblyEl) bubblyEl.value = round(bubbly, 1);
    if (conditioningEl) conditioningEl.value = round(conditioning, 1);
    if (greasyEl) greasyEl.value = round(greasyScore, 1);
  }

  function updateFattyBar(fattyPercent){
    const totals = {};
    let total = 0;
    FATTY_DISPLAY_KEYS.forEach(key => {
      const value = clamp(toNumber(fattyPercent[key]), 0, 100);
      totals[key] = value;
      total += value;
    });
    FATTY_DISPLAY_KEYS.forEach(key => {
      const el = document.getElementById(`fattyBar${key.charAt(0).toUpperCase()}${key.slice(1)}`);
      if (!el) return;
      const width = total > 0 ? (totals[key] / total) * 100 : 0;
      el.style.width = `${width}%`;
      el.style.backgroundColor = FATTY_BAR_COLORS[key] || 'var(--color-muted)';
      el.title = `${key.charAt(0).toUpperCase()}${key.slice(1)}: ${round(totals[key], 1)}%`;
    });
  }

  function getQualityTargets(){
    const preset = document.getElementById('qualityPreset')?.value || 'balanced';
    const focusEls = Array.from(document.querySelectorAll('.quality-focus:checked'));
    if (preset === 'none' && !focusEls.length) return null;
    const base = preset === 'none'
      ? { ...QUALITY_BASE }
      : (QUALITY_PRESETS[preset] ? { ...QUALITY_PRESETS[preset] } : { ...QUALITY_BASE });
    focusEls.forEach(el => {
      const attr = el.dataset.attr;
      const direction = el.dataset.direction;
      const range = QUALITY_RANGES[attr];
      if (!range) return;
      base[attr] = direction === 'low' ? range[0] : range[1];
    });
    return base;
  }

  function updateQualityTargets(){
    const targets = getQualityTargets();
    const markers = {
      hardness: document.getElementById('qualityHardnessTarget'),
      cleansing: document.getElementById('qualityCleansingTarget'),
      conditioning: document.getElementById('qualityConditioningTarget'),
      bubbly: document.getElementById('qualityBubblyTarget'),
      creamy: document.getElementById('qualityCreamyTarget'),
      iodine: document.getElementById('iodineTarget'),
      ins: document.getElementById('insTarget'),
    };
    Object.entries(markers).forEach(([key, marker]) => {
      if (!marker) return;
      const labelEl = document.getElementById(`${marker.id}Label`);
      if (!targets) {
        marker.classList.add('d-none');
        if (labelEl) labelEl.textContent = '';
        return;
      }
      const value = toNumber(targets[key]);
      if (!isFinite(value)) {
        marker.classList.add('d-none');
        if (labelEl) labelEl.textContent = '';
        return;
      }
      const scaleMax = key === 'iodine' ? IODINE_SCALE_MAX : (key === 'ins' ? INS_SCALE_MAX : 100);
      const clamped = clamp(value, 0, scaleMax);
      marker.classList.remove('d-none');
      marker.style.left = `${(clamped / scaleMax) * 100}%`;
      marker.setAttribute('aria-label', `Apply ${key} target`);
      marker.setAttribute('role', 'button');
      marker.setAttribute('tabindex', '0');
      marker.title = `Target ${key}: ${round(value, 1)}`;
      if (labelEl) {
        labelEl.textContent = round(value, 1);
      }
    });
  }

  function computeOilQualityScores(fattyProfile){
    if (!fattyProfile || typeof fattyProfile !== 'object') {
      return {
        hardness: 0,
        cleansing: 0,
        conditioning: 0,
        bubbly: 0,
        creamy: 0,
      };
    }
    const profile = {
      lauric: toNumber(fattyProfile.lauric),
      myristic: toNumber(fattyProfile.myristic),
      palmitic: toNumber(fattyProfile.palmitic),
      stearic: toNumber(fattyProfile.stearic),
      ricinoleic: toNumber(fattyProfile.ricinoleic),
      oleic: toNumber(fattyProfile.oleic),
      linoleic: toNumber(fattyProfile.linoleic),
      linolenic: toNumber(fattyProfile.linolenic),
    };
    const qualities = computeQualities(profile);
    return {
      hardness: (qualities.hardness || 0) / 100,
      cleansing: (qualities.cleansing || 0) / 100,
      conditioning: (qualities.conditioning || 0) / 100,
      bubbly: (qualities.bubbly || 0) / 100,
      creamy: (qualities.creamy || 0) / 100,
    };
  }

  function applyQualityTargets(){
    const targets = getQualityTargets();
    if (!targets) {
      showSoapAlert('info', 'Select a quality target to nudge the blend.', { dismissible: true, timeoutMs: 5000 });
      return;
    }
    const rows = Array.from(document.querySelectorAll('#oilRows .oil-row'));
    const oils = rows.map(row => {
      const grams = toGrams(row.querySelector('.oil-grams')?.value);
      const fattyRaw = row.querySelector('.oil-fatty')?.value || '';
      let fattyProfile = null;
      if (fattyRaw) {
        try {
          fattyProfile = JSON.parse(fattyRaw);
        } catch (_) {
          fattyProfile = null;
        }
      }
      return { row, grams, fattyProfile };
    }).filter(item => item.grams > 0);

    if (!oils.length) {
      showSoapAlert('warning', 'Add oils before nudging toward a target.', { dismissible: true, timeoutMs: 5000 });
      return;
    }

    const fatty = computeFattyAcids(oils.map(oil => ({
      grams: oil.grams,
      fattyProfile: oil.fattyProfile,
    })));
    const currentQualities = computeQualities(fatty.percent);
    const deltas = {
      hardness: clamp((targets.hardness - currentQualities.hardness) / 100, -1, 1),
      cleansing: clamp((targets.cleansing - currentQualities.cleansing) / 100, -1, 1),
      conditioning: clamp((targets.conditioning - currentQualities.conditioning) / 100, -1, 1),
      bubbly: clamp((targets.bubbly - currentQualities.bubbly) / 100, -1, 1),
      creamy: clamp((targets.creamy - currentQualities.creamy) / 100, -1, 1),
    };

    const totalOils = oils.reduce((sum, oil) => sum + oil.grams, 0);
    const adjusted = [];
    let totalAdjusted = 0;
    const strength = 0.8;
    const missingFatty = oils.filter(oil => !oil.fattyProfile || typeof oil.fattyProfile !== 'object').length;
    if (missingFatty === oils.length) {
      showSoapAlert('warning', 'None of the selected oils have fatty acid data, so targets cannot be applied.', { dismissible: true, timeoutMs: 6000 });
      return;
    }
    if (missingFatty) {
      showSoapAlert('info', 'Some oils are missing fatty acid data. The nudge will only use oils with profiles.', { dismissible: true, timeoutMs: 5000 });
    }

    oils.forEach(oil => {
      const scores = computeOilQualityScores(oil.fattyProfile);
      const adjustment = (deltas.hardness * scores.hardness)
        + (deltas.cleansing * scores.cleansing)
        + (deltas.conditioning * scores.conditioning)
        + (deltas.bubbly * scores.bubbly)
        + (deltas.creamy * scores.creamy);
      const factor = clamp(1 + adjustment * strength, 0.2, 1.8);
      const next = oil.grams * factor;
      adjusted.push({ row: oil.row, grams: next });
      totalAdjusted += next;
    });

    if (totalAdjusted <= 0) {
      showSoapAlert('warning', 'Unable to adjust blend with current data.', { dismissible: true, timeoutMs: 5000 });
      return;
    }

    const scale = totalOils / totalAdjusted;
    const target = getOilTargetGrams() || totalOils;
    adjusted.forEach(item => {
      const grams = item.grams * scale;
      const gramsInput = item.row.querySelector('.oil-grams');
      const pctInput = item.row.querySelector('.oil-percent');
      if (gramsInput) gramsInput.value = grams > 0 ? round(fromGrams(grams), 2) : '';
      if (pctInput && target > 0) {
        const percent = (grams / target) * 100;
        pctInput.value = percent > 0 ? round(percent, 2) : '';
      }
    });

    updateOilTotals();
    queueStateSave();
    queueAutoCalc();
    showSoapAlert('info', 'Blend nudged toward selected targets. Re-check results and adjust as needed.', { dismissible: true, timeoutMs: 6000 });
  }

  function buildSoapNotesBlob(calc){
    const iodineData = computeIodine(calc.oils || []);
    const fatty = computeFattyAcids(calc.oils || []);
    const qualities = computeQualities(fatty.percent || {});
    const lyeTotals = computeLyeTotals(calc.oils || [], calc.lyeType);
    const ins = (lyeTotals.sapAvg && iodineData.iodine) ? (lyeTotals.sapAvg - iodineData.iodine) : 0;
    const mold = getMoldSettings();
    return {
      source: 'soap_tool',
      schema_version: 1,
      unit_display: currentUnit,
      input_mode: 'mixed',
      quality_preset: document.getElementById('qualityPreset')?.value || 'balanced',
      quality_focus: Array.from(document.querySelectorAll('.quality-focus:checked')).map(el => el.id),
      mold,
      oils: (calc.oils || []).map(oil => ({
        name: oil.name || null,
        grams: round(oil.grams || 0, 2),
        iodine: oil.iodine || null,
        sap_koh: oil.sapKoh || null,
        fatty_profile: oil.fattyProfile || null,
        global_item_id: oil.global_item_id || null,
      })),
      totals: {
        total_oils_g: round(calc.totalOils || 0, 2),
        batch_yield_g: round(calc.batchYield || 0, 2),
        lye_pure_g: round(calc.lyePure || 0, 2),
        lye_adjusted_g: round(calc.lyeAdjusted || 0, 2),
        water_g: round(calc.water || 0, 2),
      },
      lye: {
        lye_type: calc.lyeType,
        superfat: calc.superfat,
        purity: calc.purity,
        water_method: calc.waterMethod,
        water_pct: calc.waterPct,
        lye_concentration: calc.lyeConcentration,
        water_ratio: calc.waterRatio,
      },
      additives: {
        fragrance_pct: calc.additives?.fragrancePct || 0,
        lactate_pct: calc.additives?.lactatePct || 0,
        sugar_pct: calc.additives?.sugarPct || 0,
        salt_pct: calc.additives?.saltPct || 0,
        citric_pct: calc.additives?.citricPct || 0,
        fragrance_g: round(calc.additives?.fragranceG || 0, 2),
        lactate_g: round(calc.additives?.lactateG || 0, 2),
        sugar_g: round(calc.additives?.sugarG || 0, 2),
        salt_g: round(calc.additives?.saltG || 0, 2),
        citric_g: round(calc.additives?.citricG || 0, 2),
        citric_lye_g: round(calc.additives?.citricLyeG || 0, 2),
      },
      qualities: {
        hardness: round(qualities.hardness || 0, 1),
        cleansing: round(qualities.cleansing || 0, 1),
        conditioning: round(qualities.conditioning || 0, 1),
        bubbly: round(qualities.bubbly || 0, 1),
        creamy: round(qualities.creamy || 0, 1),
        iodine: round(iodineData.iodine || 0, 1),
        ins: round(ins || 0, 1),
        sap_avg: round(lyeTotals.sapAvg || 0, 1),
      },
      fatty_acids: fatty.percent || {},
      updated_at: new Date().toISOString(),
    };
  }

  function getAdditiveItem(nameId, giId, fallbackName){
    const name = document.getElementById(nameId)?.value?.trim();
    const giRaw = document.getElementById(giId)?.value || '';
    return {
      name: name || fallbackName,
      globalItemId: giRaw ? parseInt(giRaw) : undefined,
    };
  }

  function buildSoapRecipePayload(calc){
    const notesBlob = buildSoapNotesBlob(calc);
    const baseIngredients = (calc.oils || []).map(oil => ({
      name: oil.name || undefined,
      global_item_id: oil.global_item_id || undefined,
      quantity: oil.grams,
      unit: 'gram',
    }));
    const lyeName = calc.lyeType === 'KOH' ? 'Potassium Hydroxide (KOH)' : 'Sodium Hydroxide (NaOH)';
    if (calc.lyeAdjusted > 0) {
      baseIngredients.push({ name: lyeName, quantity: round(calc.lyeAdjusted, 2), unit: 'gram' });
    }
    if (calc.water > 0) {
      baseIngredients.push({ name: 'Distilled Water', quantity: round(calc.water, 2), unit: 'gram' });
    }
    if (calc.additives?.fragranceG > 0) {
      const item = getAdditiveItem('additiveFragranceName', 'additiveFragranceGi', 'Fragrance/Essential Oils');
      baseIngredients.push({ name: item.name, global_item_id: item.globalItemId, quantity: round(calc.additives.fragranceG, 2), unit: 'gram' });
    }
    if (calc.additives?.lactateG > 0) {
      const item = getAdditiveItem('additiveLactateName', 'additiveLactateGi', 'Sodium Lactate');
      baseIngredients.push({ name: item.name, global_item_id: item.globalItemId, quantity: round(calc.additives.lactateG, 2), unit: 'gram' });
    }
    if (calc.additives?.sugarG > 0) {
      const item = getAdditiveItem('additiveSugarName', 'additiveSugarGi', 'Sugar');
      baseIngredients.push({ name: item.name, global_item_id: item.globalItemId, quantity: round(calc.additives.sugarG, 2), unit: 'gram' });
    }
    if (calc.additives?.saltG > 0) {
      const item = getAdditiveItem('additiveSaltName', 'additiveSaltGi', 'Salt');
      baseIngredients.push({ name: item.name, global_item_id: item.globalItemId, quantity: round(calc.additives.saltG, 2), unit: 'gram' });
    }
    if (calc.additives?.citricG > 0) {
      const item = getAdditiveItem('additiveCitricName', 'additiveCitricGi', 'Citric Acid');
      baseIngredients.push({ name: item.name, global_item_id: item.globalItemId, quantity: round(calc.additives.citricG, 2), unit: 'gram' });
      baseIngredients.push({ name: 'Extra Lye for Citric Acid', quantity: round(calc.additives.citricLyeG, 2), unit: 'gram' });
    }
    return {
      name: 'Soap (Draft)',
      instructions: 'Draft from Soap Tools',
      predicted_yield: Math.round((calc.batchYield || 0) * 100) / 100,
      predicted_yield_unit: 'gram',
      category_name: 'Soaps',
      category_data: {
        soap_superfat: calc.superfat,
        soap_lye_type: calc.lyeType,
        soap_lye_purity: calc.purity,
        soap_water_method: calc.waterMethod,
        soap_water_pct: calc.waterPct,
        soap_lye_concentration: calc.lyeConcentration,
        soap_water_ratio: calc.waterRatio,
        soap_oils_total_g: calc.totalOils,
        soap_lye_g: calc.lyeAdjusted,
        soap_water_g: calc.water,
      },
      ingredients: baseIngredients.concat(collectDraftLines('tool-ingredients', 'ingredient')),
      consumables: collectDraftLines('tool-consumables', 'consumable'),
      containers: collectDraftLines('tool-containers', 'container'),
      notes: JSON.stringify(notesBlob),
    };
  }

  function applySectionOrder(order){
    const container = document.getElementById('soapAdvancedAccordion');
    if (!container || !Array.isArray(order)) return;
    const items = Array.from(container.querySelectorAll('.accordion-item'));
    const map = new Map(items.map(item => [item.dataset.section, item]));
    order.forEach(key => {
      const item = map.get(key);
      if (item) container.appendChild(item);
    });
    items.forEach(item => {
      if (!order.includes(item.dataset.section)) {
        container.appendChild(item);
      }
    });
  }

  function enableAccordionReorder(){
    const container = document.getElementById('soapAdvancedAccordion');
    if (!container) return;
    let dragged = null;
    container.querySelectorAll('.accordion-header').forEach(header => {
      header.setAttribute('draggable', 'true');
      header.style.cursor = 'grab';
      header.addEventListener('dragstart', event => {
        dragged = header.closest('.accordion-item');
        event.dataTransfer.effectAllowed = 'move';
      });
      header.addEventListener('dragend', () => {
        dragged = null;
      });
    });
    container.addEventListener('dragover', event => {
      event.preventDefault();
      const targetItem = event.target.closest('.accordion-item');
      if (!dragged || !targetItem || targetItem === dragged) return;
      const rect = targetItem.getBoundingClientRect();
      const after = (event.clientY - rect.top) > rect.height / 2;
      container.insertBefore(dragged, after ? targetItem.nextSibling : targetItem);
    });
    container.addEventListener('drop', () => {
      queueStateSave();
    });
  }

  function collectDraftLines(wrapperId, kind){
    const out = [];
    document.querySelectorAll(`#${wrapperId} .row`).forEach(function(row){
      const name = row.querySelector('.tool-typeahead')?.value?.trim();
      const gi = row.querySelector('.tool-gi-id')?.value || '';
      const qtyEl = row.querySelector('.tool-qty');
      const unitEl = row.querySelector('.tool-unit');
      const hasQty = qtyEl && qtyEl.value !== '';
      if (!name && !gi) return;
      if (kind === 'container'){
        out.push({ name: name || undefined, global_item_id: gi ? parseInt(gi) : undefined, quantity: hasQty ? parseFloat(qtyEl.value) : 1 });
      } else {
        out.push({ name: name || undefined, global_item_id: gi ? parseInt(gi) : undefined, quantity: hasQty ? parseFloat(qtyEl.value) : 0, unit: (unitEl?.value || '').trim() || 'gram' });
      }
    });
    return out;
  }

  function updateQualitiesDisplay(data){
    const {
      qualities,
      fattyPercent,
      coveragePct,
      iodine,
      ins,
      sapAvg,
      superfat,
      waterData,
      additives,
      oils,
      totalOils,
    } = data;

    const hasCoverage = coveragePct > 0;

    function setQuality(name, value){
      const label = document.getElementById(`quality${name}Value`);
      const bar = document.getElementById(`quality${name}Bar`);
      const hintEl = document.getElementById(`quality${name}Hint`);
      if (!label) return;
      label.textContent = hasCoverage && isFinite(value) ? round(value, 1) : '--';
      pulseValue(label);
      setProgress(`quality${name}Bar`, hasCoverage ? value : 0, name);
      const rangeKey = name.toLowerCase();
      const range = QUALITY_RANGES[rangeKey];
      if (bar && range) {
        setQualityBarColor(bar, value, range);
        if (hasCoverage && isFinite(value)) {
          bar.title = `${name}: ${round(value, 1)} (ideal ${range[0]}-${range[1]}). ${QUALITY_HINTS[rangeKey] || ''}`.trim();
        } else {
          bar.title = `${name}: -- (ideal ${range[0]}-${range[1]}). ${QUALITY_HINTS[rangeKey] || ''}`.trim();
        }
      }
      if (hintEl && range) {
        if (!hasCoverage || !isFinite(value)) {
          hintEl.textContent = '';
        } else if (value < range[0]) {
          hintEl.textContent = QUALITY_FEEL_HINTS[rangeKey]?.low || '';
        } else if (value > range[1]) {
          hintEl.textContent = QUALITY_FEEL_HINTS[rangeKey]?.high || '';
        } else {
          hintEl.textContent = QUALITY_FEEL_HINTS[rangeKey]?.ok || '';
        }
      }
    }

    setQuality('Hardness', qualities.hardness);
    setQuality('Cleansing', qualities.cleansing);
    setQuality('Conditioning', qualities.conditioning);
    setQuality('Bubbly', qualities.bubbly);
    setQuality('Creamy', qualities.creamy);

    const coverageNote = document.getElementById('fattyCoverageNote');
    if (coverageNote) {
      coverageNote.textContent = coveragePct > 0
        ? `Fatty acid coverage: ${round(coveragePct, 1)}% of oils`
        : 'Fatty acid coverage: not enough data yet';
    }

    const iodineEl = document.getElementById('iodineValue');
    const insEl = document.getElementById('insValue');
    const sapEl = document.getElementById('sapAvgValue');
    if (iodineEl) {
      iodineEl.textContent = iodine > 0 ? round(iodine, 1) : '--';
      pulseValue(iodineEl);
    }
    if (insEl) {
      insEl.textContent = ins > 0 ? round(ins, 1) : '--';
      pulseValue(insEl);
    }
    if (sapEl) {
      sapEl.textContent = sapAvg > 0 ? round(sapAvg, 1) : '--';
      pulseValue(sapEl);
    }
    setScaledBar('iodineBar', iodine, IODINE_RANGE, IODINE_SCALE_MAX, 'Iodine');
    setScaledBar('insBar', ins, INS_RANGE, INS_SCALE_MAX, 'INS');

    const sat = (fattyPercent.lauric || 0) + (fattyPercent.myristic || 0) + (fattyPercent.palmitic || 0) + (fattyPercent.stearic || 0);
    const unsat = (fattyPercent.ricinoleic || 0) + (fattyPercent.oleic || 0) + (fattyPercent.linoleic || 0) + (fattyPercent.linolenic || 0);
    const ratioEl = document.getElementById('fattySatRatio');
    if (ratioEl) {
      ratioEl.textContent = (sat + unsat) > 0 ? `${round(sat, 0)}:${round(unsat, 0)}` : '--';
      pulseValue(ratioEl);
    }

    FATTY_DISPLAY_KEYS.forEach(key => {
      const id = `fatty${key.charAt(0).toUpperCase()}${key.slice(1)}`;
      const value = fattyPercent[key];
      document.getElementById(id).textContent = hasCoverage && value ? `${round(value, 1)}%` : '--';
    });
    updateQualitySliders(qualities, superfat || 0);
    updateFattyBar(fattyPercent);
    updateQualityTargets();

    const warnings = [];
    const pufa = (fattyPercent.linoleic || 0) + (fattyPercent.linolenic || 0);
    const lauricMyristic = (fattyPercent.lauric || 0) + (fattyPercent.myristic || 0);
    const concentration = waterData?.lyeConcentration || 0;

    if (iodine > 70) warnings.push('High iodine value can mean softer bars or faster rancidity.');
    if (ins > 0 && ins < 136) warnings.push('INS is low (below 136); bars may be soft or have shorter shelf life.');
    if (ins > 170) warnings.push('INS is high; bars may be brittle or overly cleansing.');
    if (hasCoverage && pufa > 15) warnings.push('High linoleic/linolenic (PUFA) increases DOS risk; consider antioxidant or more stable oils.');
    if (hasCoverage && isFinite(qualities.hardness) && qualities.hardness < QUALITY_RANGES.hardness[0]) warnings.push('Hardness looks low; bars may be soft or slow to unmold.');
    if (hasCoverage && isFinite(qualities.cleansing) && qualities.cleansing > QUALITY_RANGES.cleansing[1]) warnings.push('Cleansing is high; consider more conditioning oils.');
    if (hasCoverage && isFinite(qualities.bubbly) && qualities.bubbly < QUALITY_RANGES.bubbly[0]) warnings.push('Bubbly lather is low; add 5-10% castor or coconut for more foam.');
    if (hasCoverage && lauricMyristic > 35) warnings.push('High lauric/myristic (coconut/palm kernel/babassu) can be drying or crumbly; cut warm and keep superfat at least 5%.');
    if (superfat !== undefined && superfat >= 15) warnings.push('Superfat is high (15%+); bars can be softer/greasy and may have shorter shelf life.');
    if (concentration > 0 && concentration < 27) warnings.push('Very high water: slower trace and more shrinkage/ash. Consider a higher lye concentration for a firmer bar sooner.');
    if (concentration > 40) warnings.push('Low water: faster trace and more heat. Work quickly and avoid overheating.');
    if (additives?.fragrancePct > 3) warnings.push('Fragrance load above 3% can accelerate trace; follow supplier usage rates.');
    if (additives?.citricPct > 0) warnings.push('Citric acid consumes lye; extra lye has been added. Recheck if you also use vinegar or other acids.');
    if (Array.isArray(oils) && totalOils > 0) {
      const positiveOils = oils.filter(oil => oil.grams > 0);
      if (positiveOils.length === 1) {
        warnings.push('Single-oil recipe; consider blending for balanced hardness, cleansing, and longevity.');
      } else if (positiveOils.length > 1) {
        const maxShare = Math.max(...positiveOils.map(oil => (oil.grams / totalOils) * 100));
        if (maxShare >= 90) warnings.push('One oil is over 90% of the formula; consider blending for balance.');
      }
    }
    const warningBox = document.getElementById('soapQualityWarnings');
    if (warnings.length) {
      warningBox.classList.remove('d-none');
      warningBox.innerHTML = `<strong>Guidance & flags:</strong><ul class="mb-0">${warnings.map(w => `<li>${w}</li>`).join('')}</ul>`;
    } else {
      warningBox.classList.add('d-none');
      warningBox.textContent = '';
    }
    scheduleStageHeightSync();
  }

  function updateVisualGuidance(data){
    const list = document.getElementById('soapVisualGuidanceList');
    if (!list) return;
    const tips = [];
    const waterConc = data?.waterData?.lyeConcentration || 0;
    const additives = data?.additives || {};
    const fattyPercent = data?.fattyPercent || {};
    const lauricMyristic = (fattyPercent.lauric || 0) + (fattyPercent.myristic || 0);

    if (waterConc > 0 && waterConc < 28) {
      tips.push('High water can cause soda ash, warping, or glycerin rivers; keep temps even or use less water.');
    }
    if (waterConc > 40) {
      tips.push('Low water (strong lye) can overheat or crack; soap cooler and watch for volcanoing.');
    }
    if (additives.sugarPct > 1) {
      tips.push('Sugars add heat; soap cooler to avoid cracking or glycerin rivers.');
    }
    if (additives.saltPct > 1) {
      tips.push('Salt can make bars brittle; cut sooner than usual.');
    }
    if (lauricMyristic > 35) {
      tips.push('High lauric oils can crumble if cut cold; cut warm for clean edges.');
    }
    if (!tips.length) {
      tips.push('No visual flags detected for this formula.');
    }

    list.innerHTML = tips.map(tip => `<li>${tip}</li>`).join('');
  }

  function computeAdditives(totalOils, lyeType){
    const baseOils = clamp(totalOils, 0);
    const fragrancePct = clamp(toNumber(document.getElementById('additiveFragrancePct').value), 0, 100);
    const lactatePct = clamp(toNumber(document.getElementById('additiveLactatePct').value), 0, 100);
    const sugarPct = clamp(toNumber(document.getElementById('additiveSugarPct').value), 0, 100);
    const saltPct = clamp(toNumber(document.getElementById('additiveSaltPct').value), 0, 100);
    const citricPct = clamp(toNumber(document.getElementById('additiveCitricPct').value), 0, 100);
    const fragranceG = baseOils * (fragrancePct / 100);
    const lactateG = baseOils * (lactatePct / 100);
    const sugarG = baseOils * (sugarPct / 100);
    const saltG = baseOils * (saltPct / 100);
    const citricG = baseOils * (citricPct / 100);
    const citricLyeFactor = lyeType === 'KOH' ? 0.719 : 0.624;
    const citricLyeG = citricG * citricLyeFactor;
    return {
      fragrancePct,
      lactatePct,
      sugarPct,
      saltPct,
      citricPct,
      fragranceG,
      lactateG,
      sugarG,
      saltG,
      citricG,
      citricLyeG,
    };
  }

  function updateAdditivesOutput(totalOils){
    const lyeType = getLyeSelection().lyeType || 'NaOH';
    const outputs = computeAdditives(totalOils || 0, lyeType);
    document.getElementById('additiveFragranceOut').textContent = formatWeight(outputs.fragranceG);
    document.getElementById('additiveLactateOut').textContent = formatWeight(outputs.lactateG);
    document.getElementById('additiveSugarOut').textContent = formatWeight(outputs.sugarG);
    document.getElementById('additiveSaltOut').textContent = formatWeight(outputs.saltG);
    document.getElementById('additiveCitricOut').textContent = formatWeight(outputs.citricG);
    document.getElementById('additiveCitricLyeOut').textContent = formatWeight(outputs.citricLyeG);
    return outputs;
  }

  function updateMoldSuggested(){
    const settings = getMoldSettings();
    const targetInput = document.getElementById('oilTotalTarget');
    const targetHint = document.getElementById('oilTargetHint');
    if (settings.targetOils > 0 && targetInput) {
      targetInput.value = round(fromGrams(settings.targetOils), 2);
      targetInput.setAttribute('readonly', 'readonly');
      if (targetHint) targetHint.textContent = 'Derived from mold sizing.';
    } else if (targetInput) {
      targetInput.removeAttribute('readonly');
      if (targetHint) targetHint.textContent = 'Auto-fills when mold sizing is set.';
    }
    const note = document.getElementById('moldSuggestionNote');
    if (note) {
      let message = 'Target oils are capped to the mold size above.';
      if (settings.shape === 'cylinder' && settings.waterWeight > 0) {
        if (settings.useCylinder) {
          message = `Cylinder correction applied (${round(settings.cylinderFactor * 100, 0)}% of capacity).`;
        } else {
          message = 'Cylinder mold selected. Apply a correction if you want headspace or a smaller fill.';
        }
      }
      note.textContent = message;
    }
  }

  function getMoldSettings(){
    const waterWeight = toGrams(document.getElementById('moldWaterWeight').value);
    const oilPct = clamp(toNumber(document.getElementById('moldOilPct').value), 0, 100);
    const shape = document.getElementById('moldShape')?.value || 'loaf';
    const useCylinder = !!document.getElementById('moldCylinderCorrection')?.checked;
    const cylinderFactor = clamp(toNumber(document.getElementById('moldCylinderFactor')?.value), 0.5, 1);
    const effectiveCapacity = waterWeight > 0 ? waterWeight * (useCylinder ? cylinderFactor : 1) : 0;
    const targetOils = effectiveCapacity > 0 ? effectiveCapacity * (oilPct / 100) : 0;
    return {
      waterWeight,
      oilPct,
      shape,
      useCylinder,
      cylinderFactor,
      effectiveCapacity,
      targetOils,
    };
  }

  function updateMoldShapeUI(){
    const shape = document.getElementById('moldShape')?.value || 'loaf';
    const options = document.getElementById('moldCylinderOptions');
    if (options) {
      options.classList.toggle('d-none', shape !== 'cylinder');
    }
    updateMoldSuggested();
  }

  function setWaterMethod(){
    const method = document.getElementById('waterMethod').value;
    document.querySelectorAll('.water-input').forEach(el => {
      el.classList.toggle('d-none', el.dataset.method !== method);
    });
  }

  function getStorage(){
    try {
      return window.localStorage;
    } catch (_) {
      return null;
    }
  }

  function readCalcUsage(){
    if (!CALC_LIMIT) return { count: 0, date: null };
    const storage = getStorage();
    if (!storage) return { count: 0, date: null };
    try {
      const raw = storage.getItem('soap_calc_usage');
      const today = new Date().toISOString().slice(0, 10);
      if (!raw) return { count: 0, date: today };
      const data = JSON.parse(raw);
      if (!data || data.date !== today) {
        return { count: 0, date: today };
      }
      return { count: Number(data.count) || 0, date: today };
    } catch (_) {
      return { count: 0, date: null };
    }
  }

  function writeCalcUsage(count){
    if (!CALC_LIMIT) return;
    const storage = getStorage();
    if (!storage) return;
    const today = new Date().toISOString().slice(0, 10);
    try {
      storage.setItem('soap_calc_usage', JSON.stringify({ count, date: today }));
    } catch (_) {}
  }

  function canConsumeCalcQuota(){
    if (!CALC_LIMIT) return true;
    const usage = readCalcUsage();
    if (usage.count >= CALC_LIMIT) {
      showSoapAlert('warning', `You have reached the ${CALC_LIMIT} calculation limit for ${CALC_LIMIT_TIER} accounts. Create a free account or upgrade to keep calculating.`, { dismissible: true });
      return false;
    }
    return true;
  }

  function consumeCalcQuota(){
    if (!CALC_LIMIT) return;
    const usage = readCalcUsage();
    const nextCount = usage.count + 1;
    writeCalcUsage(nextCount);
    const remaining = Math.max(0, CALC_LIMIT - nextCount);
    if (remaining <= 1) {
      showSoapAlert('info', `You have ${remaining} calculation${remaining === 1 ? '' : 's'} left on the ${CALC_LIMIT_TIER} tier today.`, { dismissible: true, timeoutMs: 6000 });
    }
  }

  function getCalcRemaining(){
    if (!CALC_LIMIT) return null;
    const usage = readCalcUsage();
    return Math.max(0, CALC_LIMIT - usage.count);
  }

  function maybeShowSignupModal(remaining){
    if (!CALC_LIMIT || remaining === null || remaining > 1) return;
    const modalEl = document.getElementById('soapSignupModal');
    if (!modalEl) return;
    if (window.bootstrap && window.bootstrap.Modal) {
      const modal = window.bootstrap.Modal.getOrCreateInstance(modalEl);
      modal.show();
    } else {
      showSoapAlert('info', 'You are almost at the free limit. Create a free account to keep saving your work.', { dismissible: true, timeoutMs: 7000 });
    }
  }

  function validateCalculation(){
    const totals = updateOilTotals();
    const totalOils = totals.totalWeight;
    const totalPct = totals.totalPct;
    const errors = [];
    const oils = collectOilData();
    const target = getOilTargetGrams();
    const percentInputs = Array.from(document.querySelectorAll('#oilRows .oil-percent'))
      .map(input => clamp(toNumber(input.value), 0));
    const hasPercent = percentInputs.some(value => value > 0);

    if (!oils.length || totalOils <= 0) {
      errors.push('Add at least one oil with a weight or percent.');
    }
    if (!target && totalOils <= 0 && hasPercent) {
      errors.push('Enter a total oils target or weights to convert percentages.');
    }
    if (target > 0 && totalPct > 0 && Math.abs(totalPct - 100) > 0.5) {
      errors.push('Oil percentages should total 100% (use Normalize to fix).');
    }
    if (target > 0 && totalOils > target + 0.01) {
      errors.push('Oil weights exceed the mold target.');
    } else if (!target && totalPct > 100.01) {
      errors.push('Oil percentages exceed 100%.');
    }
    return { ok: errors.length === 0, errors, totals, oils };
  }

  function sanitizeLyeInputs(){
    const selection = getLyeSelection();
    const purityInput = document.getElementById('lyePurity');
    let purity = selection.purity;
    if (!purity || purity <= 0) {
      purity = 100;
    }
    purity = Math.min(100, Math.max(90, purity));
    if (selection.selected === 'KOH90') {
      purity = 90;
    }
    if (purityInput) {
      purityInput.value = round(purity, 1);
    }

    const waterMethod = document.getElementById('waterMethod')?.value || 'percent';
    let waterPct = toNumber(document.getElementById('waterPct')?.value);
    let lyeConcentration = toNumber(document.getElementById('lyeConcentration')?.value);
    let waterRatio = toNumber(document.getElementById('waterRatio')?.value);

    if (waterMethod === 'percent') {
      if (!waterPct || waterPct <= 0) {
        waterPct = 33;
      }
      waterPct = clamp(waterPct, 20, 50);
      const input = document.getElementById('waterPct');
      if (input) input.value = round(waterPct, 1);
    }
    if (waterMethod === 'concentration') {
      if (!lyeConcentration || lyeConcentration <= 0) {
        lyeConcentration = 33;
      }
      lyeConcentration = clamp(lyeConcentration, 20, 50);
      const input = document.getElementById('lyeConcentration');
      if (input) input.value = round(lyeConcentration, 1);
    }
    if (waterMethod === 'ratio') {
      if (!waterRatio || waterRatio <= 0) {
        waterRatio = 2;
      }
      waterRatio = clamp(waterRatio, 1, 4);
      const input = document.getElementById('waterRatio');
      if (input) input.value = round(waterRatio, 2);
    }

    return { purity, waterMethod, waterPct, lyeConcentration, waterRatio };
  }

  function calculateAll(options = {}){
    const settings = {
      consumeQuota: false,
      showAlerts: true,
      ...options
    };
    if (settings.showAlerts) {
      clearSoapAlerts();
    }
    const validation = validateCalculation();
    if (!validation.ok) {
      if (settings.showAlerts) {
        showSoapAlert('warning', `<strong>Missing info:</strong><ul class="mb-0">${validation.errors.map(err => `<li>${err}</li>`).join('')}</ul>`, { dismissible: true, persist: true });
      }
      return null;
    }
    if (settings.consumeQuota && !canConsumeCalcQuota()) {
      return null;
    }
    const superfatInput = document.getElementById('lyeSuperfat');
    const superfatRaw = superfatInput?.value;
    let superfat = toNumber(superfatRaw);
    if (superfatRaw === '' || superfatRaw === null || superfatRaw === undefined) {
      superfat = 5;
    }
    superfat = clamp(superfat, 0, 20);
    if (superfatInput) superfatInput.value = round(superfat, 1);
    const selection = getLyeSelection();
    const lyeType = selection.lyeType || 'NaOH';
    const sanitized = sanitizeLyeInputs();
    const purity = sanitized.purity;
    const waterMethod = sanitized.waterMethod;
    const waterPct = sanitized.waterPct;
    const lyeConcentration = sanitized.lyeConcentration;
    const waterRatio = sanitized.waterRatio;

    let oils = validation.oils;
    let totalOils = validation.totals.totalWeight;
    const lyeTotals = computeLyeTotals(oils, lyeType);
    const lyePure = lyeTotals.lyeTotal * (1 - superfat / 100);
    const lyeAdjusted = purity > 0 ? lyePure / (purity / 100) : lyePure;
    const waterData = computeWater(lyeAdjusted, totalOils, waterMethod, waterPct, lyeConcentration, waterRatio);
    const additives = updateAdditivesOutput(totalOils);
    const batchYield = totalOils + lyeAdjusted + waterData.waterG + additives.fragranceG + additives.lactateG + additives.sugarG + additives.saltG + additives.citricG;

    document.getElementById('resultsCard').style.display = 'block';
    document.getElementById('lyeAdjustedOutput').textContent = formatWeight(lyeAdjusted);
    document.getElementById('waterOutput').textContent = formatWeight(waterData.waterG);
    document.getElementById('batchYieldOutput').textContent = formatWeight(batchYield);
    document.getElementById('lyeConcentrationOutput').textContent = formatPercent(waterData.lyeConcentration);
    document.getElementById('waterRatioOutput').textContent = isFinite(waterData.waterRatio) && waterData.waterRatio > 0
      ? round(waterData.waterRatio, 2).toString()
      : '--';
    document.getElementById('totalOilsOutput').textContent = formatWeight(totalOils);
    document.getElementById('superfatOutput').textContent = formatPercent(superfat);

    ['lyeAdjustedOutput', 'waterOutput', 'batchYieldOutput', 'lyeConcentrationOutput', 'waterRatioOutput', 'totalOilsOutput', 'superfatOutput']
      .forEach(id => pulseValue(document.getElementById(id)));
    updateResultsWarnings(waterData);
    updateResultsMeta();

    const iodineData = computeIodine(oils);
    const fatty = computeFattyAcids(oils);
    const qualities = computeQualities(fatty.percent);
    const ins = (lyeTotals.sapAvg && iodineData.iodine) ? (lyeTotals.sapAvg - iodineData.iodine) : 0;
    const coveragePct = totalOils > 0 ? (fatty.coveredWeight / totalOils) * 100 : 0;
    updateQualitiesDisplay({
      qualities,
      fattyPercent: fatty.percent,
      coveragePct,
      iodine: iodineData.iodine,
      ins,
      sapAvg: lyeTotals.sapAvg,
      superfat,
      waterData,
      additives,
      oils,
      totalOils,
    });
    updateVisualGuidance({
      fattyPercent: fatty.percent,
      waterData,
      additives,
    });
    updateStageStatuses();

    if (settings.showAlerts) {
      if (lyeTotals.usedFallback) {
        showSoapAlert('info', 'Some oils are missing SAP values, so an average SAP was used. Select oils with SAP data for the most accurate lye calculation.', { dismissible: true, timeoutMs: 7000 });
      }
      if (purity < 100) {
        showSoapAlert('info', `Lye purity is set to ${round(purity, 1)}%. Adjusting lye to match your real-world purity.`, { dismissible: true, timeoutMs: 6000 });
      }
      if (waterData.lyeConcentration < 25 || waterData.lyeConcentration > 45) {
        showSoapAlert('warning', 'Your lye concentration is outside the common 25-45% range. Expect slower or faster trace.', { dismissible: true, timeoutMs: 7000 });
      }
      const mold = getMoldSettings();
      if (mold.shape === 'cylinder' && mold.waterWeight > 0 && !mold.useCylinder) {
        showSoapAlert('info', 'Cylinder mold selected. Enable the cylinder correction if you want to leave headspace or reduce spill risk.', { dismissible: true, timeoutMs: 7000 });
      }
    }

    state.lastCalc = {
      totalOils,
      oils,
      lyeType,
      superfat,
      purity,
      lyePure,
      lyeAdjusted,
      water: waterData.waterG,
      waterMethod,
      waterPct,
      lyeConcentration: waterData.lyeConcentration,
      waterRatio: waterData.waterRatio,
      additives,
      batchYield,
    };
    if (settings.consumeQuota) {
      consumeCalcQuota();
    }
    return state.lastCalc;
  }

  function buildLineRow(kind){
    const context = IS_AUTHENTICATED ? 'member' : 'public';
    const mode = IS_AUTHENTICATED ? 'recipe' : 'public';
    return buildToolLineRow(kind, { context, mode, unitOptionsHtml: TOOL_UNIT_OPTIONS_HTML });
  }

  function addStubLine(kind, name){
    const row = buildLineRow(kind);
    const input = row.querySelector('.tool-typeahead');
    const qty = row.querySelector('.tool-qty');
    if (input) {
      input.value = name;
    }
    if (qty && kind === 'container') {
      qty.value = 1;
    }
    if (kind === 'container') {
      document.getElementById('tool-containers').appendChild(row);
    } else if (kind === 'consumable') {
      document.getElementById('tool-consumables').appendChild(row);
    } else {
      document.getElementById('tool-ingredients').appendChild(row);
    }
  }

  function serializeLines(wrapperId, kind){
    const out = [];
    const rows = document.querySelectorAll(`#${wrapperId} .row`);
    rows.forEach(row => {
      const name = row.querySelector('.tool-typeahead')?.value?.trim();
      const gi = row.querySelector('.tool-gi-id')?.value || '';
      const qtyEl = row.querySelector('.tool-qty');
      const unitEl = row.querySelector('.tool-unit');
      const qty = qtyEl && qtyEl.value !== '' ? toNumber(qtyEl.value) : null;
      if (!name && !gi) return;
      if (kind === 'container') {
        out.push({
          name: name || '',
          global_item_id: gi ? parseInt(gi) : null,
          quantity: qty && qty > 0 ? qty : 1,
        });
      } else {
        out.push({
          name: name || '',
          global_item_id: gi ? parseInt(gi) : null,
          quantity: qty && qty >= 0 ? qty : 0,
          unit: unitEl?.value || 'gram',
        });
      }
    });
    return out;
  }

  function serializeOils(){
    const oils = [];
    document.querySelectorAll('#oilRows .oil-row').forEach(row => {
      const name = row.querySelector('.oil-typeahead')?.value?.trim() || '';
      const grams = row.querySelector('.oil-grams')?.value || '';
      const percent = row.querySelector('.oil-percent')?.value || '';
      const sap = row.querySelector('.oil-sap-koh')?.value || '';
      const iodine = row.querySelector('.oil-iodine')?.value || '';
      const fattyRaw = row.querySelector('.oil-fatty')?.value || '';
      const gi = row.querySelector('.oil-gi-id')?.value || '';
      if (!name && !grams && !percent && !gi) return;
      oils.push({
        name,
        grams,
        percent,
        sap,
        iodine,
        fattyRaw,
        gi,
      });
    });
    return oils;
  }

  function serializeOilRow(row){
    if (!row) return null;
    return {
      name: row.querySelector('.oil-typeahead')?.value || '',
      grams: row.querySelector('.oil-grams')?.value || '',
      percent: row.querySelector('.oil-percent')?.value || '',
      sap: row.querySelector('.oil-sap-koh')?.value || '',
      iodine: row.querySelector('.oil-iodine')?.value || '',
      fattyRaw: row.querySelector('.oil-fatty')?.value || '',
      gi: row.querySelector('.oil-gi-id')?.value || '',
    };
  }

  function restoreOilRow(data, index){
    const oilRows = document.getElementById('oilRows');
    if (!oilRows || !data) return;
    const row = buildOilRow();
    row.querySelector('.oil-typeahead').value = data.name || '';
    row.querySelector('.oil-grams').value = data.grams || '';
    row.querySelector('.oil-percent').value = data.percent || '';
    row.querySelector('.oil-sap-koh').value = data.sap || '';
    row.querySelector('.oil-iodine').value = data.iodine || '';
    row.querySelector('.oil-fatty').value = data.fattyRaw || '';
    row.querySelector('.oil-gi-id').value = data.gi || '';
    const children = Array.from(oilRows.children);
    if (index >= children.length) {
      oilRows.appendChild(row);
    } else {
      oilRows.insertBefore(row, children[index]);
    }
    return row;
  }

  function saveState(){
    const storage = getStorage();
    if (!storage) return;
    const payload = {
      version: 2,
      unit: currentUnit,
      oil_total_target: document.getElementById('oilTotalTarget').value || '',
      oils: serializeOils(),
      lye_form: {
        superfat: document.getElementById('lyeSuperfat')?.value || '5',
        lye_type: document.querySelector('input[name="lye_type"]:checked')?.value || 'NaOH',
        lye_purity: document.getElementById('lyePurity')?.value || '100',
        water_method: document.getElementById('waterMethod')?.value || 'percent',
        water_pct: document.getElementById('waterPct')?.value || '33',
        lye_concentration: document.getElementById('lyeConcentration')?.value || '33',
        water_ratio: document.getElementById('waterRatio')?.value || '2',
      },
      additives: {
        fragrance_pct: document.getElementById('additiveFragrancePct').value || '3',
        fragrance_name: document.getElementById('additiveFragranceName')?.value || '',
        fragrance_gi: document.getElementById('additiveFragranceGi')?.value || '',
        lactate_pct: document.getElementById('additiveLactatePct').value || '1',
        lactate_name: document.getElementById('additiveLactateName')?.value || '',
        lactate_gi: document.getElementById('additiveLactateGi')?.value || '',
        sugar_pct: document.getElementById('additiveSugarPct').value || '1',
        sugar_name: document.getElementById('additiveSugarName')?.value || '',
        sugar_gi: document.getElementById('additiveSugarGi')?.value || '',
        salt_pct: document.getElementById('additiveSaltPct').value || '0.5',
        salt_name: document.getElementById('additiveSaltName')?.value || '',
        salt_gi: document.getElementById('additiveSaltGi')?.value || '',
        citric_pct: document.getElementById('additiveCitricPct').value || '0',
        citric_name: document.getElementById('additiveCitricName')?.value || '',
        citric_gi: document.getElementById('additiveCitricGi')?.value || '',
      },
      mold: {
        water_weight: document.getElementById('moldWaterWeight').value || '',
        oil_pct: document.getElementById('moldOilPct').value || '65',
        shape: document.getElementById('moldShape')?.value || 'loaf',
        cylinder_correction: !!document.getElementById('moldCylinderCorrection')?.checked,
        cylinder_factor: document.getElementById('moldCylinderFactor')?.value || '0.85',
      },
      quality: {
        preset: document.getElementById('qualityPreset')?.value || 'balanced',
        focus: Array.from(document.querySelectorAll('.quality-focus:checked')).map(el => el.id),
      },
      lines: {
        ingredients: serializeLines('tool-ingredients', 'ingredient'),
        consumables: serializeLines('tool-consumables', 'consumable'),
        containers: serializeLines('tool-containers', 'container'),
      },
      updated_at: Date.now(),
    };
    try {
      storage.setItem(STATE_STORAGE_KEY, JSON.stringify(payload));
      const lastSaved = document.getElementById('soapLastSaved');
      if (lastSaved) lastSaved.textContent = formatTime(payload.updated_at);
      showAutosaveToast();
    } catch (_) {}
  }

  function restoreState(){
    const storage = getStorage();
    if (!storage) return;
    const raw = storage.getItem(STATE_STORAGE_KEY);
    if (!raw) return;
    let data = null;
    try {
      data = JSON.parse(raw);
    } catch (_) {
      return;
    }
    if (!data || typeof data !== 'object') return;

    if (data.unit) {
      const unitInput = document.querySelector(`input[name="weight_unit"][value="${data.unit}"]`);
      if (unitInput) unitInput.checked = true;
      setUnit(data.unit, { skipConvert: true, skipAutoCalc: true });
    }

    if (data.oil_total_target !== undefined) {
      document.getElementById('oilTotalTarget').value = data.oil_total_target;
    }

    const oilRows = document.getElementById('oilRows');
    if (oilRows) {
      oilRows.innerHTML = '';
      const oils = Array.isArray(data.oils) && data.oils.length ? data.oils : [{}];
      oils.forEach(oil => {
        const row = buildOilRow();
        row.querySelector('.oil-typeahead').value = oil.name || '';
        row.querySelector('.oil-grams').value = oil.grams || '';
        row.querySelector('.oil-percent').value = oil.percent || '';
        row.querySelector('.oil-sap-koh').value = oil.sap || '';
        row.querySelector('.oil-iodine').value = oil.iodine || '';
        row.querySelector('.oil-fatty').value = oil.fattyRaw || '';
        row.querySelector('.oil-gi-id').value = oil.gi || '';
        oilRows.appendChild(row);
      });
    }

    if (data.lye_form) {
      const superfat = document.getElementById('lyeSuperfat');
      if (superfat) superfat.value = data.lye_form.superfat || '5';
      const lyeType = document.querySelector(`input[name="lye_type"][value="${data.lye_form.lye_type || 'NaOH'}"]`);
      if (lyeType) lyeType.checked = true;
      const purity = document.getElementById('lyePurity');
      if (purity) purity.value = data.lye_form.lye_purity || '100';
      const waterMethod = document.getElementById('waterMethod');
      if (waterMethod) waterMethod.value = data.lye_form.water_method || 'percent';
      const waterPct = document.getElementById('waterPct');
      if (waterPct) waterPct.value = data.lye_form.water_pct || '33';
      const lyeConcentration = document.getElementById('lyeConcentration');
      if (lyeConcentration) lyeConcentration.value = data.lye_form.lye_concentration || '33';
      const waterRatio = document.getElementById('waterRatio');
      if (waterRatio) waterRatio.value = data.lye_form.water_ratio || '2';
      applyLyeSelection();
    }

    if (data.additives) {
      document.getElementById('additiveFragrancePct').value = data.additives.fragrance_pct || '3';
      const fragranceName = document.getElementById('additiveFragranceName');
      if (fragranceName) fragranceName.value = data.additives.fragrance_name || '';
      const fragranceGi = document.getElementById('additiveFragranceGi');
      if (fragranceGi) fragranceGi.value = data.additives.fragrance_gi || '';
      document.getElementById('additiveLactatePct').value = data.additives.lactate_pct || '1';
      const lactateName = document.getElementById('additiveLactateName');
      if (lactateName) lactateName.value = data.additives.lactate_name || '';
      const lactateGi = document.getElementById('additiveLactateGi');
      if (lactateGi) lactateGi.value = data.additives.lactate_gi || '';
      document.getElementById('additiveSugarPct').value = data.additives.sugar_pct || '1';
      const sugarName = document.getElementById('additiveSugarName');
      if (sugarName) sugarName.value = data.additives.sugar_name || '';
      const sugarGi = document.getElementById('additiveSugarGi');
      if (sugarGi) sugarGi.value = data.additives.sugar_gi || '';
      document.getElementById('additiveSaltPct').value = data.additives.salt_pct || '0.5';
      const saltName = document.getElementById('additiveSaltName');
      if (saltName) saltName.value = data.additives.salt_name || '';
      const saltGi = document.getElementById('additiveSaltGi');
      if (saltGi) saltGi.value = data.additives.salt_gi || '';
      document.getElementById('additiveCitricPct').value = data.additives.citric_pct || '0';
      const citricName = document.getElementById('additiveCitricName');
      if (citricName) citricName.value = data.additives.citric_name || '';
      const citricGi = document.getElementById('additiveCitricGi');
      if (citricGi) citricGi.value = data.additives.citric_gi || '';
    }

    if (data.mold) {
      document.getElementById('moldWaterWeight').value = data.mold.water_weight || '';
      document.getElementById('moldOilPct').value = data.mold.oil_pct || '65';
      const moldShape = document.getElementById('moldShape');
      if (moldShape) moldShape.value = data.mold.shape || 'loaf';
      const cylCorrection = document.getElementById('moldCylinderCorrection');
      if (cylCorrection) cylCorrection.checked = !!data.mold.cylinder_correction;
      const cylFactor = document.getElementById('moldCylinderFactor');
      if (cylFactor) cylFactor.value = data.mold.cylinder_factor || '0.85';
    }
    if (data.quality) {
      const preset = document.getElementById('qualityPreset');
      if (preset) {
        const desired = data.quality.preset || 'balanced';
        const option = Array.from(preset.options).find(opt => opt.value === desired);
        preset.value = option ? desired : 'balanced';
      }
      document.querySelectorAll('.quality-focus').forEach(el => {
        el.checked = Array.isArray(data.quality.focus) && data.quality.focus.includes(el.id);
      });
    }

    function restoreLines(wrapperId, items, kind){
      const wrapper = document.getElementById(wrapperId);
      if (!wrapper) return;
      wrapper.innerHTML = '';
      (items || []).forEach(item => {
        const row = buildLineRow(kind);
        const input = row.querySelector('.tool-typeahead');
        const giHidden = row.querySelector('.tool-gi-id');
        const qtyEl = row.querySelector('.tool-qty');
        const unitEl = row.querySelector('.tool-unit');
        if (input) input.value = item.name || '';
        if (giHidden) giHidden.value = item.global_item_id || '';
        if (qtyEl && item.quantity !== undefined && item.quantity !== null) qtyEl.value = item.quantity;
        if (unitEl && item.unit) {
          const option = Array.from(unitEl.options).find(opt => opt.value === item.unit);
          if (option) unitEl.value = item.unit;
        }
        wrapper.appendChild(row);
      });
    }

    if (data.lines) {
      restoreLines('tool-ingredients', data.lines.ingredients, 'ingredient');
      restoreLines('tool-consumables', data.lines.consumables, 'consumable');
      restoreLines('tool-containers', data.lines.containers, 'container');
    }

    setWaterMethod();
    updateMoldShapeUI();
    updateQualityTargets();
    updateOilTotals();
    updateAdditivesOutput(getTotalOilsGrams());
    updateMoldSuggested();
    calculateAll({ consumeQuota: false, showAlerts: false });
    if (data.updated_at) {
      const lastSaved = document.getElementById('soapLastSaved');
      if (lastSaved) lastSaved.textContent = formatTime(data.updated_at);
    }
    updateStageStatuses();
    showSoapAlert('info', 'Restored your last soap tool session from this device.', { dismissible: true, timeoutMs: 5000 });
  }

  let saveStateTimer = null;
  function queueStateSave(){
    if (saveStateTimer) clearTimeout(saveStateTimer);
    saveStateTimer = setTimeout(saveState, 350);
  }

  let autoCalcTimer = null;
  function queueAutoCalc(){
    if (autoCalcTimer) clearTimeout(autoCalcTimer);
    autoCalcTimer = setTimeout(() => {
      calculateAll({ consumeQuota: false, showAlerts: false });
    }, 350);
  }

  document.getElementById('addOil').addEventListener('click', function(){
    document.getElementById('oilRows').appendChild(buildOilRow());
    updateStageStatuses();
    queueStateSave();
  });

  document.getElementById('normalizeOils').addEventListener('click', function(){
    normalizeOils();
    updateStageStatuses();
    queueStateSave();
    queueAutoCalc();
  });

  document.getElementById('oilRows').addEventListener('input', function(e){
    if (e.target.classList.contains('oil-grams')) {
      state.lastOilEdit = { row: e.target.closest('.oil-row'), field: 'grams' };
    }
    if (e.target.classList.contains('oil-percent')) {
      state.lastOilEdit = { row: e.target.closest('.oil-row'), field: 'percent' };
    }
    if (e.target.classList.contains('oil-grams')
      || e.target.classList.contains('oil-percent')
      || e.target.classList.contains('oil-typeahead')) {
      if (e.target.classList.contains('oil-typeahead')) {
        setSelectedOilProfileFromRow(e.target.closest('.oil-row'));
      }
      updateOilTotals();
      queueStateSave();
      queueAutoCalc();
    }
  });

  document.getElementById('oilRows').addEventListener('focusin', function(e){
    if (e.target.classList.contains('oil-typeahead')) {
      setSelectedOilProfileFromRow(e.target.closest('.oil-row'));
    }
  });

  document.getElementById('oilRows').addEventListener('focusout', function(e){
    if (e.target.classList.contains('oil-typeahead')) {
      clearSelectedOilProfile();
    }
  });

  document.getElementById('oilRows').addEventListener('mouseover', function(e){
    if (!e.target.classList.contains('oil-typeahead')) return;
    const row = e.target.closest('.oil-row');
    if (!row || row === state.lastPreviewRow) return;
    state.lastPreviewRow = row;
    setSelectedOilProfileFromRow(row);
  });

  document.getElementById('oilRows').addEventListener('mouseout', function(e){
    if (e.target.classList.contains('oil-typeahead')) {
      clearSelectedOilProfile();
    }
  });

  document.getElementById('oilRows').addEventListener('click', function(e){
    const profileButton = e.target.closest('.oil-profile-open');
    if (profileButton) {
      const row = profileButton.closest('.oil-row');
      if (row) {
        setSelectedOilProfileFromRow(row);
        const modalEl = document.getElementById('oilProfileModal');
        if (modalEl && window.bootstrap) {
          const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
          modal.show();
        }
      }
      return;
    }
    if (e.target.classList.contains('remove-oil')) {
      const row = e.target.closest('.oil-row');
      if (row) {
        state.lastRemovedOil = serializeOilRow(row);
        state.lastRemovedOilIndex = Array.from(row.parentElement.children).indexOf(row);
        showUndoToast('Oil removed.');
      }
      if (row && state.lastOilEdit && state.lastOilEdit.row === row) {
        state.lastOilEdit = null;
        clearSelectedOilProfile();
      }
      if (row) row.remove();
      updateOilTotals();
      updateStageStatuses();
      queueStateSave();
    }
  });

  const stageAccordion = document.getElementById('soapStageAccordion');
  if (stageAccordion) {
    stageAccordion.addEventListener('click', event => {
      const actionBtn = event.target.closest('[data-stage-action]');
      if (!actionBtn) return;
      const action = actionBtn.dataset.stageAction;
      const index = Number(actionBtn.dataset.stageIndex);
      if (Number.isNaN(index)) return;
      if (action === 'prev') openStageByIndex(Math.max(0, index - 1));
      if (action === 'next') openStageByIndex(Math.min(STAGE_CONFIGS.length - 1, index + 1));
      if (action === 'reset') resetStage(index + 1);
    });
    stageAccordion.addEventListener('shown.bs.collapse', () => {
      updateStageAccordionLayout();
      scheduleStageHeightSync();
    });
    stageAccordion.addEventListener('hidden.bs.collapse', () => {
      updateStageAccordionLayout();
      scheduleStageHeightSync();
    });
  }

  document.querySelectorAll('input[name="weight_unit"]').forEach(el => {
    el.addEventListener('change', function(){
      setUnit(this.value);
      queueStateSave();
    });
  });

  document.getElementById('oilTotalTarget').addEventListener('input', function(){
    updateOilTotals();
    queueStateSave();
    queueAutoCalc();
  });

  document.getElementById('waterMethod').addEventListener('change', function(){
    setWaterMethod();
    queueStateSave();
    queueAutoCalc();
  });

  document.querySelectorAll('input[name="lye_type"]').forEach(el => {
    el.addEventListener('change', function(){
      applyLyeSelection();
      updateAdditivesOutput(getTotalOilsGrams());
      queueStateSave();
      queueAutoCalc();
    });
  });

  ['lyeSuperfat', 'lyePurity', 'waterPct', 'lyeConcentration', 'waterRatio'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    ['input', 'change'].forEach(eventName => {
      el.addEventListener(eventName, () => {
        queueStateSave();
        queueAutoCalc();
      });
    });
  });

  ['additiveFragrancePct', 'additiveLactatePct', 'additiveSugarPct', 'additiveSaltPct', 'additiveCitricPct']
    .forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('input', () => {
        updateAdditivesOutput(getTotalOilsGrams());
        queueStateSave();
        queueAutoCalc();
      });
    });

  document.querySelectorAll('.additive-typeahead').forEach(input => {
    input.addEventListener('input', () => {
      queueStateSave();
    });
  });

  const qualityPreset = document.getElementById('qualityPreset');
  if (qualityPreset) {
    qualityPreset.addEventListener('change', function(){
      updateQualityTargets();
      queueStateSave();
    });
  }
  document.querySelectorAll('.quality-focus').forEach(el => {
    el.addEventListener('change', function(){
      updateQualityTargets();
      queueStateSave();
    });
  });
  const applyQualityBtn = document.getElementById('applyQualityTargets');
  if (applyQualityBtn) {
    applyQualityBtn.addEventListener('click', function(){
      applyQualityTargets();
    });
  }
  document.querySelectorAll('.quality-target-marker').forEach(marker => {
    marker.addEventListener('click', () => applyQualityTargets());
    marker.addEventListener('keydown', event => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        applyQualityTargets();
      }
    });
  });

  document.getElementById('moldWaterWeight').addEventListener('input', function(){
    updateMoldSuggested();
    updateOilTotals();
    queueStateSave();
    queueAutoCalc();
  });
  document.getElementById('moldOilPct').addEventListener('input', function(){
    updateMoldSuggested();
    updateOilTotals();
    queueStateSave();
    queueAutoCalc();
  });
  const moldShape = document.getElementById('moldShape');
  if (moldShape) {
    moldShape.addEventListener('change', function(){
      updateMoldShapeUI();
      updateOilTotals();
      queueStateSave();
      queueAutoCalc();
    });
  }
  const moldCylinderCorrection = document.getElementById('moldCylinderCorrection');
  if (moldCylinderCorrection) {
    moldCylinderCorrection.addEventListener('change', function(){
      updateMoldSuggested();
      updateOilTotals();
      queueStateSave();
      queueAutoCalc();
    });
  }
  const moldCylinderFactor = document.getElementById('moldCylinderFactor');
  if (moldCylinderFactor) {
    moldCylinderFactor.addEventListener('input', function(){
      updateMoldSuggested();
      updateOilTotals();
      queueStateSave();
      queueAutoCalc();
    });
  }

  document.querySelectorAll('.stub-btn').forEach(btn => {
    btn.addEventListener('click', function(){
      const kind = this.dataset.stubKind;
      const name = this.dataset.stubName;
      addStubLine(kind, name);
      queueStateSave();
    });
  });

  const soapRoot = document.getElementById('soapToolPage');
  if (soapRoot) {
    soapRoot.addEventListener('click', function(e){
      if (e.target.classList.contains('tool-remove')) {
        queueStateSave();
      }
    });
    soapRoot.addEventListener('input', function(e){
      if (e.target.matches('input, select, textarea')) {
        queueStateSave();
        validateNumericField(e.target);
        updateStageStatuses();
        flashStage(e.target.closest('.accordion-item'));
      }
    });
    soapRoot.addEventListener('change', function(e){
      if (e.target.matches('input, select, textarea')) {
        queueStateSave();
        validateNumericField(e.target);
        updateStageStatuses();
      }
    });
  }

  document.getElementById('addToolIngredient').addEventListener('click', function(){
    document.getElementById('tool-ingredients').appendChild(buildLineRow('ingredient'));
    queueStateSave();
  });
  document.getElementById('addToolConsumable').addEventListener('click', function(){
    document.getElementById('tool-consumables').appendChild(buildLineRow('consumable'));
    queueStateSave();
  });
  document.getElementById('addToolContainer').addEventListener('click', function(){
    document.getElementById('tool-containers').appendChild(buildLineRow('container'));
    queueStateSave();
  });

  document.getElementById('calcLyeBtn').addEventListener('click', function(){
    calculateAll({ consumeQuota: true, showAlerts: true });
    queueStateSave();
  });

  document.getElementById('saveSoapTool').addEventListener('click', async function(){
    try {
      const calc = state.lastCalc || calculateAll({ consumeQuota: false, showAlerts: true });
      if (!calc) return;
      const payload = buildSoapRecipePayload(calc);
      state.lastRecipePayload = payload;
      try {
        const storage = getStorage();
        if (storage) {
          storage.setItem('soap_recipe_payload', JSON.stringify(payload));
        }
      } catch (_) {}
      window.SOAP_RECIPE_DTO = payload;
      showSoapAlert('info', 'Recipe payload is ready. Push is stubbed for now; no data has been sent.', { dismissible: true, timeoutMs: 7000 });
    } catch(_) {
      showSoapAlert('danger', 'Unable to prepare the recipe payload. Please try again.', { dismissible: true, persist: true });
    }
  });

  const undoRemoveBtn = document.getElementById('soapUndoRemove');
  if (undoRemoveBtn) {
    undoRemoveBtn.addEventListener('click', () => {
      if (!state.lastRemovedOil) return;
      restoreOilRow(state.lastRemovedOil, state.lastRemovedOilIndex || 0);
      state.lastRemovedOil = null;
      state.lastRemovedOilIndex = null;
      updateOilTotals();
      queueStateSave();
      queueAutoCalc();
    });
  }

  const setupMobileDrawer = () => {
    const drawer = document.getElementById('soapMobileDrawer');
    const drawerContent = document.getElementById('soapMobileDrawerContent');
    const drawerTitle = document.getElementById('soapMobileDrawerTitle');
    const drawerEmpty = document.getElementById('soapDrawerEmpty');
    const closeBtn = document.getElementById('soapDrawerClose');
    const qualityCard = document.getElementById('soapQualityCard');
    const resultsCard = document.getElementById('resultsCard');
    if (!drawer || !drawerContent || !drawerTitle || !qualityCard || !resultsCard) return;

    const qualityHome = qualityCard.parentElement;
    const resultsHome = resultsCard.parentElement;
    const placeholders = new Map();
    let currentTarget = null;

    const isSmallScreen = () => window.matchMedia('(max-width: 767px)').matches;
    const cardForTarget = (target) => (target === 'quality' ? qualityCard : resultsCard);
    const homeForTarget = (target) => (target === 'quality' ? qualityHome : resultsHome);
    const titleForTarget = (target) => (target === 'quality' ? 'Display' : 'Results');

    const ensurePlaceholder = (card) => {
      let placeholder = placeholders.get(card);
      if (!placeholder) {
        placeholder = document.createElement('div');
        placeholder.className = 'soap-card-placeholder';
        placeholders.set(card, placeholder);
      }
      placeholder.style.height = `${card.offsetHeight}px`;
      if (card.parentElement && card.parentElement !== drawerContent && !placeholder.parentElement) {
        card.parentElement.insertBefore(placeholder, card);
      }
    };

    const moveCardToDrawer = (card) => {
      if (!card) return;
      ensurePlaceholder(card);
      drawerContent.appendChild(card);
    };

    const restoreCard = (card, home) => {
      const placeholder = placeholders.get(card);
      if (placeholder && placeholder.parentElement) {
        placeholder.replaceWith(card);
      } else if (home && card.parentElement !== home) {
        home.appendChild(card);
      }
    };

    const updateDrawerEmpty = () => {
      if (!drawerEmpty) return;
      const isResults = currentTarget === 'results';
      const resultsVisible = getComputedStyle(resultsCard).display !== 'none';
      drawerEmpty.classList.toggle('d-none', !isResults || resultsVisible);
    };

    const openDrawer = (target) => {
      if (!isSmallScreen()) return;
      if (currentTarget && currentTarget !== target) {
        restoreCard(cardForTarget(currentTarget), homeForTarget(currentTarget));
      }
      moveCardToDrawer(cardForTarget(target));
      drawerTitle.textContent = titleForTarget(target);
      currentTarget = target;
      drawer.classList.add('is-open');
      updateDrawerEmpty();
    };

    const closeDrawer = () => {
      if (!currentTarget) return;
      restoreCard(cardForTarget(currentTarget), homeForTarget(currentTarget));
      currentTarget = null;
      drawer.classList.remove('is-open');
      updateDrawerEmpty();
    };

    drawer.querySelectorAll('[data-drawer-target]').forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.drawerTarget;
        if (!target) return;
        if (drawer.classList.contains('is-open') && currentTarget === target) {
          closeDrawer();
        } else {
          openDrawer(target);
        }
      });
    });

    if (closeBtn) {
      closeBtn.addEventListener('click', closeDrawer);
    }

    window.addEventListener('resize', () => {
      if (!isSmallScreen() && currentTarget) {
        closeDrawer();
      }
    });

    const resultsObserver = new MutationObserver(() => updateDrawerEmpty());
    resultsObserver.observe(resultsCard, { attributes: true, attributeFilter: ['style', 'class'] });
  };
  setupMobileDrawer();
  window.addEventListener('resize', () => {
    updateStageAccordionLayout();
    scheduleStageHeightSync();
  });
  window.addEventListener('load', scheduleStageHeightSync);

  const initialOilRow = document.querySelector('#oilRows .oil-row');
  if (initialOilRow) {
    attachOilTypeahead(initialOilRow);
  }
  attachAdditiveTypeahead('additiveFragranceName', 'additiveFragranceGi', FRAGRANCE_CATEGORY_SET);
  attachAdditiveTypeahead('additiveLactateName', 'additiveLactateGi', LACTATE_CATEGORY_SET);
  attachAdditiveTypeahead('additiveSugarName', 'additiveSugarGi', SUGAR_CATEGORY_SET);
  attachAdditiveTypeahead('additiveSaltName', 'additiveSaltGi', SALT_CATEGORY_SET);
  attachAdditiveTypeahead('additiveCitricName', 'additiveCitricGi', CITRIC_CATEGORY_SET);
  applyHelperVisibility();
  injectStageActions();
  initQualityTooltips();
  applyLyeSelection();
  setWaterMethod();
  updateMoldShapeUI();
  setQualityRangeBars();
  updateUnitLabels();
  updateQualityTargets();
  updateAdditivesOutput(getTotalOilsGrams());
  updateStageStatuses();
  restoreState();
  updateStageAccordionLayout();
  scheduleStageHeightSync();
  const downloadModal = document.getElementById('soapDownloadPreviewModal');
  if (downloadModal) {
    downloadModal.addEventListener('show.bs.modal', updateDownloadPreview);
  }
})();
</script>
{% endblock %}