{% extends 'layout.html' %}
{% block content %}
<input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
<div x-data="planProduction()" x-init="init()" class="container">
  <h2>Plan Production: {{ recipe.name }}</h2>

  <!-- Scale + Yield -->
  <div class="row mb-4">
    <div class="col-md-6">
      <label>Batch Scale:</label>
      <input type="number" min="0.1" step="0.1" class="form-control" x-model.number="scale" @input="fetchContainerPlan">
    </div>
    <div class="col-md-6">
      <label>Projected Yield:</label>
      <div class="form-control-plaintext" x-text="(baseYield * scale).toFixed(2) + ' ' + unit"></div>
    </div>
  </div>

  <!-- Auto-Fill Toggle -->
  <div class="row mb-4">
    <div class="col-md-6">
      <input type="checkbox" id="autoFill" x-model="autoFill" @change="fetchContainerPlan">
      <label for="autoFill">Auto-Fill Containers</label>
    </div>
  </div>

  <!-- Container Selection -->
  <div class="card mb-4">
    <div class="card-header d-flex justify-content-between">
      <h5>Selected Containers</h5>
      <button type="button" class="btn btn-outline-primary btn-sm" @click="manualAddContainer">Add Container</button>
    </div>
    <div class="card-body">
      <template x-for="(container, index) in containersSelected" :key="index">
        <div class="d-flex align-items-center gap-2 mb-2">
          <select class="form-select" x-model="container.id" :disabled="autoFill" @change="updateContainer(index)">
            <option value="">Select Container</option>
            <template x-for="allowed in allowedContainers" :key="allowed.id">
              <option :value="allowed.id" x-text="allowed.name + ' (' + allowed.storage_amount + ' ' + allowed.storage_unit + ')'"></option>
            </template>
          </select>
          <input type="number" min="1" class="form-control" x-model.number="container.quantity" :disabled="autoFill" @input="updateProgress">
          <button type="button" class="btn btn-danger btn-sm" @click="removeContainer(index)" :disabled="autoFill">&times;</button>
        </div>
      </template>

      <!-- Containment Progress -->
      <div class="mt-3">
        <label>Containment Progress:</label>
        <div class="progress" style="height: 20px;">
          <div class="progress-bar" role="progressbar" :style="'width: ' + containmentPercent + '%'" x-text="containmentPercent + '%'"></div>
        </div>
        <small class="form-text text-muted" x-text="liveContainmentMessage"></small>
      </div>

      <!-- Warnings -->
      <div class="alert alert-warning mt-2" x-show="containmentIssue">
        <span x-text="containmentIssue"></span>
      </div>

      <div class="alert alert-danger mt-2" x-show="containersSelected.length === 0">
        No containers selected. Please add containers or enable Auto-Fill.
      </div>
    </div>
  </div>

  <!-- Check Ingredients -->
  <h4>Check Ingredients</h4>
  <div class="mb-4">
    <div class="d-flex gap-2">
      <button type="button" class="btn btn-warning" @click="checkStockOrWarn">Check Stock</button>
      <a href="{{ url_for('recipes.list_recipes') }}" class="btn btn-secondary">Cancel</a>
    </div>
    <div x-show="stockChecked" class="mt-3">
      <template x-if="stockCheckPassed">
        <div class="alert alert-success mt-2">
          ‚úÖ All ingredients are available!
        </div>
      </template>
      <template x-if="!stockCheckPassed">
        <div class="alert alert-warning mt-2">
          ‚ö† Some ingredients are low or missing. Adjust inventory before proceeding.
        </div>
      </template>

      <table class="table table-bordered table-sm mt-2">
        <thead>
          <tr>
            <th>Ingredient</th>
            <th>Required</th>
            <th>Available</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          <template x-for="item in stockResults" :key="item.ingredient">
            <tr>
              <td x-text="item.ingredient"></td>
              <td x-text="`${item.needed} ${item.recipe_unit}`"></td>
              <td x-text="`${item.available} ${item.inventory_unit}`"></td>
              <td>
                <span x-show="item.status === 'OK'" class="text-success">‚úÖ</span>
                <span x-show="item.status === 'LOW'" class="text-warning">‚ö†Ô∏è</span>
                <span x-show="item.status === 'NEEDED'" class="text-danger">‚ùå</span>
              </td>
            </tr>
          </template>
        </tbody>
      </table>

      <button class="btn btn-outline-secondary btn-sm" @click="downloadCSV">üì• Download CSV</button>
      <button class="btn btn-outline-secondary btn-sm" @click="downloadShoppingList">üìù Download Shopping List</button>
    </div>
  </div>

  <!-- Start Batch -->
  <div class="d-flex justify-content-end">
    <button type="button" class="btn btn-success" x-show="canStartBatch" @click="startBatch">Start Batch</button>
  </div>
</div>

<!-- Alpine Component -->
<script>
function planProduction() {
  return {
    recipeId: {{ recipe.id }},
    baseYield: {{ '%.2f'|format(recipe.predicted_yield) }},
    unit: '{{ recipe.predicted_yield_unit }}',
    allowedContainers: [],
    containersSelected: [],
    autoFill: true,
    scale: 1.0,
    stockChecked: false,
    stockCheckPassed: false,
    stockResults: [],
    containmentPercent: 0,
    remainingToContain: 0,
    flexMode: false,
    containmentIssue: '',

    init() {
      this.fetchContainerPlan();
    },

    get totalContained() {
      return this.containersSelected.reduce((sum, c) => sum + (c.capacity * c.quantity), 0);
    },

    get liveContainmentMessage() {
      if (this.containersSelected.length === 0) return '';
      if (this.containmentPercent < 100) {
        return `There will be ${this.remainingToContain.toFixed(2)} ${this.unit} left uncontained.`;
      }
      return 'Full containment achieved.';
    },

    get canStartBatch() {
      return (this.flexMode || this.containmentPercent >= 100) && this.stockChecked && this.stockCheckPassed;
    },

    fetchContainerPlan() {
      fetch(`/api/available-containers/${this.recipeId}?scale=${this.scale}`)
        .then(res => res.json())
        .then(data => {
          // Update allowedContainers first
          this.allowedContainers = data.available || [];

          // Update containersSelected in autoFill mode
          if (this.autoFill) {
            this.containersSelected = (data.plan || []).map(container => ({
              id: container.id,
              quantity: container.quantity,
              name: '',
              capacity: 0,
              unit: ''
            }));
            // Sync names and details for all containers
            this.containersSelected.forEach((container, index) => {
              this.updateContainer(index);
            });
          }

          this.updateProgress();
          this.evaluateContainment();
        });
    },

    updateProgress() {
      const projected = this.baseYield * this.scale;
      const contained = this.totalContained;
      this.containmentPercent = Math.min((contained / projected) * 100, 100).toFixed(0);
      this.remainingToContain = Math.max(projected - contained, 0);
    },

    evaluateContainment() {
      if (this.autoFill && this.containmentPercent < 100) {
        this.containmentIssue = 'Warning: Some containers will be partially filled.';
        const projected = this.baseYield * this.scale;
        const totalAvailable = this.allowedContainers.reduce((sum, c) => sum + (c.storage_amount * c.stock_qty), 0);
        if (totalAvailable < projected) {
          const smallestContainer = Math.min(...this.allowedContainers.map(c => c.storage_amount));
          const missingUnits = Math.ceil((projected - totalAvailable) / smallestContainer);
          this.containmentIssue += ` You need ${missingUnits} more containers to make this batch.`;
        }
      } else {
        this.containmentIssue = '';
      }
    },

    updateContainer(index) {
      const container = this.containersSelected[index];
      const selectedId = container.id;
      const match = this.allowedContainers.find(c => c.id == selectedId);

      if (!match) return;

      // Calculate remaining stock after accounting for existing selections
      const usedQuantity = this.containersSelected.reduce((sum, c, i) => 
        i !== index && c.id === selectedId ? sum + c.quantity : sum, 0);
      const remainingStock = match.stock_qty - usedQuantity;

      // If no stock remains, set quantity to 0
      if (remainingStock <= 0) {
        container.quantity = 0;
        this.containmentIssue = `No more ${match.name}s available (all allocated)`;
      }

      // Update container details
      container.capacity = match.storage_amount;
      container.unit = match.storage_unit;
      container.name = match.name;

      this.updateProgress();
      this.evaluateContainment();
    },

    removeContainer(index) {
      this.containersSelected.splice(index, 1);
      this.updateProgress();
      this.evaluateContainment();
    },

    manualAddContainer() {
      if (this.autoFill) {
        alert('Please uncheck Auto-Fill to add containers manually.');
        return;
      }
      this.containersSelected.push({ id: '', name: '', capacity: 0, quantity: 1, unit: '' });
      this.updateProgress();
      this.evaluateContainment();
    },

    checkStockOrWarn() {
      if (!this.flexMode && this.containmentPercent < 100 && this.containersSelected.length > 0) {
        if (confirm(`You do not have enough containers selected, or there will be ${this.remainingToContain.toFixed(2)} ${this.unit} left over. Would you like to continue anyway?`)) {
          this.flexMode = true;
          this.checkStock();
        }
      } else {
        this.checkStock();
      }
    },

    checkStock() {
      const csrfToken = document.querySelector('input[name=csrf_token]');
      fetch('/api/check-stock', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'X-CSRFToken': csrfToken.value
        },
        body: JSON.stringify({ 
          recipe_id: parseInt(this.recipeId), 
          scale: parseFloat(this.scale),
          flex_mode: this.flexMode
        })
      })
        .then(res => res.json())
        .then(data => {
          this.stockChecked = true;
          this.stockCheckPassed = data.all_ok;
          this.stockResults = data.ingredients || [];
        })
        .catch(err => {
          this.stockChecked = false;
          this.stockResults = [];
          console.error(err);
        });
    },

    startBatch() {
      alert('Batch would be started. Backend logic needed.');
    },

    downloadCSV() {
      if (!this.stockResults?.length) return;
      let csv = "Ingredient,Required,Available,Unit,Status\n";
      this.stockResults.forEach(row => {
        csv += `${row.ingredient},${row.needed},${row.available},${row.unit},${row.status}\n`;
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'stock_check_report.csv';
      link.click();
    },

    downloadShoppingList() {
      if (!this.stockResults?.length) return;
      const needed = this.stockResults.filter(item => item.status === 'LOW' || item.status === 'NEEDED');
      if (!needed.length) {
        alert('No items need restocking!');
        return;
      }
      let text = "Shopping List\n=============\n\n";
      needed.forEach(item => {
        const missing = item.needed - item.available;
        text += `${item.ingredient}: ${missing.toFixed(2)} ${item.unit}\n`;
      });
      const blob = new Blob([text], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'shopping_list.txt';
      link.click();
    }
  };
}
</script>
{% endblock %}