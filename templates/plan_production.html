{% extends 'layout.html' %}
{% block content %}
<div x-data="planProduction()" x-init="init()" class="container">
  <h2>Plan Production: {{ recipe.name }}</h2>

  <div class="row mb-4">
    <div class="col-md-6">
      <label>Batch Scale:</label>
      <input type="number" min="0.1" step="0.1" class="form-control" x-model.number="scale" @input="debouncedRefresh">
    </div>
    <div class="col-md-6">
      <label>Projected Yield:</label>
      <div class="form-control-plaintext" x-text="(baseYield * scale).toFixed(2) + ' ' + unit"></div>
    </div>
  </div>

  <div class="row mb-4">
    <div class="col-md-6">
      <input type="checkbox" id="autoFill" x-model="autoFill" @change="fetchContainerPlan">
      <label for="autoFill">Auto-Fill Containers</label>
    </div>
  </div>

  <div class="card mb-4">
    <div class="card-header d-flex justify-content-between">
      <h5>Selected Containers</h5>
      <button type="button" class="btn btn-outline-primary btn-sm" @click="addContainer" :disabled="autoFill">Add Container</button>
    </div>
    <div class="card-body">
      <template x-for="(container, index) in containersSelected" :key="index">
        <div class="d-flex align-items-center gap-2 mb-2">
          <select class="form-select" x-model="container.id" :disabled="autoFill" @change="updateContainer(index)">
            <option value="">Select Container</option>
            <template x-for="allowed in allowedContainers" :key="allowed.id">
              <option :value="allowed.id" x-text="allowed.name + ' (' + allowed.storage_amount + ' ' + allowed.storage_unit + ')'"></option>
            </template>
          </select>
          <input type="number" class="form-control" min="1" x-model.number="container.quantity" :disabled="autoFill" @input="updateProgress">
          <button type="button" class="btn btn-danger btn-sm" @click="removeContainer(index)" :disabled="autoFill">Ã—</button>
        </div>
      </template>

      <div class="mt-3">
        <label>Containment Progress:</label>
        <div class="progress" style="height: 20px;">
          <div class="progress-bar" role="progressbar" 
               :style="'width: ' + containmentPercent + '%'" 
               x-text="containmentPercent + '%'"></div>
        </div>
        <small class="form-text text-muted" x-text="liveContainmentMessage"></small>
      </div>

      <div class="alert alert-warning mt-2" x-show="containmentIssue" x-text="containmentIssue"></div>

      <div class="alert alert-danger mt-2" x-show="containersSelected.length === 0">
        No containers selected. Please add containers or enable Auto-Fill.
      </div>
    </div>
  </div>

  <h4>Check Ingredients</h4>
  <div class="mb-4">
    <div class="d-flex gap-2">
      <button type="button" class="btn btn-warning" @click="checkStockOrWarn">Check Stock</button>
      <a href="{{ url_for('recipes.list_recipes') }}" class="btn btn-secondary">Cancel</a>
    </div>
    <div class="alert alert-danger mt-2" x-show="stockChecked && !stockCheckPassed">
      Some ingredients are low or missing. Adjust inventory before proceeding.
    </div>
    <div class="alert alert-success mt-2" x-show="stockChecked && stockCheckPassed">
      All ingredients are available!
    </div>
  </div>

  <div class="d-flex justify-content-end">
    <button type="button" class="btn btn-success" x-show="canStartBatch" @click="startBatch">Start Batch</button>
  </div>
</div>

<script>
function planProduction() {
  return {
    recipeId: {{ recipe.id }},
    baseYield: {{ '%.2f'|format(recipe.predicted_yield) }},
    unit: '{{ recipe.predicted_yield_unit }}',
    recipe: {{ recipe.to_dict()|tojson }},
    allowedContainers: [],
    containersSelected: [],
    autoFill: true,
    scale: 1.0,
    stockChecked: false,
    stockCheckPassed: false,
    containmentPercent: 0,
    remainingToContain: 0,
    flexMode: false,
    containmentIssue: '',

    debounceTimer: null,
    isLoading: false,
    currentRequest: null,
    lastValue: null,

    async debouncedRefresh() {
      const currentValue = this.scale;
      this.lastValue = currentValue;

      if (this.debounceTimer) clearTimeout(this.debounceTimer);

      this.debounceTimer = setTimeout(async () => {
        if (this.lastValue === currentValue) {
          if (this.currentRequest) {
            this.currentRequest.abort();
          }
          await this.fetchContainerPlan();
        }
      }, 100);
    },

    init() {
      this.fetchContainerPlan();
    },

    updateProgress() {
      const projected = this.baseYield * this.scale;
      const contained = this.containersSelected.reduce((sum, c) => 
        sum + (Number(c.capacity || 0) * Number(c.quantity || 0)), 0);
      this.containmentPercent = Math.min((contained / projected) * 100, 100).toFixed(0);
      this.remainingToContain = Math.max(projected - contained, 0);
    },

    get liveContainmentMessage() {
      if (this.containersSelected.length === 0) return '';
      if (this.containmentPercent < 100) {
        return `There will be ${this.remainingToContain.toFixed(2)} ${this.unit} left uncontained.`;
      }
      return 'Full containment achieved.';
    },

    get canStartBatch() {
      return (this.flexMode || this.containmentPercent >= 100) && 
             this.stockChecked && this.stockCheckPassed;
    },

    addContainer() {
      if (this.autoFill) return;
      this.containersSelected.push({
        id: '',
        name: '',
        capacity: 0,
        quantity: 1,
        unit: ''
      });
      this.updateProgress();
    },

    removeContainer(index) {
      if (this.autoFill) return;
      this.containersSelected.splice(index, 1);
      this.updateProgress();
    },

    updateContainer(index) {
      const container = this.containersSelected[index];
      const match = this.allowedContainers.find(c => c.id === container.id);
      if (match) {
        container.capacity = match.storage_amount;
        container.unit = match.storage_unit;
        container.name = match.name;
        if (container.quantity > match.stock_qty) {
          container.quantity = match.stock_qty;
        }
      }
      this.updateProgress();
      this.debouncedRefresh();
    },

    async fetchContainerPlan() {
      // Cancel any in-flight request
      if (this.currentRequest) {
        this.currentRequest.abort();
      }
      
      // Create new request controller
      const controller = new AbortController();
      this.currentRequest = controller;
      
      if (this.isLoading) {
        return;
      }
      
      this.isLoading = true;
      try {
        const response = await fetch(`/api/available-containers/${this.recipeId}?scale=${this.scale}`, {
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        
        // Only update if this is still the current request
        if (this.currentRequest === controller) {
          this.allowedContainers = data.available || [];
          if (this.autoFill && data.plan) {
            this.containersSelected = data.plan;
          }
          this.updateProgress();
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Error fetching containers:', error);
        }
      } finally {
        if (this.currentRequest === controller) {
          this.isLoading = false;
          this.currentRequest = null;
        }
      }
    },

    async checkStockOrWarn() {
      if (!this.flexMode && this.containmentPercent < 100) {
        if (confirm(`You do not have enough containers selected, or there will be ${this.remainingToContain.toFixed(2)} ${this.unit} left over. Would you like to continue anyway?`)) {
          this.flexMode = true;
          await this.checkStock();
        }
      } else {
        await this.checkStock();
      }
    },

    async checkStock() {
      try {
        const payload = {
          recipe_id: this.recipeId,
          scale: this.scale,
          flex_mode: this.flexMode
        };

        console.log('Checking stock with:', payload);

        const response = await fetch('/api/check-stock', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (!data) {
          throw new Error('Empty response from server');
        }
        this.stockChecked = true;
        this.stockCheckPassed = data.all_ok;
      } catch (error) {
        console.error('Error checking stock:', error);
        alert('Error checking stock. Please try again.');
      }
    },

    async startBatch() {
      try {
        const response = await fetch('/api/start-batch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            recipe_id: this.recipeId,
            scale: this.scale,
            flex_mode: this.flexMode,
            containers: this.containersSelected
          })
        });
        if (response.ok) {
          alert('Batch started successfully.');
          window.location.href = '/dashboard';
        } else {
          alert('Error starting batch. Please try again.');
        }
      } catch (error) {
        console.error('Error starting batch:', error);
        alert('Error starting batch. Please try again.');
      }
    }
  };
}
</script>
{% endblock %}