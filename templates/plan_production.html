
{% extends 'layout.html' %}
{% block content %}
<div x-data="planProduction()" x-init="init()" class="container">
  <div class="mb-4">
    <h2>Plan Production: {{ recipe.name }}</h2>
  </div>

  <div class="row mb-4">
    <div class="col-md-6">
      <label for="scale">Batch Scale:</label>
      <input type="number" id="scale" min="0.1" step="0.1" x-model.number="scale" @input="fetchContainerPlan" class="form-control">
    </div>
    <div class="col-md-6">
      <label>Projected Yield:</label>
      <div class="form-control-plaintext" x-text="(baseYield * scale).toFixed(2) + ' ' + unit"></div>
    </div>
  </div>

  <div class="row mb-4">
    <div class="col-md-6">
      <label><input type="checkbox" x-model="flexMode"> Flexible Mode (Allow incomplete containment)</label>
    </div>
    <div class="col-md-6">
      <label><input type="checkbox" x-model="autoFill" @change="fetchContainerPlan"> Auto-Fill Containers</label>
    </div>
  </div>

  <div class="card mb-4">
    <div class="card-header d-flex justify-content-between">
      <h5>Selected Containers</h5>
      <button type="button" class="btn btn-outline-primary btn-sm" @click="addContainer">Add Container</button>
    </div>
    <div class="card-body">
      <template x-for="(container, index) in containersSelected" :key="index">
        <div x-data="containerRow(container, index, $parent)" class="d-flex align-items-center gap-2 mb-2">
          <select class="form-select" x-model="container.id" @change="updateContainer()">
            <option value="">Select Container</option>
            <template x-for="allowed in allowedContainers.filter(c => c.stock_qty > 0 && recipe.allowed_containers.includes(c.id))" :key="allowed.id">
              <option :value="allowed.id" x-text="allowed.name + ' (' + allowed.storage_amount + ' ' + allowed.storage_unit + ')'"></option>
            </template>
          </select>
          <input type="number" class="form-control" min="1" x-model.number="container.quantity" @input="updateContainer()">
          <button type="button" class="btn btn-danger btn-sm" @click="removeContainer()">Ã—</button>
        </div>
      </template>

      <div class="mt-3">
        <label>Containment Progress:</label>
        <div class="progress" style="height: 20px;">
          <div class="progress-bar" role="progressbar"
            :style="'width: ' + Math.min((totalContained / (baseYield * scale)) * 100, 100) + '%'"
            x-text="Math.min((totalContained / (baseYield * scale)) * 100, 100).toFixed(0) + '%'">
          </div>
        </div>
        <small class="form-text text-muted mt-1" x-text="'Remaining: ' + Math.max((baseYield * scale) - totalContained, 0).toFixed(2) + ' ' + unit"></small>
      </div>

      <div class="alert alert-warning mt-2" x-show="!flexMode && totalContained < (baseYield * scale)">
        Warning: You must fully contain this batch under Strict Mode!
      </div>
    </div>
  </div>

  <div class="d-flex justify-content-between gap-2 mb-4">
    <a href="{{ url_for('recipes.list_recipes') }}" class="btn btn-secondary">Cancel</a>
    <button type="button" class="btn btn-warning" @click="checkStock">Check Stock</button>
  </div>

  <div class="mb-4">
    <div class="alert alert-danger mt-2" x-show="stockChecked && !stockCheckPassed">
      Some ingredients are low or missing. Please adjust your inventory.
    </div>
    <div class="alert alert-success mt-2" x-show="stockChecked && stockCheckPassed">
      All ingredients are available!
    </div>
  </div>

  <div class="d-flex justify-content-end">
    <button type="button" class="btn btn-success" x-show="canStartBatch" @click="startBatch">Start Batch</button>
  </div>

</div>

<script>
function containerRow(container, index, parent) {
  return {
    container,
    index,
    allowedContainers: parent.allowedContainers,
    updateContainer() {
      const match = this.allowedContainers.find(c => c.id == this.container.id);
      if (match) {
        this.container.name = match.name;
        this.container.capacity = match.storage_amount;
        this.container.unit = match.storage_unit;
      } else {
        this.container.name = '';
        this.container.capacity = 0;
        this.container.unit = '';
      }
    },
    removeContainer() {
      parent.containersSelected.splice(this.index, 1);
    }
  }
}

function planProduction() {
  return {
    recipeId: {{ recipe.id }},
    baseYield: {{ '%.2f'|format(recipe.predicted_yield) }},
    unit: '{{ recipe.predicted_yield_unit }}',
    allowedContainers: [],
    containersSelected: [],
    flexMode: false,
    autoFill: true,
    scale: 1.0,
    stockChecked: false,
    stockCheckPassed: false,
    init() {
      this.fetchContainerPlan();
    },

    get totalContained() {
      return this.containersSelected.reduce((sum, c) => sum + (c.capacity * c.quantity), 0);
    },

    get canStartBatch() {
      const fullContain = this.flexMode || this.totalContained >= this.baseYield * this.scale;
      return fullContain && this.stockChecked && this.stockCheckPassed;
    },

    fetchContainerPlan() {
      if (!this.autoFill) return;
      fetch(`/api/available-containers/${this.recipeId}?scale=${this.scale}`)
        .then(res => res.json())
        .then(data => {
          this.allowedContainers = data.available;
          this.containersSelected = data.plan;
        });
    },

    addContainer() {
      this.containersSelected.push({ id: '', name: '', capacity: 0, quantity: 1, unit: '' });
    },

    updateContainer(index, field, value) {
      if (field === 'id') {
        const match = this.allowedContainers.find(c => c.id == value);
        if (match) {
          this.containersSelected[index] = { ...match, quantity: this.containersSelected[index].quantity || 1 };
        }
      } else if (field === 'quantity') {
        this.containersSelected[index].quantity = parseInt(value);
      }
    },

    removeContainer(index) {
      this.containersSelected.splice(index, 1);
    },

    checkStock() {
      fetch('/api/check-stock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ recipe_id: this.recipeId, scale: this.scale })
      })
        .then(res => res.json())
        .then(data => {
          this.stockChecked = true;
          this.stockCheckPassed = data.all_ok;
          if (!data.all_ok) alert('Some ingredients are low or missing.');
        });
    },

    startBatch() {
      alert('Batch would be started now. Connect real endpoint.');
    }
  };
}
</script>
{% endblock %}
