
{% extends 'layout.html' %}
{% block content %}

<h2>Plan Production: {{ recipe.name }}</h2>

<form id="planProductionForm" method="post" action="{{ url_for('batches.start_batch') }}">
  <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
  <input type="hidden" name="recipe_id" value="{{ recipe.id }}">

  <div x-data="planProduction()" class="container">
    <!-- Scale and Projected Yield -->
    <div class="row mb-4">
      <div class="col-md-6">
        <label for="scale">Scale:</label>
        <input type="number" id="scale" name="scale" min="0.1" step="0.1" x-model.number="scale" class="form-control">
      </div>
      <div class="col-md-6">
        <label>Projected Yield:</label>
        <div class="form-control-plaintext" x-text="(baseYield * scale).toFixed(2) + ' ' + unit"></div>
      </div>
    </div>

    <!-- Mode Toggles -->
    <div class="row mb-4">
      <div class="col-md-6">
        <label><input type="checkbox" name="flex_mode" x-model="flexMode"> Flexible Mode</label>
        <small class="form-text text-muted">Allow proceeding without full containment.</small>
      </div>
      <div class="col-md-6">
        <label><input type="checkbox" name="auto_fill" x-model="autoFill"> Auto-Fill Containers</label>
        <small class="form-text text-muted">Auto select best-fit containers.</small>
      </div>
    </div>

    <!-- Select Containers Button -->
    <div class="mb-4">
      <button type="button" class="btn btn-outline-primary btn-sm" @click="addContainer">Select Container</button>
    </div>

    <!-- Container Selection -->
    <template x-for="(container, index) in containersSelected" :key="index">
      <div class="container-row d-flex align-items-center gap-2 mb-2">
        <select class="form-select" x-model="container.id" @change="updateContainer(index, 'id', $event.target.value)">
          <option value="">Select Container</option>
          <template x-for="allowed in allowedContainers" :key="allowed.id">
            <option :value="allowed.id" x-text="allowed.name + ' (' + allowed.storage_amount + ' ' + allowed.storage_unit + ')'"></option>
          </template>
        </select>
        <input type="number" class="form-control" min="1" x-model.number="container.quantity" @input="updateContainer(index, 'quantity', $event.target.value)">
        <button type="button" class="btn btn-danger btn-sm" @click="removeContainer(index)">Ã—</button>
      </div>
    </template>

    <!-- Containment Progress -->
    <label class="mt-3">Containment Progress:</label>
    <div class="progress" style="height: 20px;">
      <div class="progress-bar" role="progressbar"
        :style="'width: ' + Math.min((totalContained / (baseYield * scale)) * 100, 100) + '%'"
        x-text="Math.min((totalContained / (baseYield * scale)) * 100, 100).toFixed(0) + '%'">
      </div>
    </div>
    <small class="form-text text-muted mt-1" x-text="'Remaining to contain: ' + Math.max((baseYield * scale) - totalContained, 0).toFixed(2) + ' ' + unit"></small>

    <!-- Flex Mode Containment Error -->
    <div class="alert alert-danger mt-3" x-show="!flexMode && totalContained < (baseYield * scale)">
      You must fully contain this batch to proceed.
    </div>

    <!-- Action Buttons -->
    <div class="d-flex justify-content-between mt-4">
      <button type="button" class="btn btn-primary" @click="checkStock">Check Stock</button>
      <button type="submit" class="btn btn-success" :disabled="!flexMode && totalContained < (baseYield * scale)">Start Batch</button>
    </div>

    <!-- Stock Check Results -->
    <div id="stockCheckResults" class="mt-4" x-show="stockResults.length > 0">
      <h4>Stock Check Results</h4>
      <div class="table-responsive">
        <table class="table">
          <thead>
            <tr>
              <th>Item</th>
              <th>Needed</th>
              <th>Available</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            <template x-for="item in stockResults" :key="item.name">
              <tr>
                <td x-text="item.name"></td>
                <td x-text="item.needed + ' ' + item.unit"></td>
                <td x-text="item.available + ' ' + item.unit"></td>
                <td :class="item.status === 'OK' ? 'text-success' : item.status === 'LOW' ? 'text-warning' : 'text-danger'"
                    x-text="item.status"></td>
              </tr>
            </template>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</form>

<script>
function planProduction() {
  return {
    baseYield: {{ '%.2f'|format(recipe.predicted_yield) }},
    unit: '{{ recipe.predicted_yield_unit }}',
    allowedContainers: {{ allowed_containers|tojson|safe if allowed_containers else '[]' }},
    scale: 1.0,
    flexMode: false,
    autoFill: true,
    containersSelected: [],
    stockResults: [],

    autoFillContainers() {
      if (!this.autoFill) return;
      
      this.containersSelected = [];
      let remainingYield = this.baseYield * this.scale;
      
      // Sort containers by capacity (largest first)
      const sortedContainers = [...this.allowedContainers]
        .sort((a, b) => b.storage_amount - a.storage_amount);
      
      for (const container of sortedContainers) {
        if (remainingYield <= 0) break;
        
        const quantity = Math.floor(remainingYield / container.storage_amount);
        if (quantity > 0) {
          this.containersSelected.push({
            id: container.id,
            quantity: quantity
          });
          remainingYield -= container.storage_amount * quantity;
        }
      }

      // Handle strict mode requirements
      if (!this.flexMode && remainingYield > 0.01) {
        alert('Cannot fully contain batch with available containers in strict mode');
        this.containersSelected = [];
      }
    },

    get totalContained() {
      return this.containersSelected.reduce((sum, container) => {
        const found = this.allowedContainers.find(c => c.id == container.id);
        return sum + (found ? found.storage_amount * container.quantity : 0);
      }, 0);
    },

    addContainer() {
      if (this.autoFill) {
        this.autoFillContainers();
      } else {
        this.containersSelected.push({ id: '', quantity: 1 });
      }
    },

    // Watch for changes that should trigger autofill
    init() {
      this.$watch('scale', () => {
        if (this.autoFill) this.autoFillContainers();
      });
      
      this.$watch('autoFill', (newValue) => {
        if (newValue) this.autoFillContainers();
      });
    },

    removeContainer(index) {
      this.containersSelected.splice(index, 1);
    },

    updateContainer(index, field, value) {
      if (field === 'id') {
        this.containersSelected[index].id = value;
      } else if (field === 'quantity') {
        this.containersSelected[index].quantity = parseInt(value) || 1;
      }
    },

    async checkStock() {
      try {
        const response = await fetch('/api/check-stock', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('input[name="csrf_token"]').value
          },
          body: JSON.stringify({
            recipe_id: {{ recipe.id }},
            scale: this.scale,
            containers: this.containersSelected
          })
        });
        const data = await response.json();
        this.stockResults = data.stock_check;
      } catch (error) {
        console.error('Error checking stock:', error);
        alert('Failed to check stock.');
      }
    }
  }
}
</script>

{% endblock %}
